1. Motivation

지하실에 있는 골동품 증기 기관차나 거실의 경마장에 있는 최신 포뮬러 원 경주차등
복잡한 기술 시스템을 관리 가능한 크기와 원칙으로 확장하면 모든 세대의 사람들을 매료시킬 수 있다.
하늘로 날아갈 수 있는 로켓을 만드는 것보다 더 고무시키는 것이 있을까 ?
가장 간단한 접근법에서는 별에 조금 더 가까이 가려면 빈 물병, 공기 펌프, 코르크 및 약간의 물이 필요하다.
이러한 이유로 물로켓은 장난감으로 간주되는 경우가 많지만 오해의 소지가 있다.
관련된 모든 물리학 요소에 대한 설명이 굉장히 복잡해진다.

이 논문에서 계산적인 방법으로 이 설명에 접근할 것이다.
첫 번째 부분에서는 합리적이지만 관리가 가능한 물로켓의 물리적 모델이 어떻게 공식화될 수 있는지 설명한다.
그러한 로켓을 시뮬레이션할 수 있게 된 후 두 번째 부분의 작업이 최적화된다.
모든 로켓 취미자들이 더 높은 고도를 비행하기 위해 노력하므로
주요 목표는 일부 매개변수를 변경하여 동일한 로켓으로 더 높은 원점에 도달하는 것이다.
또한 단일 매개 변수의 작은 변화가 물로켓에 미치는 영향을 분석한다.
이 모든 작업을 수행함으로써 물로켓의 물리학 및 행동에 대한 더 깊은 통찰력을 얻을 수 있다.

Figure 1.1. Advanced Water Rocket Axion V



2. Modeling

2.1. Overview

여기서 물로켓의 다양한 모듈과 이에 따른 통합 모델을 제시한다.
결국 모델의 단순화와 단점과 더 많은 단계를 추가하는 이점에 대해 논의한다.

Figure 2.1. Water Rocket Modules

그림 2.1 은 통합 모델의 모듈을 정의하는 물로켓에 작용하는 다양한 힘 F_i 를 보여준다.
이 모델은 시스템의 수치적 솔루션을 얻고 로켓의 성능을 특성화할 수 있다.

F_R = m_R * d(v_R) / dt = F_Th + F_G + F_D



2.2. Modules

2.2.1. Thrust

물로켓에 의해 생성된 추력 F_Th 는 아래의 잘 알려진 Tsiolkovsky 로켓 방정식

F_Th(t) = v_e(t) * d(m_R) / dt

에 의해 주어지는데, 여기서 노즐에서의 배기 속도(v_e) 와
전체 로켓 질량 m_R(t) 의 시간에 대한 미분이 결정되어야 한다.
여기서는 가속 과정을 두 부분으로 나눌 수 있다고 가정한다.
첫 번째 경우는 물이 빠져 나가는 동안 공기가 병을 떠나는 케이스다.
그 후 나머지 가압된 공기는 매우 빨리 팽창하여 로켓에 또 다른 짧은 추력을 준다.
이 분리식 (2.2) 에 의해 2 개의 방정식으로 나뉘며
나중에 가속 단계에 따라 시뮬레이션에서 사용된다.

추력을 계산할 때 중요한 문제는 rocket 내부의 공기가 어떻게 팽창하는지를 이해하는 것이다.
따라서 필요한 기능은 Shaviv 와 Finney 의 방법에 따라 주로 유도 된다.
팽창의 일반적인 시간 척도는 단지 약 1/10 초이며
PET 는 열전도율이 매우 작기 때문에 이 공정은 단열된 것으로 가정해도 좋다.
일반 물로켓 내부의 온도와 압력은 대기의 임계점에서
멀리 떨어져 있기 때문에 기체는 이상적으로 취급될 수 있다.
이러한 가정에 기초하여 식 (2.2)에 필요한 함수를 얻기 위해 기본 열역학 식을 사용할 수 있다.



* Water Thrust

물이 개구에서 밀려나는 과정은 아래의 베르누이의 방정식에 의해 기술된다.

p(t) + 0.5 * ρ_Water * v_in^2 = p_0 + ρ_Water * 0.5 * v_E^2

로켓 전체에 비례하여 내부의 압력 p(t), 대기압 p_0,
물의 밀도 ρ_Water 및 병 안의 물의 속도 v_in 으로 표기한다.
노즐의 유효 면적이 훨씬 작기 때문에 물의 이동 속도가 훨씬 빨라지고
로켓 내부의 물의 흐름을 나타내는 항은 무시될 수 있다.
위를 통해 배기 속도에 대한 아래 방정식을 얻는다:

v_E(t) = sqrt([2 * (p(t) - p_0)]/ρ_Water)

분명히 다음 단계는 병 내부의 압력을 시간의 함수로 결정하는 것이다.

Figure 2.2: Air Expansion inside the rocket

열역학에서 알 수 있듯이 Figure 2.2 에서 볼 수 있듯이
기체는 초기 압력 p(0) 과 부피 V_A(0) 에서
시간 p(t) 및 V_A(t) 의 다른 상태로 팽창하며, γ 는 단열 계수에 해당한다:

p(0) * V_A^γ(0) = p(t) * V_A^γ(t) => p(t) = p(0) * (V_A(t) / V_A(0))^-γ

이제 물의 부피 V_W(t) 를 사용하여
공기량을 V_A(t) = V_A(0) + (V_W(0) - V_W(t)) 로 나누면 아래 식이 된다:

p(t) = p(0) * ([V_A(0) + (V_W(0) - V_W(t))]/ V_A(0))^-γ
     = p(0) * (1 + [m_W(0) - m_W(t)] / [ρ_Water * V_A(0)])^-γ

여기서 ρ_Water = m_W(t) / V_W(t) 는 물의 밀도다.
총 로켓 질량 m_R(t) = m_W(t) + m_A(t) + m_0 는
물 m_W 와 공기 질량 m_A 뿐만 아니라 빈 로켓 자체의 무게 m_0 으로 구성된다.
이 과정에서 일정한 m_A(t) 를 초래하는 공기가
병을 떠나지 않는다고 가정하면 최종 압력 관계를 얻을 수 있다.

p(t) = p(0) * (1 + [m_R(0) - m_A(0) - m_0 - m_R(t) + m_A(t) + m_0] / [ρ_Water * V_A(0)])^-γ
     = p(0) * (1 + [m_R(0) - m_R(t)] / [ρ_Water * V_A(0)])^-γ

그래서 로켓 질량에 대한 함수를 찾는 것이 해결할 마지막 문제다.
이것은 구경 영역 A_N 이 있는 노즐에서의 물 질량 유량을 보면 쉽게 알 수 있다:

d(m_R) / dt = d(m_W) / dt = ρ_Water * d(V_water) / dt = ρ_Water * A_N * v_E(t)



* Air Thrust

모든 물이 밀려나면 병 내부의 공기가 여전히 가압되어 매우 빠르게 팽창하여 추력을 추가로 발생시킨다.
일반적으로 이 공기 팽창은 물이 있는 공기 팽창과 매우 유사하므로
배기 속도에 대한 방정식은 이전과 동일하다.

v_E(t) = sqrt([2 * (p(t) - p_0)]/ρ_A)

알 수 있듯이, 유일한 차이점은 물 밀도를 공기 밀도 ρ_A 로 대체한 것이다.
단열 과정은 공기가 한 부분 V_(A, o) 가
병 외부에 있는 부피로 팽창하기 때문에 더 많은 힘이 필요하다.
이것은 총 로켓 부피 V_R 을 사용하여 아래와 같이 나타낼 수 있다.
이는 특정 시간(t = t0 으로 선택됨)에서 시작하는 새로운 절차라는 점에 유의해야 한다.

p(t) = p(t_0) * (V_A(t) / V_A(t_0))^-γ
     = p(t_0) * ([V_R + V_(A, o)(t)] / V_R)^-γ
     = p(t_0) * (1 + [m_(A, o)(t)] / [ρ_A * V_R])^-γ
     = p(t_0) * (1 + [m_(A, i)(t_0) - m_(A, i)(t)] / [ρ_A * V_R])^-γ

색인 i 와 o 는 로켓 내부의 질량 또는 체적을 나타낸다.
마침내 로켓 내부의 공기 질량 함수만 결정하면 된다.
필요한 초기값 m_(A, i)(t_0) 에 대해 밀도는 압력의 함수이며, R 은 특정 기체 상수고, T 는 온도다.
여기서 ρ'_A(p) = p / (R_S * T) 로 나타낼 수 있다.
그러나, m_(A, i)(t) 를 계산하기 위해 어떤 압력을 사용할지 명확하지 않다.
공기가 노즐에서 얼마나 팽창했는지 확실하지 않기 때문이다.
표준 조건에서 압력을 사용하도록 한다.

m_(A, i)(t_0) = m_(A, i)(0) = V_A(0) * ρ'_A(p) = V_A(0) * p(0) / (R_S * T)
d[m_(A, i)] / dt = ρ_A * A_N * v_E(t)



2.2.2. Gravitation

로켓 궤도에 영향을 미치는 한 가지 중요한 힘은 중력이다:

F_G = m_R(t) * g

로켓 질량은 이전 섹션에서 이미 결정되었으며 중력 가속도 g 는 일정하다고 가정한다.
이 가정은 2.3.2 에서 더 논의될 것이다.



2.2.3. Drag

전체 힘에 대한 아래 항은 로켓에 작용하는 항력이다:

F_D = 0.5 * c_D * ρ_A * A * v_R^2

혹은 벡터 형태로 두면 아래와같다:

F_d = -0.5 * c_D * ρ_A * A(v_R.v_R) * (v_R / ||v_R||)

이 형태는 Drag Force(항력)이 항상 로켓의 속도 벡터를 가리키므로
상승뿐만 아니라 강하를 억제함을 보증한다.
항력 계수 c_D 와 기준 면적 A 의 결정은 중요한 문제는 아니지만
풍동(Wind Tunnel) 실험에서 모델 로켓에 대해 측정되었다.



2.2.4. Resulting Model

결과를 다시 요약하기 위해 이 모델을 설명하는 모든 방정식이 여기에 나열되어 있다:

m_R * (dv_R / dt) = v_e(t) * (dm_R / dt) + m_R(t) * g - 0.5 * c_D * ρ_A * A * (v_R.v_R) * (v_R / ||v_R||)

Water Thrust Phase:

v_E(t) = sqrt([2 * (p(t) - p_0)] / ρ_Water)
p(t) = p(0) * (1 + [m_W(0) - m_W(t)] / [ρ_Water * V_A(0)])^-γ
dm_R / dt = ρ_Water * A_N * v_E(t)

Air Thrust Phase:

v_E(t) = sqrt([2 * (p(t) - p_0)] / ρ_A)
p(t) = p(t_0) * (1 + [m_(A, i)(t_0) - m_(A, i)(t)] / [ρ_A * V_R])^-γ
dm_(A, i) / dt = ρ_A * A_N * v_E(t)



2.3. Limitations

통합 모델을 정의한 후에 이 단점과 한계가 고려될 것이다.



2.3.1. Wind effects

개발된 모델은 2.2.3 에서 설명된 정면 항력만을 고려한다.
crosswind 와 같은 추가 효과를 전체적인 복잡성에 포함시키는 것이 매우 어렵다.
일관성 있는 설명을 위해서는 Navier-Stokes 방정식을 풀어야 한다.
이 방정식은 상상을 초월할정도로 어렵다.
따라서 이러한 효과는 모델에서 완전히 무시된다.
문제는 실제 풍동에 영향을 줄 수 있는 영향력이다.
첫째로, 단순히 로켓의 곧은 상승을 방해할 것이다.
모든 방정식은 작용력이 서로 평행 또는 반 평행하다고 가정한다.
로켓이 공중에서 조금 기울게되면 crosswind 가 발생하면서 전체 힘의 구성이 부정확해질 수 있다.

Figure 2.3: Magnus Effect

이 모델에서 무시된 또 다른 힘의 기여는 Magnus Effect 를 기반으로 한다.
이것은 유체를 통해 움직이는 회전하는 물체에서 발생하는 힘을 기술한다.
이 힘은 항상 운동 방향과 회전축에 수직하다.
모델 로켓은 발사 과정의 결과 혹은 안정화 목적에 따라 오름차순으로 회전하고 있다.
따라서 바람이 로켓의 측면을 때리면 Magnus 힘은 풍향과 직각이 되어 옆으로 잡아당길 것(그림 2.3)이다.
앞서 언급하였듯이 이 모델에서 다루는 정보를 벗어나 로켓을 기울일 수 있게 된다.

요약하면 바람은 수직으로 올라가는 로켓의 상승을 매우 많이 방해한다.
따라서 모델 로켓의 비행 행동을 예측하는데 있어 바람을 주요 오류 원인으로 꼽는다.
불행히도 모델에서 자세히 고려하기란 너무 어렵다.
어쨋든 취미 우주 비행사는 바람이 부는 날에 작업을 하지 않을 것이며
이 근사를 정당화하는 로켓의 모델링이 모두 무너지게 될 것이다.



2.3.2. Non-constant pressure and gravitation

앞에서 언급했듯이 기압과 중력은 높이에 따라 감소한다.
방정식 2.16 과 2.19 는 주어진 내부 압력에서
더 작은 공기 압력은 더 큰 배기 속도와 추력을 만들어냄을 보여준다.
또한 감소된 중력 가속도는 식 2.13 에서 볼 수 있듯이 보다 작은 힘을 유발한다.
두 효과 모두 로켓의 고도를 더 높일 수 있다.
두 가지의 중요성을 분석하기 위해 일부 추정치가 사용된다.

압력 변화는 대기압 공식에 의해 주어진다.
정상적인 물로켓은 수백 미터까지 작동하기 때문에 이 지수 함수는 선형화될 수 있으며,
이는 근사치 ∆p = 1/8 hPa/m·∆h 를 제공한다.
마찬가지로 간단한 근사식을 중력 가속도에 대해 기술할 수 있다:
∆g = 3.1µm/s 2·∆h
5000 hPa 의 내부 압력, 총 로켓 중량은 0.5 kg 이고 200 m 의 도달 높이를 가정하면
Water Thrust 단계 동안 이러한 효과가 있던 없던 로켓 모델에서의 차이는 미미하다:

∆v_E = 620 µm/s
∆F_G = 310 µN

물로켓의 전형적인 값은 v_E = 20 m/s, F_G = 200N 이다.
그 외에도 공기압이 떨어지면 방정식 2.11 에서 이미 보았듯이 공기 밀도가 낮아진다.
이것은 방정식 2.14 의 Drag Force(항력)을 소량으로 줄인다.
이전 매개변수들에 대해, c_D = 0.5 의 항력 계수, 
A = 0.01 m^2 의 표면과 v_R = 10 m/s 의 로켓 속도는
ΔF_D = 15 mN 일 뿐이므로 이 효과 또한 무시할 수 있다.



2.3.3. Water Flow

모델은 베르누이의 식에 기초하고 있기 때문에
유출은 층류 유동 체제로 이상화된 것으로 가정할 수 있다.
팽창하는 공기는 내부에 물이 남아있지 않을 때까지 병에서 물을 밀어내는 피스톤으로 볼 수 있다.
이후 남아있는 압축 공기가 배출된다.
불행히도 이것은 그림 2.4 에서 보여지는 것처럼 실제에 의해 지원되지 않는다.
이 사진들은 리즈 대학교(University of Leeds)의
요하네스 냅(Johannes Knapp) 박사가 조직한 물로켓 워크샵에서 찍은 사진이다.
유출이 모델에서 가정한 첫 층류인것처럼 보인다.
그러나 로켓 내부에서 물은 공기와 섞여서 끝까지 더 격렬한 유출이 발생한다.
따라서 물과 공기 추력 단계 사이의 엄격한 분리는 다소 비현실적이다.

또한 피스톤 유추법과 달리 물은 병 안에서 일정한 유속을 가지고 있지 않다.
현실적인 유동장은 매우 복잡하며 베르누이의 방정식으로 설명할 수 없다.
이것은 병 내부에 더 많은 Drag 를 유도하여 유출 속도를 낮추게 된다.

Figure 2.4: Water Exhaust

따라서 바람과 더불어 물의 흐름은 모형의 또 다른 주요 불확실 요인이며 무시해야 한다.
난기류의 시뮬레이션은 복잡한 모델을 포함하는 매우 어려운 작업이기 때문에 무시해야 한다.



2.3.4. Imbalances

이미 언급했듯이 이 모델은 평행 또는 역평행 힘을 가정한다.
옆에서 바람이 불면 로켓 자체의 불균형이 발생하여 이 가정을 무효로 만들 수도 있다.
물이 병에서 흘러 내림에 따라 무게 중심이 위쪽으로 움직인다.
탱크가 비게되면 로켓의 불안정성과 기울기가 증가한다.
부정확성으로 인해 무게 중심이 옆으로 치우쳐 로켓이 스스로 기울어지게 된다.
이러한 문제와 관련하여 모델은 오히려 낙관적인 예측이며 영리한 설계로 도달할 수 있다.



2.4. Multi-Staging

모델에 대한 방정식을 유도한 후 단일 단계 로켓에는 매우 엄격한 제한이 있음이 분명하다.
예로 병 안의 압력이 높으면 항상 부작용없이 더 많은 힘을 가할 수 있다.
물론 어느 시점에서 가압 공기로인한 체중 증가가 현저해질 수 있지만 훨씬 더 일찍 병이 파열된다.
또한 더 높은 용적이 우수하지만 결과적으로 병의 구조적 완전성이 감소될 수 있으며
따라서 최대 압력을 제한할 수 있다.

Turner 혹은 Messerchmid 와 Fasoulas 가 설명한 것처럼
이러한 한계를 극복하기 위해 다단계 시스템을 구축하는 것은 매우 직관적인 단계다.
화학 로켓을 고려할 때, 이전에 들어 있던 연료가 점화된 후
특정한 빈 부피(연료통)을 떨어 뜨리는 것은 논리적이다.

Figure 2.5: Two-Stage Water Rocket

이후에 로켓은 더 적은 무게를 지니므로 더 효율적이다.
물로켓의 경우 Staging 이 훨씬 논리적인 것처럼 보인다.
식 2.9 는 배기 속도와 추력이 압력에 크게 의존함을 나타낸다.
따라서 더 많은 Stage 는 불필요한 무게를 없앰으로써 보다 높은 효율을 얻을뿐만 아니라
높은 배기 속도를 보다 많은 단계동안 오래 제공할 수 있다.
이것은 물로켓의 최적화를 위한 Multi-Stage 계획의 중요성을 보여준다.
예를 들어, 추력 단계를 증가시키기 위해 하나 또는 2 개의 큰 단계 대신 많은 작은 단계를 구현할 수 있다.
이 최적화 아이디어 및 다른 최적화 아이디어에 대해 보다 자세히 설명한다.

다행스럽게도 더 많은 Stage 를 기술하는데 추가 방정식이 필요하지 않다.
Multi Stage 시스템은 여러 개의 Single Stage 로켓을 추가한 것으로 볼 수 있다.
모든 것들은 분리 점에서 높이와 속도를 아래 Stage 로 전달한다.
활성 단계 위에 있는 다른 모든 단계는 추가 페이로드 역할을 한다.
그러므로 Multi-Stages 의 구현은 다소 간단한 작업이며
보다 아래에서 Single Stage 로켓의 시뮬레이션 및 특정 최적화 방법과 함께 제시될 것이다.



3. Numerical Implementation

3.1. Flight Diagnostics

로켓 파라미터를 최적화하기 전에 소위 "전체 출력" 프로그램이 필요하다.
이것은 방정식 (2.15) - (2.21) 을 풀고 진단을 해야 한다.
프로그램의 기능은 여기서 설명된 예제 테스트의 끝 부분에서 사용된다.



3.1.1. Functionality

Figure 3.1: Flow Chart of the Single-Stage Program

Figure 3.1 은 프로그램이 일반적으로 어떻게 작동하는지 보여준다.
처음에는 로켓의 매개 변수를 결정해야 한다.
이들을 사용하여 해에 대한 초기값을 계산할 수 있다.
모든 다른 값은 방정식 2.15 - 2.21 방정식의 계단식 시간 적분에 의해 얻어진다.
매 단계마다 시간, 압력, 로켓 질량, 로켓 속도, 배기 속도, 높이 및 추력 값을 추후 분석을 위해 작성한다.
미분 방정식을 푸는데 사용되는 적분기는 명시적인 오일러 알고리즘이다.

y_i(x_0 + h) = y_i(x_0) + h * y_i'(x_0)

그러므로 프로그램은 함수 y_i(x) 를 작은 시간 간격 h 를 통해 직선으로 근사한다.
물론 이 알고리즘은 4 차 Runge-Kutta 방법과 같은 고차 체계보다 덜 정확하지만
해결해야할 방정식이 너무 복잡하지 않기 때문에 다소 단순한 수치 접근법이 적합하다고 본다.

오일러 알고리즘의 정확도는 선택한 시간 간격에 따라 크게 달라진다.
예를 들어 아주 작은 초기량의 물이 로켓 내부에 있다면
비어있는 것이 알고리즘 동작 과정에서 발생할 수 있고
이것은 비현실적으로 높은 추력을 발생시킨다.
이러한 이유로 동적 타임 스텝핑이 코드에 포함된다.
변수의 시간 변화를 확인하고 이러한 변화가 적당한 간격 내에 있을 때까지 시간 간격을 조정한다.
유감스럽게도 Drag 조건은 에너지 보존을 파괴하므로 그러한 유효성 검사는 불가능하다.



3.1.2. Test Run

모든 Module 이 프로그램에 포함된 후 첫 번째 Test 는 해당 기능을 보여준다.
아래와 같은 물로켓 매개변수가 선택되었다.

초기 내부 압력: p_0 = 5.101325 Pa
총 로켓 부피: V_0 = 1.5 L
초기 물 부피: V_W = 0.75 L
텅빈 로켓 무게: m_0 = 300 g
노즐 반경: r_N = 1 cm
병 반경: r_B = 4 cm
항력 계수: C_D = 0.5

이러한 매개 변수로 시뮬레이션된 로켓은 실험 데이터와 일치하여 24.3 m 의 정점에 도달한다.
Figure 3.2 는 로켓의 높이와 속도를 공기 추력의 유무와 시간의 함수로 나타낸 것이다.
로켓이 가속하는 실제 추력 단계는 2 분의 1 초 미만으로 지속된다.
이후에 비행은 기본 포물선 궤적과 유사하다.
Drag 와 중력만이 로켓에서 작용하기 때문이다.
그러므로 1 / 10 초 내에서 더 흥미로운 부분이 그림 3.3 과 3.4 에 그려져 있다.
공기 추력 항은 항상 여기에 포함된다.
그림 3.3 에서 2 개의 추진 단계를 쉽게 확인할 수 있다.
0.125 초에서 공기 추력 단계가 시작된다.
이 단계는 이전보다 훨씬 짧으며 속도가 훨씬 빠르다.
그러나 배출된 질량 또한 훨씬 적기 때문에(그림 3.4 참조) 추력은 물이 있는 것보다 다소 적다.
궤적에 대한 공기 추력의 영향은 그림 3.2 에 나와있다.
점선은 남아있는 방치된 압축 공기에 대한 프로그램 실행을 나타낸다.
분명히 최대 속도에 미치는 영향은 적지만
여전히 로켓의 약 7% 정도 더 높게 영향을 미치므로 무시할 수 없다.

그림 3.4 는 또한 프로그램 내의 오류를 보여준다.
압력이 이미 대기 수준 이하로 떨어지는 동안
질량은 빈 로켓 질량과 공기 질량 내부로 되돌아가지 않았다.
그 이유는 기체 유출에 대해 일치하지 않는 기술이지만 받아들일 수 있는 작은 것이다.

Figure 3.2: Test run: Height(blue) and Velocity(red), with (solid) and without (dashed) air thrust

Figure 3.3: Test run: Thrust(blue) and Exhaust Velocity(red)

Figure 3.4: Test run: Total Rocket Mass



3.1.3. Multi-Staging

Single Stage 시뮬레이션을 수행한 후 다음 단계는 하나 이상의 추가 Stage 를 구현하는 것이다.
이는 추가 페이로드가 있는 독립적인 Single Stage 와 같다.
그러므로 그림 3.5 와 같이 Multi-Stage 프로그램이 작동한다.
"Rocket Simulation" Box 는 그림 3.1 의 회색 상자를 나타낸다.
위에서 볼 수 있듯이, 첫 단계는 위의 Stage 에서 추가 무게를 얻는다.
두 번째 단계는 높이와 속도에 대해 0 이 아닌 초기값을 갖는 Single Stage 프로그램의 두 번째 호출이다.
이것들은 첫 번째 단계의 최종 값에 의해 주어지며 따라서 Stage 분리의 시간에 의존한다.
추가 프로그램 호출만 필요하기 때문에 프로그램을 Stage 추가로 쉽게 확장할 수 있다.



3.2. Optimisation

물로켓을 최적화하기 위해서는 입력 매개변수가 달라지는 알고리즘이 필요하다.
로켓에 의해 도달된 원점은 최적화될 매개변수가 된다.
이 섹션에서는 적용된 알고리즘을 소개하고 매개 변수에 대한 설명은 아래서 설명한다.



3.2.1. Monte Carlo Method

Dickman and Gilman 에 의해 기술된 바와 같이
Monte Carlo 는 통계적 접근에서 최적화를 위해 매우 쉽게 사용될 수 있다.
하나는 많은 솔루션(약 백만 가지)을 생성하여 최적을 찾는다.

Figure 3.5: Flow Chart of the Two-Stage Program

이러한 솔루션의 매개변수는 특정 간격 내에서 무작위로 선택된다.
다중 레벨 알고리즘에 의해 개선될 수 있는데
이는 획득된 최적값을 매개 변수의 더 좁은 간격에 대한 새로운 중심점으로 사용한다.
이것을 반복함으로써 수치적 최적을 높은 정확도로 얻는다.
뉴턴(Newton) 이나 Gradient Descent 와 같은 결정론적 알고리즘과는 대조적으로
이 방법의 단점은 훨씬 더 높은 계산 시간과 실제 최적치까지에 대한 정보가 없다는 사실이다.
장점은 Monte Carlo Scan 이 최적을 제공할뿐만 아니라 솔루션 토폴로지에 대한 설명을 제공한다는 것이다.
따라서 이 방법이 주 최적화 도구로 선택되었다.



3.2.2. Gradient Ascent

이전에 소개된 Monte Carlo 최적화 절차를 확인하기 위해서 다른 알고리즘도 프로그램에 포함되었다.
일반적으로 Gradient Descent 방법으로 알려져 있지만
검색된 최적값이 로켓의 최대 높이이므로 Gradient Ascent 라는 이름이 더 적합하다.
알고리즘은 임의의 매개 변수 점에서 시작한 다음 모든 매개 변수 방향(앞뒤)에 대한
Gradient 를 계산하는 반면 다른 매개 변수는 일정하게 유지한다.
이후 가장 높은 상승을 가진 방향이 탐색이 계속되는 방향으로 선택된다.
양수 상승이 발견되지 않으면 step 길이가 짧아진다.
알고리즘은 적어도 하나의 방향이 제로 상승을 나타낼 때까지 반복되고
다른 모든 방향은 0 이 될 때까지 반복된다.
이 점이 최적을 나타낸다.

물론 알고리즘은 로컬 최대값을 찾지 못하는 경우에도 완료될 수 있다.
두 가지 방법을 조합하면 매우 유용하다.
Monte Carlo Scan 으로 알려진 매개 변수 공간의 토폴로지를 사용하면
Gradient Ascent 에서 찾은 최대값이 전역인지 로컬인지를 쉽게 결정할 수 있다.
Monte Carlo 알고리즘이 Gradient Ascent 방법의 시작점을 무작위로 선택하는 방법조차도 가능하다.
이 특별한 문제에서 그러한 Hybrid 는 필요하지 않다.



3.2.3. Enhanced Program

Figure 3.6: Flow Chart of the Optimisation Programs

2 가지 최적화 방법의 구현이 그림 3.6 에 나와 있다.
Monte Carlo 에는 랜덤 생성기와 알고리즘이 추가되어 결과를 비교하고 최대 원점으로 매개 변수 집합을 저장한다.
반면에 Gradient Ascent 는 매개 변수 공간의 모든 방향에 대한 프로그램 호출과 새로운 시작점을 얻기 위해
각 방향을 평가하는 알고리즘이 있어야하기 때문에 조금 더 복잡하다.
오른쪽 흐름도의 상자 "Rocket Simulation" 은 왼쪽 차트에서 같은 색의 상자를 나타낸다.
끝나면 두 방법 모두 최고점으로 설정된 매개 변수를 반환한다.
Monte Carlo 는 또한 모든 매개 변수 집합과 매개 변수 공간 토폴로지의 추가 분석을 위한 해당 높이를 저장한다.
두 알고리즘의 성능은 아래에서 설명한다.



4. Results

4.1. Parameters

여기선 Single 및 Multi-Stage 물로켓의 매개 변수가 최적화 가능성을 고려하여 평가될 것이다.
이러한 매개 변수는 아래와 같다:

초기 내부 압력: p_0
텅빈 로켓 질량: m_0
노즐 반경: r_N
병 반경: r_B
항력 계수: C_D
전체 로켓 부피: V_0
초기 물 부피: V_W
분리 시간: t_sep

항력 계수, 빈 로켓 질량, 병 반경 및 총 로켓 부피를 배제할 수 있다.
이 최적화의 목적은 주어진 부피, 치수 및 빈 중량으로 로켓에 대한 이상적인 매개 변수를 찾는 것이다.
이에 대한 결론은 이것들의 최적화가 무의미하다는 것이다.
또한, 보다 작은 항력 계수는 항력을 억제하는 강도를 조정하기 때문에 항상 더 좋다.
그러므로 최적화는 엔지니어링 문제보다 더 중요하며 매개 변수는 주어진 것으로 간주된다.
방정식 2.16 과 2.19 는 압력 차가 클수록 배기 속도가 더 빨라짐을 나타낸다.
유일한 부정적인 영향은 공기 질량이 증가하는 것이다.
공기의 밀도가 매우 낮기 때문에 무시해도 된다.
압력의 한계는 로켓의 재료에 의해서만 주어진다.
따라서 모든 추가 최적화 작업에서 일반적인 압력이 적용된다.
나머지 매개 변수는 이제 더 자세히 논의될 것이다.
달리 지정하지 않으면 모든 개별 Stage 의 매개 변수는 3.1.2 와 동일하게 취급하도록 한다.



4.1.1. Nozzle Radius

모델을 살펴보면 노즐의 반경이 로켓의 성능에 어떤 영향을 미치는지 분명하지 않다.
분명히 반경이 커질수록 질량의 시간 도함수가 증가한다.
그 결과 더 많은 추력이 발생한다.
다른 한편으로는 병을 더 빨리 비워서 추력의 시간을 줄인다.
이것은 두 가지 시나리오를 남긴다:

최적 노즐 반경이 존재하거나 더 높은 반경이 항상 원점을 증가시킨다.
0 과 병의 반지름 사이에서 변화하는 다른 노즐 반지름에 대한
Monte Carlo Scan 은 그림 4.1 에서 곡선을 나타냈다.

Figure 4.1: Monte Carlo Scan of the Nozzle Radius

알 수 있듯이 이 매개 변수 공간에는 최적이 없다.
또한 병의 반경에 가까워지는 동안 높은 배기 속도에 비해 느린 내부 물 운동의 가정은 무효가 된다.
따라서 더 높은 노즐 반경에서는 전체 모델이 더 이상 유효하지 않다.
더 복잡한 유체 모델을 적용하여 최적의 반경을 얻을 수 있다.
그러나 이 작품의 모델 안에서는 그것을 발견할 수 없다.
다행스럽게도 물로켓의 일반적인 노즐 반경은 약 1 cm (물병) 혹은 그 보다 훨씬 적다(예: 가자미 노즐)
따라서 이 매개 변수는 이후에 주어진 것으로서 취급될 것이다.

도표에는 일정한 폭의 톱니 형태가 있음을 주목할 수 있다.
이 문제는 추가 Scan 에서 발생하며 나중에 자세히 분석된다.



4.1.2. Seperation Time

분리 시간은 Multi-Stage 로켓에만 적용된다.
하단 단계가 해제될 시점을 정의한다.
가능한 2 가지 시나리오로는 최대 로켓 속도 혹은 원점에서 분리하는 것이 그럴듯하다.
일반적인 화학 로켓은 현재 단계의 연료가 완전히 점화될 때 분리되며 첫 번째 옵션을 선호한다.
또한 불필요한 질량을 일찍 떨어뜨리면 로켓 추진력이 높아져 최고점이 증가한다.
따라서 이론적으로 떨어지는 것은 연료를 다 소진하면 발생해야 한다.
이전에 소개된 최적화 알고리즘을 통해 이를 검증할 수 있다.

분리 시간에 대한 최대 높이의 영향은 그림 4.2 (파란색) 에 나와있다.
빨간선은 분리가 없는 로켓 속도를 보여준다.

Figure 4.2: Monte Carlo Scan of Separation Time (blue) and Velocity of the First Stage (red)

점선은 최적화된 분리 시간 및 최대 속도가 동시에 발생하는 것을 볼 수 있다.
따라서 이 첫 번째 최적화 이론에 부합하므로 적용된 Monte Carlo 알고리즘의 유효성을 나타낸다.
결과적으로 모든 추가 프로그램 실행에서 현재 Stage 의 최대 속도시 Stage 가 분리된다.



4.1.3. Initial Water Volume

물로켓의 마지막 자유 매개 변수는 병 내부의 초기 물량
또는 보다 일반적인 형태로 물과 공기량의 비율 V_(W, 0) / V_(A, 0) 이다.
인터넷에서 검색할 때 1/3 에서 1/2 사이에 다양한 값을 찾는다.
이러한 변동의 이유는 아래에서 살펴볼 것이다.
더 많은 시뮬레이션 결과에 따르면 공기와 물의 비율은 물로켓의 중요한 매개 변수중 하나일 수 있다.
작은 변화만으로도 최대 비행 고도에 중요한 차이가 생긴다.
Multi-Stage Rocket 을 제작할 때 모든 단계가 동일한 최적 비율을 가지지는 않기 때문에 더욱 중요하다.

물과 공기의 비율이 최적화에 결정적인 요소임을 분명하게 알 수 있다.
따라서 아래에서는 Single 및 Double Stage 로켓에 대해 이 매개 변수를 최적화한 결과를 살펴볼 것이다.
그 다음으로 마지막에서 Simulation 의 적응성을 보여주기 위해 더 많은 이국적인 최적화 모델을 설명한다.



4.2. Single-Stage Optimisation

4.2.1. Monte Carlo and Gradient Ascent

Figure 4.3: Monte Carlo (green) and Gradient Ascent (blue) Optimisation

Monte Carlo 최적화를 위해 1 과 0 사이의 100 만개의 랜덤 연료비
V_(W, 0) / V_(A, 0) 로 프로그램의 입력으로 준비되었다.
Gradient Ascent 알고리즘의 시작점은 2/3 으로 선택되었다.
두 가지 최적화를 모두 마친 후에는 데이터가 하나의 차트로 그려져 (그림 4.3) 방법간의 차이를 보여준다.
결과는 아래와 같다:

Monte Carlo: V_(W, 0) / V_(A, 0) = 0.3938,   H_max = 26.4467 m
Gradient Ascent: V_(W, 0) / V_(A, 0) = 0.4245,   H_max = 26.2758 m

이미 알려진 바와 같이 Gradient 방법은 Monte Carlo 와 같은 최대값을 찾을 수 없다.
도표의 확대된 부분을 보면 함수의 분포 폭이 뚜렷하게 나타난다.
이것은 Monte Carlo Scan 의 오차가 아니라 적분기의 오차다.
이것은 그림 4.4 에서 더욱 분명해진다.
오른쪽 그림은 최고점에 아주 가까운 모습을 보여준다.
오일러 방법은 두 점 사이의 간격을 선으로 채운다.
따라서 최대값은 시간 간격에 의해 결정된다.
그림에서 가장 높은 지점은 imaginary real parabola 의 가장 높은 지점이 아닌것 같다.
이제 연료 비율의 모든 미세한 변화는 로켓이 더 높이 날 수 있다는 효과를 가져오지만 더 길어진다.
그러므로 다음으로 높은 최고점은 현재의 최고점 옆으로 이동한다.
물론 주기적인 거리에서 발견된 최고점은 포물선의 최대값과 일치한다.
하지만 Monte Carlo 에서 발견되는 다음 매개변수의 경우
다른 매개변수가 실제 최대값에 도달할 때까지 오차가 계속 발생한다.
결과는 왼쪽 그림에서 확대된 Monte Carlo Scan 을 볼 때 드러나는 Strip Pattern 이다.

이 때문에 솔루션에는 인공적인 최대값이 많이 있다.
불행히도 Gradient Ascent 는 단계별 크기가 너무 작아 다음 최대값에 도달할 수 없을 때 끝난다.
이에 대한 유일한 해결책은 고차원 적분기를 구현하는 것이다.
그러나 Monte Carlo 가 여전히 좋은 결과를 산출하고 있기 때문에 적분기가 유지되는 것이 결정되었다.
그러나 Gradient Ascent 방법은 속도 측면에서 매우 유용한 것으로 판명된 교차 검사 외에 더 이상 사용되지 않는다.

Figure 4.4: Magnified Monte Carlo Scan (left) and Trajectory (right)



4.2.2. Pressure Dependency

5 분의 2 정도의 최적을 달성한 후에도 인터넷에서 발견되는 값이 왜 그렇게 다른지 의문이다.
몇 가지 추가 시뮬레이션을 한 후에는 그 비율이
이전에 최적화에서 제외된 다른 매개 변수에 크게 의존한다는 것이 분명해졌다.
압력은 변화하기 쉬운 매개 변수이므로 다른 최적화를 위해 선택되었다.
이를 위해 Monte Carlo 프로그램이 약간 변경되었다.
두 번째 Monte Carlo Loop 가 기존 Loop 와 결합되었다.
첫 번째 Loop 가 최적의 연료 비율을 검색하는 동안 두 번째 Loop 는 내부 압력을 변화시킨다.
이것에 의해 압력에 대한 최적의 연료 비율의 차트를 얻는다.
결과는 그림 4.5 에서 볼 수 있다.
예상대로 연료 비율은 명확한 압력 의존성을 나타낸다.
그래프의 왼쪽 상단에 있는 작은 선이 한 지역 내에 있으며
로켓은 거의 높이가 없어 무시할 수 있다.

Figure 4.5: Pressure Dependent Optimum Fuel Ratio

불행히도 그래프는 2 개의 Monte Carlo 알고리즘을 동시에 실행해야 하기 때문에 드문 드문하다.
관리 가능한 제한 범위 내에서 계산 시간을 포함하려면 Loop 수를 줄여야 한다.
따라서 실제 최대 값은 이전 실행에서와 같이 정확한 것으로 결정될 수 없었다.
숫자에서는 각 Monte Carlo 로 실행에 대해 단지 1000 개의 연료 비율과 10000 회의 압력이 최적화에 적용되었다.
전에 사용된 100 만개의 연료 비율과 비교하면 이 작은 숫자는 확대 그래프를 설명한다.
다행히도 결과는 기능적 추세를 파악하기에 충분하다.
그러나 추가 계산은 병렬 프로그래밍으로 추가 계산 시간을 보완하면서 많은 수의 매개 변수 집합을 사용해야 한다.



4.3. Two-Stage Optimisation

4.3.1. Monte Carlo

Monte Carlo 방법이 Gradient Ascent 보다 분명히 우월하다는 결론을 얻은 후에
Two-Stage 로켓의 최적화는 Monte Carlo 로만 이루어진다.
Single Stage 최적화 외에도 두 번째 연료 비율이 필요하므로
2 개의 부피를 따로 따로 최적화할 수 있다.
최적화된 비율은 아래와 같다:

First Stage: V_(W, 0) / V_(A, 0) = 0.4577
Second Stage: V_(W, 0) / V_(A, 0) = 0.3423

Figure 4.6: Two-Stage Rocket: Monte Carlo Optimisation

이 비율로 모의 실험된 2 단계 로켓은 45.3973 m 의 정점에 도달할 수 있었다.
분명히 이것은 Single Stage 로켓과 비교할 때 큰 이점이다.
두 로켓 모두 최적의 비율이 다르다는 것은 매우 흥미롭다.
더 나은 시각화를 위해 그림 4.6 의 매개 변수 공간의 토폴로지가 3 차원으로 그려진다.
분명히 높이와 두 연료비 사이에는 다소 복잡한 기능 종속성이 있다.
두 번째 연료 비율이 1 로 향하는 동안 비행 높이가 0 으로 떨어지는 사실은 적용된 프로그램 때문이다.
두 번째 단계는 양의 속도에 대해 충분한 추력을 생성하지 않지만
첫 번째 단계에서는 여전히 일정한 높이에 도달할 수 있다.
그러나 이 최적화는 Two-Stage 로켓 전용이므로
시작 단계가 없는 모든 결과는 "높이에 도달하지 않았다" 라고 한다.



4.3.2. Pressure Dependency
