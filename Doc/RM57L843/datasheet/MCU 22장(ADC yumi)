22장
ADC(Analog to Digital Converter) : 아날로그에서 디지털신호로 바꾸는 변환기

22.1 오버뷰

마이크로 컨트롤러가 ADC모듈의 두개까지  구현을 한다.
ADC의 주요 기능:

*10비트 또는 12비트로 선택가능함
*연속 근사 레지스터 아키텍터 구조이다.
*3개의 변환 그룹을 가지고 있다: 그룹1, 그룹2, 이벤트 그룹
*3개의 변환 그룹은 하드웨어에 트리거 되는 구성으로 되어있고, 소프트웨어에 의해 트리거 되어질수도 있다.
트리거: 어떤 신호르 동작시키거나 정지시키는것.
*변환된 결과는 64워드 메모리로 저장된다(SRAM).
 -이 64단어는 세개의 변환그룹으로 나뉘어서 소프트웨어별로 구성되어진다.
 -변환 결과 RAM에 대한 엑세스는 패리티로 보호가된다.
 -변환 결과 전송을 위한 DMA요청을하는데 이 옵션들이 여러가지 있다.
*선택 가능한 채널 변환 순서
 -채널번호의 오름차순으로 순차적인 변환
 -향상된 채널 선택모드로 된 사용자 정의 채널변환 순서
*향상된 채널선택 모드는 ADC1에서만 사용할수 있다.
*단일 또는 연속변환 모드들이 있다.
*내장된 셀프테스트로직은 입력채널오류감지를 위한 로직이다.(오픈,단락,접지에 대한 단락)
*내장된 보정로직은 offset오류보정을 위한 로직이다.
*강화된 파워 다운 모드가있다.
*외부이벤트 핀(ADEVT)은 변환을 트리거 한다.
 -외부이벤트 핀은 I/O 로 프로그래밍 되어진것.
*8가지 하드웨어 이벤트로 변환을 트리거한다.


12비트의 ADC모듈의 두 개의 인스턴스는 16개의 아날로그 입력 채널을 공유한다.
ADC1은 32개의 채널이 있다.
ADC2는 25개의 채널이 있고, 그중 16개의 채널을 ADC1과 공유한다.
공유채널에서 ADC1과 ADC2를 모두 사용할때는 샘플윈도우는 서로 완전히 일치하거나,
겹치지 않도록 해야하며 하나의 샘플윈도우의 끝과 다른 ADC 샘플창 시작에서 최소 2ADC사이클 버퍼가 있어야하고,
2개의 ADC코어간에 동작전원및 접지는 공유된다.

22.1.1 소개

ADC 모듈 구성요소 그림이다.

22.1.1.1 입력 멀티플렉서

입력멀티플렉서(MUX)는 선택된 입력채널을 AIN입력에 연결한다. AIN은 ADC코어안에있음.
ADC1은 그림과 같이 최대 32개의 입력을 지원한다.
ADC2는 최대 25개의 입력을 지원한다.

시퀀서는 변환할 채널을 선택한다.
향상된 채널모드가 활성화 되면, 하나 또는 여러개의 아날로그 입력채널이 
외부 아날로그 스위치 또는 멀티플렉서의 출력에 연결할수있다.


22.1.1.2 자체 테스트및 교정 셀

ADC는 아날로그 입력에서 open/short를 감지하기 위해 소프트웨어 알고리즘이 짜여져있고,
이것은 특정 하드웨어 안에 포함되어있는 사항이다.


22.1.1.3 Analog-to-Digital Converter Core  변환 코어

ADC코어는 전압 스케일링(크기조정하는것)으로 조합되어있고,
아날로그 디지털 변환기안에 있는  SAR(Successive Approximation Register)로 전하를 재분배 한다.
이 코어는 10비트 또는 12비트로 구성되어질수 있다.
이것은 시퀀서로직에 의해 제어가 된다.
이 선택은 ADC모듈에 의해 수행되는 모든 변환에 적용된다.
일부 채널은 12비트와 10비트로 변환할수 없다.

아날로그 입력에서 디지털 변환 결과에서 단일 변환은 2개의 별개의 기간에 발생한다.

*샘플링 기간:
 -시퀀서는 샘플링의 시작을 알리기위해 ADC코어에 START 신호를 생성한다.
 -아날로그 입력신호는 이 기간동안, 직접적으로 커패시터 어레이를 스위치하고, 
고유의 샘플및 홀드기능을 제공한다.
 -샘플링 기간은 START신호의 하강 끝이 떨어진 이후에 ADCLK중 한개가 전체가 꺼짐.
 -시퀀서는 변환 그룹의  샘플시간 제어 레지스터를 구성하여 샘플링 기간을 제어 할수 있다.
 이 레지스터는 START신호가 하이로 유지되는 시간을 제어한다.

*전환 기간:

-변환 주기는 START의 하강 끝 이후에, 전체 ADCLK를 시작한다.
-변환 결과중 하나의 비트는 변환 주기의 ADCLK의 각 상승 에지에서 출력되며, 최상위비트부터 시작한다.
-변환주기가 12비트 ADC의 경우는 12ADCLK 사이클이며, 10비트 ADC의 경우 10ADCLK 사이클이다.
-ADC코어는 변환기간이 끝날때 시퀀서에 EOC신호를 생성한다.
12비트또는 10비트의 변환결과를 사용한다.
-시퀀서는 EOC가 하이로 구동되는 즉시 ADC코어의 변환 결과 출력을 캡쳐한다.

아날로그 변환 범위는 AD REFHI 및 AD REFLO의 기준전압에의해 결정된다.
 AD REFHI는 최고 기준전압이며 변환 할 수있는 최대 아날로그 전압이다.
AD REFHI와 동일한 아날로그 입력 전압은 10 비트 분해능의 경우 0x3FF,
12 비트 분해능의 경우 0xFFF의 출력 코드를 생성한다.
AD REFLO는 하단 전압이며, 변환 할수 있는 최소 아날로그 전압이다.
AD REFLO와 동일한 입력을 적용하면 출력코드는 0x000이 된다.
AD REFLO와 AD REFLO 모두 아날로그 전원 공급장치를 초과하지 않도로고 선택해야 한다.
AD REFLO와 AD REFLO 사이의 입력전압은 10비트경우(Equation 29)로, 12비트의 경우 (Equation 30)
에 의해 주어진 변환 결과를 생성한다.

22.1.1.4 시퀀서

입력멀티플렉서, ADC코어및 결과 메모리를 포함하여 ADC의 동작을 조정한다.
시퀀서의 상태 레지스터 플래그 로직은 변환이 진행중이거나 중지되거나 끝날때의 상태를 설정한다.
시퀀서의 모든 기능은 이 문서의 다음 섹션에서 자세히 설명한다.

22.1.1.5 전환 그룹들

여러 application에서는 예를 들어 단일 트리거 소스를 사용하여 채널그룹을 변환 해야한다.
수집 시간의 특정 인수 설정이 필요한 채널 그룹이 구별될수 있다.
ADC모듈은 그룹1,그룹2,이벤트그룹의 세가지 변환 그룹을 지원한다.
사용가능한 아날로그 입력채널을 변환 그룹에 할당을 한다.
또한 특정 채널을 여러 그룹으로 선택해서 반복적으로 샘플링할수있다.
한번에 여러개의 전환 그룹이 실행되면 우선순위 체계가 사용된다.
이벤트 그룹은 우선순위가 가장 높고 그다음이 그룹1,그룹2 순이다.
이벤트 그룹은 항상 하드웨어 이벤트가 트리거 되어진다.
그룹1,그룹2는 default에 의해 소프트웨어 트리거가 되고, 하드웨어 로 구성 할수있다. ->? 직접해석해보세요
(3번째문단 입니다.)
각 그룹의 전환 유발 방법은 22.2.1.6절에 나와있다.


22.2 기본 운영방법

22.2.1 ADC의 기본 기능 및 사용법

22.2.1.1  12비트&10비트 해상도 선택 방법

ADC 동작 모드 제어 레지스터 (ADOPMODECR)의 10_12_BIT 필드는
ADC를 10 비트 또는 12 비트 분해능 모드로 구성한다.

*10_12_BIT = 0이면 모듈은 10 비트 해상도 모드이다.
  이것은 기본 작동 모드이다.
* 10_12_BIT = 1이면 모듈이 12 비트 해상도 모드이다.


22.2.1.2 ADCLK 속도 설정 방법

ADC시퀀서는 ADC코어에 대한 클럭인 ADC클럭을 생성한다.
ADC코어는 타이밍을 위해 ADCLK 신호를 사용한다.
ADCLK는 입력 클럭을 ADC모듈을 분할하여 생성한다.(VBUSP인터페이스 클럭,VCLK)
ADC클럭 제어 레지스터중 5비트 필드(PS)는 VCLK를 1에서 32로 나누기 위해 사용된다.
ADCLK 유효주파수 범위는 장치 데이터시트에 지정되어있다.
최대 주파수도 장치 데이터시트에 지정되어있다.

22.2.1.3 입력 채널 획득 시간 설정 방법

각 그룹의 신호 획득 시간은 ADG1SAMP [11 : 0], ADG2SAMP [11 : 0] 및
ADEVSAMP [11 : 0] 레지스터에 저장된다.
획득 시간은 ADCLK 사이클을 기준으로 지정되며 최소 2ADCLK 사이클에서 최대 4098ADCLK사이클까지의 범위가있다.
예를 들어 그룹1획득시간은 t ACQG1 = G1SAMP [11 : 0] + 2, ADCLK 사이클.
최소획득 시간은 변환되는 아날로그 입력채널에 연결된 회로의 임피던스에 따라 달라진다.
(임피던스는 교류의 저항을 말함)

22.2.1.4 변환을 위한 입력채널 선택방법

변환을 위한 입력채널을 선택하기전에 먼저 ADC모듈을 활성화 해야한다.
ADC모듈은 ADC동작 모드 제어 레지스터에서 ADC_EN비트를 설정함으로써 활성화 될수있다.
각 그룹의 변환을 위해 여러입력채널을 선택할수있다.
한번에 하나의 입력채널만 변환된다.
변환될 채널은 3개의 변화 그룹의 채널 선택 레지스터에 구성되어있다.
그룹에서 변환될 채널은 그룹1 채널 선택 1레지스터에서
 변환될 그룹2는 그룹2 채널 선택 레지스터에서 구성되고,
이벤트 그룹에서 변환 될것은 이벤트 그룹 채널 선택 레지스터에서 구성된다.
22.2.2는 향상된 채널 선택 모드의 입력 채널 선택이 정의 되어있다.

22.2.1.5 단일변환 또는 연속변환 중에서 선택하는 방법

각 그룹에는 자체 모드 레지스터가 있다.
이 제어 레지스터 모드 필드는 단일변환 또는 연속변환 모드 중에서 선택하는 application이다.

NOTE: 세개의 그룹을 모두 연속 변혼 모드로 구성 할수 없다.
application이 그룹 모드제어 레지스터를 구성하여 세그룹 모두에 대해 연속변환 모드를 활성화하면
그룹2는 자동으로 단일변환 시퀀스 모드로 구성된다.

연속변환 모드에서 변환이 진행중일때 그룹의 모드 필드가 지워지면 해당 그룹은 단일 변환 순서모드로 전환된다.
해당 그룹에 대해 선택된 모든 채널이 변환이 되면 그룹에 대한 전환이 중단된다.

22.2.1.6 변환 시작 방법

변환그룹 그룹1과 그룹2는 기본적으로 소프트웨어 트리거된다.
이 그룹의 변환은 각 채널 선택 레지스터에 원하는 채널을 쓰는 것만으로 시작할수있다.
예를 들어 그룹1의 채널에 0,1,2와3 채널8,9,10과 11을 변환하려면 application이
ADG1SEL에0x0000000F를,  ADG2SEL에 0x00000F00 를 쓴다.
ADC 모듈은 먼저 트리거 된 그룹인 그룹1에 서비스를 제공하면서 시작된다.
모든 그룹의 전환은 채널 번호가 오름차순으로 수행된다.
그룹1의 경우 전환은 채널0, 채널1, 채널2순으로 순서대로 수행된다.
그룹2의 전환은 채널 8,9,10및 11순으로 수행된다.
이벤트 그룹은 하드웨어로 트리거 된다.
ADC 모듈에 대해 정의된 최대 8개의 하드웨어 이벤트 트리거소스가 있다.
이 트리거 소스는 ADEVSRC 레지스터에 구성되어있다.
그룹1과 그룹2에 대해 유사한 레지스터가 존재하므로 이벤트 트리거 되도록 구성할수도있다? ->직접 해석해보세요
(830쪽 제일 마지막 문단입니다!!)
이벤트 트리거는 양극성으로 구성 가능하고, 하강 엣지가 기본값을 가진다.
이벤트 그룹에서 변환을 위해 하나 이상의 채널이 선택되고 정의된 이벤트 트리거가 발생할때,
이벤트 그룹 변환이 시작된다.
변환 그룹이 연속 변환 모드로 구성된 경우에는 한번만 트리거 해야한다.
해당 그룹에서 변환을위해 선택된 모든 채널이 반복적으로 변환된다.


22.2.1.7 그룹변환이 완료되면 알수있는 방법

각 전환 그룹에는 전환이 종료된 시점을 나타내는 상태 플래그가 있다.
ADEVSR, ADG1SR 및 ADG2SR를 보면된다.
이 비트는 그룹에 대한 변환 순서가 끝나면 설정이된다.
그룹이 연속변환으로 구성된 경우 이 비트는 항상 설정된다.

22.2.1.8 결과가 결과메모리에 저장되는 방법

ADC는 각그룹에 대해 ADC결과의 RAM에 3개의 개별 메모리 영역에 변환 결과를 저장한다.
각 메모리영역은 하나의 변환 결과를 보유할수있는 버퍼의 스택이다.
각 그룹에 할당된 버퍼수는 ADC모듈 레지스터( ADBNDCR 및 ADBNDEND)를 구성하여 프로그래밍한다.
 ADBNDCR에는 두개의 9비트 포인터 BNDA와 BNDB가 있다.
그림 22-3을 보면 BNDA,BNDB와 BNDEND는 메모리를 세개의 메모리영역으로 분할하는데 사용된다.
BNDA,BNDB는 메모리 시작에 참조되는 포인터이다.
BNDA는 이벤트 그룹 변환 결과에 할당된 버퍼수를 두개의 버퍼단위로 지정한다.
BNDB는 이벤트 그룹에 할당된 버퍼수와 그룹1을 두개의 버퍼단위로 지정한다.
ADC결과의 메모리 구성에 대한 자세한 내용은 22.3.23절을 참조한다.
ADBNDEND에는 사용가능한 총 메모리를 구성하는 BNDEND라는 3비트의 필드가 들어있다.
ADC모듈은 최대 1024개의 버퍼를 지원할수있다.
이 소자는 두 ADC 모듈 모두를 위해 최대 64개의 버퍼를 지원한다.

22.2.1.9 결과메모리에서 결과를 읽는 방법

CPU는 두가지 방법중 하나로 변환결과를 읽을수있다.
1.변환결과메모리를 FIFO큐를 사용함으로써
2.변환결과메모리에 직접액세스하여

22.2.1.9.1 FIFO에서 변환결과 읽기

각 그룹의 변환결과는  ARM Cortex-R4 CPU의 LDM (Load-Multiple) 명령어 사용을
용이하게하기 위해 제공되는 주소 범위를 통해 액세스 할 수 있다.

LDR명령을 사용하여 수행된 단일 read는 단일변환결과를 읽는데 사용되어진다.
결과는 주소범위내의 모든 위치에서 읽음으로서 그룹의 메모리 영역에서 FIFO대기열로 읽혀진다.
먼저 저장된 결과가 먼저 읽혀진다.
메모리에서 읽은 결과는 메모리에서 제거가 된다.
예를 들어서 예를 들어, ADEVBUFFER (오프셋 90h ~ AFh) 범위의 모든 주소에서 읽으면
이벤트 그룹 메모리에서 하나의 변환 결과가 추출된다.


변환결과와 함께 채널ID를 읽을 수있는 옵션:

application에는 변환결과와 함께 채널ID를 읽을 수 있는 옵션이 있다.
이것은 그룹의 모드 제어 레지스터의 CHID필드에 의해 제어된다.
채널 ID를 읽는 옵션이 선택되지 않는 경우 변환 결과의 채널 ID필드는 0으로 읽는다.

비어있는 FIFO 읽기 방지:
application이 새로운 수를 지나서 읽지 않도록 보호하는 하드웨어 메커니즘이 있다.
변환 결과는 FIFO에 보관된다.
사용가능한 모든 변환 결과가 application에 의해 FIFO에서 읽혀지면 FIFO에서 후속 읽기는
메커니즘이 EMPTY필드를 설정하여 FIFO가 있음을 나타낸다.

디버그/에뮬레이션(경쟁) 지원:

디버그 목적으로 각 변환 그룹은 그룹의 변환 결과 추출을 위해 application이 읽을수 있는 주소도 제공한다.
그러나 변환 그룹에 대한 상태플래그는 이 에뮬레이션 버퍼 주소에서 읽음으로써 영향을 받지 않는다.
예를 들어 ADEVEMUBUFFER (offset F0h)는 이벤트 그룹 버퍼의 다음결과를 반환하지만
실제로 결과 그룹에서 해당결과를 제거하더나 버퍼에 보유된 데이터의 양을 변경하지 않는다.

22.2.1.9.2 변환결과의 메모리에서 직접 변환 결과 읽기

변환 결과 메모리는 장치의 메모리맵의 일부이다.
ADC1 결과 메모리의 기본 주소는 FF3E 0000h이고 ADC2 결과 메모리는 FF3A 0000h이다.

application은 22.2.1.8절에서 설명한대로 세분화를 수행한 후
3개의 변환 그룹에 대한 3개의 메모리 영역 각각에 대한 주소 범위를 식별할수있다.
세개의 변환 그룹에서 원하는 결과를 읽는 것은 application에 달려있다.
RAM에서 직접 읽을때의 변화 결과 형식은 22-7과 22-8그림에 나와있다.

그림에서
이전에 읽은 데이터를 응용프로그램이 읽지 못하도록 EMPTY필드가 없음을 유의해야한다.
각 그룹에는 ADC가 다음 변환결과를 기록할 그룹결과메모리의 주소를 보유하는 별도의 레지스터가 있다.
이들은 ADEVRAMWRADDR, ADG1RAMWRADDR W ADG2RAMWRADDR 레지스터이다.
응용프로그램이 정보를 사용하여 읽을수있는 유효한 변환 결과수를 계산할수있다.

ADC RAM에서 변환결과를 직접읽어서 좋은점:
응용 프로그램이 변환결과를 FIFO에서 읽는거처럼 순차적으로 읽을 필요가 없다.
결과적으로 응용프로그램은 다른 채널의 변환결과를 읽지 않고도 특정 입력채널에 대한
변환결과를 선택적으로 읽을 수 있다.

22.2.1.9.3 예제

이벤트 그룹에서 채널 4,7,8에서 변환을 위해 채널 0,1,2가 선택되어진다고 가정을 해보자.
그룹1에서 변환을 위해 선택되고 채널 3,5,6이 그룹2에서 변환을위해 선택되어진다.
변환 결과는 그림 22-9와 같이 세개의 메모리 영역에 저장된다.

CPU가 FIFO큐에서 이벤트그룹에 대한 결과를 읽으려고한다고 가정하자.
CPU는 ADEVBUFFER (오프셋 90h에서 AFh까지) 범위의 모든 주소에서 여러 번 읽어야한다.
이 주소 범위에서 "다중로드"해라.
이것은 ADC가 채널0에 대한 결과를 반환하게 하고, 그런 다음 주소범위에 대한 각 읽기 액세스에 대한
채널1,2,0 등을 수행한다.

이제 응용 프로그램이 그룹1의 결과를 RAM에 직접 읽으려고 한다고 가정하다.
그룹1의 변환 결과는 주소 ADC RAM Base Address + BNDA에서부터 액세스 할 수 있다.
이 주소에서의 첫번째 결과는 입력채널4에 대한 것이고,다음 주소는 입력채널7에 대한것이다.
따라서 원하는 경우 응용프로그램에서 단 하나의 채널에 대한 변환 결과를 선택적으로 읽을 수 있다.

22.2.1.10 변환 중지 방법

그룹의 채널 선택 레지스터를 지우면 그룹의 변환을 중지할수있다.

22.2.1.11 ADC 모듈의 기본구성을 위한 예제 시퀀스

그룹1을 사용하여 단일 채널ADC에서 채널 0,2,4,8을 변환하도록 ADC를 구성하려면 다음순서가 필요하다

1. 재설정 제어 레지스터에 0을 쓰면 모듈이 재설정상태에서 해제된다.
2. ADC 상태머신을 활성화하기 위해 동작 모드 제어 레지스터의 ADC_EN비트에 1을 쓴다.
3. 클럭 제어 레지스터에 원하는 디바이저를 프로그래밍하여 ADCLK주파수를 구성한다.
4. 사용할 그룹의 획득시간을 구성한다. 예를 들어 그룹1 샘플링 시간제어 레지스터를 사용하여
그룹1의 수집시간을 설정한다.
5.그룹1 채널 선택레지스터에 기록하여 그룹1에서 변환해야 하는 채널을 선택한다.
예시로 그룹1에서 변환을 위해 채널0,2,4,8을 선택하기 위해 0x115 값을 ADG1SEL에 쓸 필요가 있다.

*ADC시퀀서는 채널선택레지스터(ADG1SEL)에 대한 쓰기가 완료되자마자 그룹1변환을 시작한다.
6.그룹1 변환 상태 레지스터(ADG1SR)에 GP1_END 비트가 설정될때까지 기다린다.
이 비트는 그룹1에서 변환을 위해 선택된 모든 채널이 변환되고 결과가 그룹1메모리에 저장될때 설정된다.
7. 그룹1 FIFO접근 위치에서 읽음으로써 변환결과를 읽거나 그룹1을 직접 읽는다.


22.2.2 고급변환 그룹 구성 옵션

그림 22-10은 동작모드 제어 레지스터와 3개의 변환 그룹 각각에 상태레지스터를 보여준다.
표시된 레지스터 주소는 기본 주소의 오프셋이다.

22.2.2.1 그룹 트리거 옵션

그룹1,2 작동모드 제어 레지스터에는 추가 제어비트인 HW_TRIG가 있다.
이 비트는 그룹이 하드웨어 이벤트 트리거가 되도록 구성한다(기본값으로)
그룹이 이벤트 트리거 되도록 구성이 되면, 그룹에서 변환을 위해 하나이상의 채널이 선택되고
정의된 이벤트 트리거가 발생할때 그룹변환이 시작된다.
이벤트 트리거 소스는 ADEVSRC, ADG1SRC 및 ADG2SRC 레지스터의 각 그룹에 대해 정의된다.
이벤트 트리거 소스로 사용되는 실제 연결은 두 ADC모듈의 장치 데이터 시트에 정의되어있다.

22.2.2.2 아날로그 입력채널 선택모드 옵션

이 장치의 ADC1 모듈은 변환할 아날로그 입력 채널을 선택하는 두가지 모드를 지원한다.
*순차 채널 선택 모드(기본값)
*향상된 채널 선택 모드

NOTE: ADC2 모듈은 순차 채널선택모드만 지원한다.

22.2.2.2.1 순차 채널 선택모드

이것은 기본모드이며, TI의 다른 HerculesTM ARM® Safety MCU의 ADC 모듈과
역 호환 모드로 ADC 모듈을 사용할 수 있다.
섹션 22.2.1.4에 설명된 바와 같이 아날로그 입력 채널 그룹의 채널 선택 레지스터의 채널번호에
대응하는 비트를 설정하여 한개 이상의 변환 그룹으로 전환 선택 할수 있다.


22.2.2.2.2 향상된 채널 선택 모드

몇가지 중요한 개념이 있다.

*룩업 테이블(LUT)
변환 할 아날로그 입력 채널 번호를 정의하는 데 사용되는 32단어 딥 메모리 매핑영역이다.
세 그룹에 대한 LUT는 함께 스택되어 전체 LUT가 96단어를 차지한다.
각 단어는 32비트로 정렬이 된다.

*전환 그룹 하위시퀀스
그룹 하위 시퀀스는 각 변환 트리거에서 변환되는 채널 집합에 대한 변환으로 정의된다.
그룹 하위 시퀀스에서 변환을 위해 선택된 패널수는 그룹의 채널선택 레지스터에 설정된
비트수에 의해 정의된다.


*LUT 인덱스
각 그룹에 대한"CURRENT_COUNT"레지스터는 해당 그룹의 LUT에 대한 인덱스로 유지된다.
이 레지스터는 채널변환이 완료될때마다 증가한다.
따라서 이름에서 알수있듯이 레지스터르 읽으면 그룹의 채널선택레지스터에 마지막으로 쓰여진
이후에 완료된 변환수가 반환된다.
"CURRENT_COUNT"레지스터는 다음 조건중 하나라도 충족되면 모두0으로 재설정된다.
1.ADC주변장치는 글로벌 주변장치 리셋을 통해 리셋된다
2.ADC주변장치는 ADC리셋 제어 레지스터를 통해 리셋된다.
3."CURRENT_COUNT"는 해당 전환 그룹에 대해 정의된 MAX_COUNT와 같다.
4.응용프로그램이 CURRENT_COUNT 레지스터에 0을 쓴다.
5.변환그룹 결과 RAM이 재설정된다.


*최대 변환수
각 전환 그룹에 대한 MAX_COUNT개의 레지스터는 그룹의 LUT에 대한 색인이 0으로 재설정되기 전에 수행할
최대전환수를 저장합니다.
이 레지스터는 0과31사이의 값으로 프로그래밍 될 수있다.
해당 그룹의 변환 하위 시퀀스에 있는 채널수의 배수보다 작은 값으로 max_count 레지스터를 프로그래밍하는것이
좋다.


22.2.2.2.2.1 룩업테이블 세부 사항

이전에 말했듯이, 각 변환 그룹은 강화된 채널 선택모드에 인에이블 될때 사용되는 룩업테이블을 갖는다.
이 룩업테이블은 ADC결과 RAM의 베이스로 부터 8kb 오프셋에서 시작한다.
LUT는 3개의 변환 그룹 각각에 대해 32개의 항목을 보유한다.
처음 32개의 항목은 이벤트 그룹용이고, 다음 32개의 항목은 그룹1용이며 마지막은 그룹2용이다.
그림22-11은 이벤트 그룹에 대한 예제 LUT항목이다.


22-1 ADC 룩업테이블의 자세한 사항

31-13	: 리턴0을 읽고, 쓰기는 가질수없다.
12-8	: 이 필드는 이벤트 그룹 CURRENT_COUNT 레지스터가 LUT엔트리를 가리키고,
	 향상된 채널 선택 모드가 활성화 된 상태로 이벤트 그룹 변환이 트리거될때
	 ADC 모듈에서 출력되는 외부 아날로그 멀티플렉서 선택을 정의한다.
7-5	:  리턴0을 읽고, 쓰기는 가질수없다.
4-0	: 이 필드는 이벤트 그룹 CURRENT_COUNT 레지스터가 LUT엔트리를 가리키고,
	 향상된 채널 선택모드가 활성화 된 상태로 이벤트 그룹 변환이 트리거 될때
	 ADC모듈에서 출력되는 내부 아날로그 멀리플렉서 선택을 정의한다.

이 장치는 24개의 입력채널만 지원한다. ADC1은 16 입력 채널, ADC2는 16입력채널
응용프로그램이  EV_INT_CHN_MUX_SEL 필드에 사용할 수없는 채널 번호를 구성하면
 ADC는 계속 변환을 수행하므로 결과가 불확실하다.

22.2.2.2.2 향상된 채널 선택 모드를 사용하는 ADC변환 시퀀스의 예

그림22-12에 표시된 예제 변환은 그룹1구성을 보여준다.
ADG1SEL의 비트 0과 31 만 설정된다. 이 레지스터의 다른 모든 비트는 0이라고 가정하자.
기본 순차 채널 선택 모드의 경우 ADG1SEL 레지스터에 쓰면 그룹1변환이 채널0부터 채널31로 시작된다.
변환은 그룹1이 단일 또는 연속적인지 여부에 따라 이 순서로 중지되거나 반복된다.
이제 응용프로그램이 G1_MAX_COUNT 레지스터가 3으로
구성된 Group1의 향상된 채널 선택 모드를 활성화했다고 가정하자.
이제 응용 프로그램이 ADG1SEL에 0x80000001을 써서 Group1 변환을 트리거한다고 가정해보자.
즉, 비트 0과 31이 설정되고 나머지는 모두 0이다. ADC 변환은 다음 순서로 진행된다.


*입력채널 선택

G1_CURRENT_COUNT의 초기 값은 0이며 Group1 LUT에 대한 인덱스로 사용된다.
그룹 1의 LUT행은 0  G1_EXT_CHN_MUX_SEL에 대해 1의 값을 가지고,
G1_INT_CHN_MUX_SEL에 대해 1의 값을 가진다.

AWM_EXT_SEL 터미널에서 0b00001의 5 비트 외부 채널 id가 드라이브되어 나간다.
그림22-12와 같이 연결된 외부 아날로그 멀티플렉서에 대한 채널1이 선택된다.
또한 ADC모듈은 AWM_EXT_SEL단자를 통해 외부 아날로그 멀티플렉서에 인에이블 신호를 출력한다.
내부채널 id가 그룹1 LUT의 행 0에서 1로 구성되어진다.
이로 인해 ADC의 내부 채널1(ADIN1)에 대한 스위치가 닫힌다.
다른 모든 내부 ADC 입력 스위치들은 오픈된다.
ADIN1입력 채널은 실제 8:1아날로그 멀티플렉서의 출력에 연결된다.
결과적으로 ADC는 마이크로 컨트롤러의 ADIN1단자에 연결된 8:1 아날로그 멀티플렉서의
채널1을 변환한다.

*전환 완료후

첫 번째 변환이 완료되면 CURRENT_COUNT 값 0이 "채널 ID"에 저장된다.
필드를 ADC 코어의 실제 변환 결과와 함께 Group1의 변환 결과 RAM에 저장한다.
그런 다음 G1_CURRENT_COUNT 값 0은 G1_MAX_COUNT 값 3과 비교된다.
값이 일치하지 않으므로 G1_CURRENT_COUNT가 0에서 1로 증가한다.

*다음채널 선택

ADG1SEL 레지스터에는 2 비트가 설정되어 있기 때문에
ADC 모듈은 G1_CURRENT_COUNT 값을 1로 사용하여 Group1 LUT를 인덱싱한다..

그림 22-12에서 볼 수 있듯이 Group1 LUT의 
2번째행에는 G1_EXT_CHN_MUX_SEL이 4, G1_INT_CHN_MUX_SEL이 2가 있다.
ADC 입력 채널 ADIN2는 외부 아날로그 멀티플렉서에 연결되지 않고
변환 할 아날로그 신호에 직접 연결된다.
ADC 모듈은 여전히 마이크로 컨트롤러에 연결된 
모든 외부 아날로그 멀티플렉서에 대해 AWM_EXT_ENA 및 AWM_EXT_SEL (4의 값, 즉 0b00100)을 구동한다.

*변환 종료 시퀀스
일단 내부 채널 ADIN2의 변환이 완료되면 G1_CURRENT_COUNT의 1이 실제 변환 결과와 함께
Group1 결과 RAM의 "채널 ID"필드에 저장된다.
이 값 1은 G1_MAX_COUNT 값 3과 비교된다.
값이 일치하지 않으므로 G1_CURRENT_COUNT가 1에서 2로 증가한다.
ADG1SEL에는 2 비트 만 설정되므로
하위 시퀀스에는 더 이상의 변환이 필요하지 않다.

*그룹1 의 계속적인 트리거
ADC Group1이 다시 트리거되거나 Group1이 연속 변환 모드이면
Group1 LUT의 인덱스를 위해 2의 G1_CURRENT_COUNT가 다시 사용된다.
이전과 같은 추론에 따라 ADIN1에 연결된 8 : 1 아날로그 멀티플렉서의 채널 1이 변환된다.
이 변환이 완료되면 G1_CURRENT_COUNT 값 2가 변환 결과와 함께 결과 RAM의 "채널 ID"필드에 저장된다.
이것은 여전히 G1_MAX_COUNT가 3과 일치하지 않으므로 G1_CURRENT_COUNT가 2에서 3으로 증가한다.
이 색인 값 3은 이전과 같은 추론에 따라 ADIN2 채널을 다시 변환하는 데 사용된다.
이 변환이 완료되면 변환 결과와 함께 결과 RAM의
"채널 ID"필드에 3의 G1_CURRENT_COUNT가 저장된다.
또한이 G1_CURRENT_COUNT 값 3은 G1_MAX_COUNT와 일치한다.
G1_CURRENT_COUNT가 0으로 재설정된다.

그룹1이 다음에 트리거될때마다 또는 그룹1이 연속변환 모드로 구성되는 경우
위의 설명되로 시퀀스가 진행된다.

22.2.2.3 단일 또는 연속 변환 모드

각 그룹에 대한 변환모드를 위해 EV_MODE, G1_MODE 및 G2_MODE 비트는
단일 또는 연속 중 하나를 선택하는 데 사용된다.

22.2.2.3.1 단일 변환 모드

단일 변환 모드로 구성된 변환 그룹은 각 그룹 트리거에 대해 ADC에 의해 한 번만 처리된다.
트리거는 기본적으로 Group1 및 Group2의 경우와 같이 소프트웨어 트리거 일 수 있으며
이벤트 그룹 또는 Group1 또는 Group2의 경우처럼 하드웨어 이벤트 트리거 일 수 있다.
그룹 변환 요청의 수락에서 마지막 채널의 변환 끝까지의 전체 변환 순서는
해당 그룹의 상태 레지스터에있는 해당 BUSY 비트에 의해 각 그룹에 대해 플래그가 지정된다.
단일 변환 모드가 시작된 후 마지막 채널의 변환이 완료 될 때까지 BUSY 비트가 1로 읽힌다.
해당 그룹의 모든 채널이 변환되면 그룹의 END 비트가 설정된다.

예를 들어, 단일 변환 모드에서 Group1의 변환을 위해
채널 0, 2, 4 및 6이 선택되었다고 가정하자.
Group1이 서비스되면 ADC는 채널 0, 채널 2, 채널 4, 채널 6의 변환을 시작한다.
그런 다음 Group1 서비스를 중지하고
GP1_END 상태 비트를 설정 한 다음 필요에 따라 Event Group 또는 Group2에 서비스를 제공한다


22.2.2.3.2 연속 변환 모드

연속 변환 모드로 구성된 변환 그룹은 ADC에 의해 지속적으로 처리된다.
첫 번째 전환을 시작하기 위해 그룹을 계속 트리거해야한다.
전환은 이후에도 계속 수행된다.
그룹 변환 요청의 수락에서 마지막 채널의 변환 끝까지의 전체 변환 순서는
해당 그룹의 상태 레지스터에있는 해당 BUSY 비트에 의해 각 그룹에 대해 플래그가 지정된다.
연속 변환 모드가 시작된 후  그룹에 대한 연속 변환 모드가 선택되어있는 한 BUSY 비트는 1로 읽는다.

예를 들어 Group1에서 변환을 위해 채널 0, 2, 4 및 6이 변환을 위해
선택 되었으면 연속변환모드로 전환된다고하자.
Group1이 서비스되면 ADC는 채널 0, 2, 4 및 6에 대한 변환을 완료 한 다음
이벤트 그룹 또는 Group2에 서비스를 제공한다.
이벤트 그룹 또는 Group2에 대한 서비스가 완료되면 서비스로 돌아간다.

NOTE: 모든그룹이 연속변환모드로 될때 구성

모든 그룹이 동시에 연속변환모드로 작동할수는 없다
동시에 연속변환 모르도 하게 되면 그룹2가 자동으로 단일변환 모드로 재설정이 되고,
그룹2의 ADG2MODECR 레지스터 안의 비트를 단일로 반영해서 삭제하게 된다.

22.2.2.4 전환 그룹 고정 기능

세개의 그룹사이 에는 고유한 우선순위가 존재한다.
우선순위는 여러그룹이 트리거될때 변환순서를 결정한다.

세 그룹간의 내림차순 우선순위는 다음과 같다.
1. 이벤트그룹
2. 그룹1
3. 그룹2

전환 그룹 우선 순위의 예 :

*단일 변환 순서 모드 및 Group2 및 Group1에서 이벤트 그룹 변환이 진행중인 경우
전환이 요청되면, ADC는 Event Group에서 선택된 채널의 변환을 끝내고
Group1에서 선택한 채널을 변환 한 다음 Group2에서 선택한 채널을 변환한다.

*Group1 변환이 연속 변환 모드에서 진행 중이고 
Group2 변환이 요청되면 ADC는 Group1의 현재 채널 변환을 완료하고
Group2에서 선택된 변환 채널로 전환한다.
Group1에 대한 보류중인 연속 변환 요청보다 
Group2에 대한 새 변환 요청의 우선 순위가 더 높음.

전환그룹고정기능을 사용하면 변환 그룹간에 기본우선순위를 재정의하는 것을 따른다.
고정 기능을 사용하면 다른 (우선 순위가 낮은) 그룹에서 변환 요청이있을 때마다
ADC가 우선 순위가 높은 변환 그룹의 변환을 고정 할 수 있다.

예를 들어, ADEVMODECR 레지스터의 FRZ_EV 비트를 설정하면
보류중인 요청이 있거나 그룹 1 또는 그룹 2 변환에 대한 새 요청이있을 때마다
ADC가 진행중인 이벤트 그룹 변환을 고정 할 수 있습니다.
Group1 또는 Group2 전환이 활성화되어있는 한 이벤트 그룹의 전환은 고정됩니다.
Group1 또는 Group2 변환이 완료되면 이벤트 그룹 변환은 고정 된 위치에서부터 시작됩니다

그룹 변환이 고정되는 동안 그룹의 stop상태의 비트가 활성화 된다.

22.2.2.5 변환 그룹 메모리 오버런 옵션

오버런 상태는 ADC 모듈이 이미 가득 찬 그룹의 결과 메모리에
더 많은 변환 결과를 저장하려고 할 때 발생합니다.
이 경우 ADC는 두 가지 옵션을 허용합니다.
그룹의 작동 모드 제어 레지스터 (ADEVMODECR, ADG1MODECR, ADG2MODECR)의 OVR_RAM_IGN 비트가 설정된 경우
ADC 모듈은 그룹 결과의 메모리 내용을 무시하고 새 변환 결과로 메모리를 덮어 씁니다.
OVR_RAM_IGN 비트가 설정되어 있지 않으면
응용 프로그램은 오버런 (overrun) 조건에서 그룹 결과의 메모리를 읽어야합니다.
그런 다음에도 ADC는 새로운 결과를 메모리에 계속 쓸 수 있습니다.


22.2.2.6 변환그룹의 채널 선택 레지스터에 0이 아닌값을 쓰는 것에 대한 응답.

해당 그룹의 변환이 이미 서비스되는 동안
응용 프로그램이 그룹의 채널 선택 레지스터에 0이 아닌 값을 쓰는 경우
해당 그룹의 변환은 채널 선택 레지스터에 프로그래밍 된 새 구성으로 다시 시작됩니다.


다음 규칙이 ADC 변환 순서에 미치는 영향에 적용됩니다.

*새 전환 요청이 진행중인 전환과 동일한 그룹에서 발생한 경우
 현재 진행중인 전환이 중단되는 단계에서 진행중인 전환이 중지되고 새로운 전환 순서가 시작됩니다.

* 새 전환 요청이 별도 그룹에서 오는 경우 진행중인 채널의 전환이 완료되어 새 전환 순서가 시작됩니다.

그룹의 결과 메모리에 미치는 영향에 대해 다음 규칙이 적용됩니다.

* 그룹 변환이 진행 중이거나 정지 된 경우 
그룹의 채널 선택 레지스터에 0이 아닌 값을 쓰면 결과가 FIFO로 재설정됩니다.
이것은 결과 FIFO의 내용을 지우지 않습니다.
ADC 모듈 만 FIFO의 내용을 첫 번째 위치에서 시작하는 새로운 변환 결과로 덮어 쓸 수 있습니다.


22.2.2.7 읽기 결과의 변환 결과 크기 : 8 비트, 10 비트 또는 12 비트

일부 응용 프로그램은 장치에서 ADC 모듈의 전체 12 비트 해상도가 필요하지 않으며
8 비트 또는 10 비트 변환 결과로 작동 할 수 있습니다.

12.2.2.7.1  12 비트 해상도로 구성된 ADC

각 변환 그룹의 모드 제어 레지스터에는 DATA_FMT라는 필드가 있으며,
이는 FIFO로 액세스 할 때 결과 RAM에서 읽은 변환 결과의 형식을 정의합니다.

DATA_FMT 필드는 다음과 같이 인코딩됩니다.

* DATA_FMT = 0이면 완전한 12 비트 변환 결과가 FIFO에서 읽혀집니다.
* DATA_FMT = 1h이면 12 비트 변환 결과가 2만큼 오른쪽으로 시프트되고 그 결과 10 비트 결과가 FIFO에서 읽혀집니다.
* DATA_FMT = 2h이면 12 비트 변환 결과가 4만큼 오른쪽으로 시프트되고 그 결과 8 비트 결과가 FIFO에서 읽혀집니다.

이 컨트롤 필드는 응용 프로그램이 변환 결과 메모리에 직접 액세스 할 때 효과적이지 않습니다.
이 경우 응용 프로그램은 필요에 따라 비트 수를 마스크하도록 선택할 수 있습니다


22.2.2.7.2 10 비트 분해능으로 구성된 ADC

DATA_FMT 필드는이 모드에서 유효하지 않으며
응용 프로그램에서 전체 10 비트 변환 결과 또는 8 비트 변환 결과를 읽을 수 있습니다.
이것은 그룹의 작동 모드 제어 레지스터의 8BIT 필드에 의해 제어됩니다

* 8BIT = 0이면 완전한 10 비트 변환 결과가 FIFO에서 읽혀진다.
* 8BIT = 1이면 10 비트 변환 결과가 2만큼 오른쪽으로 시프트되고 그 결과 8 비트 결과가 FIFO에서 읽혀집니다.


22.2.2.8 변환 결과와 함께 그룹 채널 ID를 읽을 수있는 옵션

ADC 모듈을 통해 응용 프로그램은 변환 결과와 함께 아날로그 입력 채널 번호도 읽을 수 있습니다.
이 기능은 그룹의 작동 모드 제어 레지스터에 CHID 비트를 설정하여 활성화됩니다.

* CHID = 0 인 경우 변환 결과를 그룹 결과의 FIFO에서 읽을 때 비트 [14-10]는 강제로 00000이됩니다.
* CHID = 1이면 그룹 결과 메모리의 비트 [14-10]에 변환 결과가 속한 입력 채널 번호가 포함됩니다.

참고 : 채널 ID의 실제 저장

CHID 비트가 설정되었는지 여부에 관계없이 
채널 번호는 항상 변환 결과와 함께 메모리에 저장됩니다.
CHID 비트는 그룹의 메모리를 읽을 때
채널 번호를 변환 결과와 함께 사용할 수 있는지 여부에만 영향을줍니다.
따라서 그룹의 CHID 비트는 해당 그룹의 진행중인 변환에 영향을 미치지 않고
동적으로 변경할 수 있습니다.

22.2.3 ADC 모듈 기본 인터럽트

이 절에서는 ADC 모듈에 의해 생성 된 기본 인터럽트에 대해 설명합니다.

22.2.3.1 그룹 변환 종료 인터럽트

ADC 모듈은 그룹의 변환 종료 플래그 (EV_END, G1_END 또는 G2_END)를 해당 그룹에 설정합니다
인터럽트 플래그 레지스터 (ADEVINTFLG, ADG1INTFLG, ADG2INTFLG)에 대해
해당 그룹의 전환이 변환됩니다.

이로 인해 그룹의 END_INT_EN 제어 비트 (EV_END_INT_EN, G1_END_INT_EN 또는 G2_END_INT_EN)를
설정하여 인터럽트를 활성화하면 그룹 변환 종료 인터럽트가 생성됩니다.
이 인터럽트는 단일 변환 모드로 구성된 변환 그룹에 쉽게 사용할 수 있습니다.
응용 프로그램은 필요한 경우 변환 결과를 읽고 
그룹 구성을 변경하고 인터럽트 서비스 루틴 내에서 그룹을 트리거하여
변환을 다시 시작할 수 있습니다.

연속 변환 모드로 구성된 그룹의 
경우 인터럽트 조건은 변환이 항상 진행 중이므로 실용적이지 않습니다.
이 경우 그룹 메모리 임계 값 인터럽트가 더 실용적입니다
응용 프로그램은 CPU를 인터럽트하기 전에
프로그래밍 가능한 개수의 변환 결과를 누적 할 수 있습니다







22.2.3.2 그룹 메모리 임계 값 인터럽트

ADC 모듈은 각 그룹에 대해 고정 된 수의 변환을 위해
인터럽트를 생성 할 수 있습니다.

그룹 메모리 임계 값 레지스터는 CPU가 인터럽트되기 전에
얼마나 많은 변환 결과가 그룹의 메모리 영역에 있어야 하는지를 결정합니다.

이 기능을 사용하면 인터럽트를 사용하여
변환 결과를 읽을 때 CPU로드를 크게 줄일 수 있습니다.
그룹 전환이 트리거되기 전에 그룹의 임계 값 레지스터를 구성해야합니다.
이 임계 값 레지스터 값은 ADC가 변환 결과를
이 그룹의 메모리에 쓸 때마다 감소하는 다운 카운터처럼 동작합니다.

이 카운터는 응용 프로그램이 FIFO 대기열에 액세스하여 결과의
메모리에서 변환 결과를 읽을 때마다 증가합니다.
그룹 결과의 메모리에서 (애플리케이션 프로그램에 의해
동시에 읽기(ADC 모듈에 의해) 연산을 수행하면 임계 값 카운터가 변경되지 않습니다.

임계 값 카운터는 과거 0을 감소시키고 음수가 될 수 있습니다.
메모리 영역을 비울 때 항상 원래 값으로 증가합니다.

 주어진 순간에 얼마나 많은 샘플이 메모리 영역에 있는지를
 결정하기 위해 임계 카운터는 원래 구성된 임계 값에서 뺄 수 있습니다.

임계 값 카운터가 +1에서 0으로 전환 할 때마다 
그룹의 임계 값 인터럽트 플래그를 설정하고 그룹의 임계 값 인터럽트가 활성화되면
 CPU가 인터럽트됩니다.
CPU는 변환 결과를 메모리에서 읽은 후 인터럽트 플래그를 지울 것으로 예상됩니다.
임계 값 카운터가 0 또는 -1에서 0으로 전환 될 때 인터럽트 플래그는 설정되지 않습니다.

22.2.3.3 그룹 메모리 오버런 인터럽트

해당 그룹에 대한 ADC 변환 수가 해당 변환 그룹에 할당 된 버퍼 수를 초과하면
각 그룹에 대해 인터럽트를 생성 할 수 있습니다.
응용 프로그램은 CPU 또는 DMA를 사용하여 모든 변환 결과를 읽을 수 있습니다.
또는 응용 프로그램이 그룹의 OVR_RAM_IGN 비트를 설정하고 
ADC 모듈이 그룹 결과의 메모리 내용을 새로운 변환 결과로 덮어 쓸 수있게합니다

22.2.4 ADC 모듈 DMA 요청

이 섹션에서는 플랫폼 DMA 컨트롤러 모듈을 활용하는
ADC 모듈의 기능에 대해 설명합니다.
ADC 모듈은 다음 두 조건에서 DMA 요청을 생성 할 수 있습니다.

22.2.4.1 결과의 메모리에 기록 된 각 변환 결과에 대한 DMA 요청

이 모드에서 ADC 모듈은 변환 결과가 그룹 결과의 메모리에 쓰여지자마자
첫 번째 DMA 요청을 생성합니다.
결과의 메모리에 대한 후속 쓰기는 DMA 요청을 생성합니다.
이 모드를 사용하면 애플리케이션에 
필요한 ADC 결과의 메모리 양을 줄일 수 있습니다.
이 DMA 요청 생성은 그룹의 DMA 제어 레지스터에
그룹의 DMA_EN 비트를 설정하여 활성화됩니다.
결과의 메모리에 새로운 결과가 기록되도록 DMA 요청을 생성하려면
이 레지스터의 BLK_XFER 비트를 지워야합니다 (기본 값)

22.2.4.2 고정 된 수의 변환 결과에 대한 DMA 요청

이 모드는 그룹의 DMA 제어 레지스터에서
그룹의 DMA_EN과 그룹의 BLK_XFER 비트를 모두 설정하여 활성화됩니다.
이 모드에서는 그룹 결과의 메모리에서 사용할 수있는 
지정된 수의 변환 결과에 대해 DMA 요청이 생성됩니다.
원하는 변환 결과 수는 제어 레지스터에서
그룹의 BLOCKS 필드를 사용하여 구성됩니다.

예를 들어 BLOCK 수를 10으로 구성하면 
ADC 모듈은 10 번째 변환이 끝날 때 DMA 요청을 생성합니다.
DMA 컨트롤러는 다음 10 개의 변환이 완료되기 전에 10 개의 데이터를 읽어야합니다.

NOTE : 임계 값 인터럽트가있는 블록 DMA 전송 사용

그룹 임계 값 인터럽트와 동시에 
그룹에 대한 블록 DMA 전송을 활성화하지 않는 것이 좋습니다.
그룹의 BLOCKS 필드는 섹션 22.2.3.2에서 설명 된 그룹의
 인터럽트 제어 레지스터에있는 그룹의 THRESHOLD 필드와 본질적으로 동일합니다.


22.2.5 ADC 크기 임계 값 인터럽트

ADC는 최대 3 개의 크기 임계 값 인터럽트를 발생시킬 수있다.
비교 매개 변수는 Magnitude Threshold Control Register (ADMAGINTxCR)를 통해 프로그래밍됩니다.

22.2.5.1 크기 임계 값 인터럽트 구성

다음 필드는 사용 가능한 3 가지 크기 임계 값 인터럽트 각각에 대해 구성 할 수 있습니다.

1. CHN_THR_COMP : 
두 채널의 변환 결과를 비교할지 또는 
채널의 변환 결과를 프로그램 가능한 임계 값과 비교 할지를 지정합니다.
값 0은 비교할 프로그램 가능한 임계 값을 선택하고 
값 1은 비교할 COMP_CHID 필드로 식별되는 채널의 변환 결과를 선택합니다.

2. MAG_CHID :
 변환 결과를 모니터해야하는 채널 번호를 0에서 31까지 지정합니다.

3. COMP_CHID : 
마지막 변환 결과가 모니터중인 채널의 변환 결과와의
비교에 사용되는 0에서 31까지의 채널 번호를 지정합니다

4. MAG_THRESHOLD :
MAG_CHID 필드에 의해 식별 된 채널의 변환 결과와 비교할 값을 지정한다.

5. CMP_GE_LT : 
MAG_CHID에 의해 식별 된 채널의 변환 결과가 "보다 크거나 같음"
또는 "미만"으로 참조되는 값을 비교하는지 여부를 지정합니다.

기준값은 COMP CHID 필드에 의해 식별 된 다른 채널의 변환 결과 일 수 있으며, 
또는 MAG_THRESHOLD 필드에 지정된 임계 값 일수 있다.
CMP_GE_LT 필드의 값 0은 "미만"비교를 나타내고
 값 1은 "크거나 같음"비교를 나타냅니다


22.2.5.2 크기 임계 값 인터럽트 비교 마스크 구성

세 개의 크기 임계 값 인터럽트 각각에 대해 
별도의 비교 마스크 레지스터 (ADMAGINTxMASK)가 있습니다.
이 레지스터는 비교를 위해 마스크가 해제 된 비트를 지정하는 데 사용됩니다.

예를 들어, 변환 결과의 하위 4 비트는 인터럽트 비교 마스크 레지스터에 0xf를 쓰면
마스크가되어 전체 비교를 할 수 있습니다.
기본적으로 전체 10/12 비트 변환 결과가 비교됩니다

22.2.5.3 크기 임계 값 인터럽트 활성화 / 비활성화 제어

세 가지 크기의 인터럽트 각각에는 별도의 
인터럽트 활성화 세트 (ADMAGTHRINTENASET) 및 클리어 (ADMAGTHRINTENACLR) 레지스터가 있습니다.
이들은 각각 활성화 및 비활성화하는 데 사용됩니다.
특정 크기 임계 값 인터럽트가 생성되지 않습니다.

크기 임계 값 인터럽트를 사용하려면,
인터럽트 인 에이블 설정 레지스터의 해당 비트에 1을 쓴다. 
반대로, 크기 임계 값 인터럽트를 비활성화하려면
 인터럽트 인 에이블 클리어 레지스터의 해당 비트에 1을 씁니다.

22.2.5.4 크기 임계 값 인터럽트 플래그

이 세 가지 인터럽트에 대한 플래그를 보유하는
별도의 크기 인터럽트 플래그 레지스터 (ADMAGINTFLG)가 있습니다.
 이 플래그는 해당 인터럽트에 대한
비교 조건이 충족 될 때마다 설정됩니다.
대응하는 플래그가 플래그 레지스터 내에 설정되고
 인터럽트 생성이 가능하면 크기 임계 값 인터럽트가 생성됩니다.
 이 플래그는 플래그에 1을 쓰거나 인터럽트가 현재 우선 순위가 
가장 높은 보류중인 인터럽트 인 경우 인터럽트 오프셋 레지스터에서 읽음으로써 지울 수 있습니다.



22.2.5.5 크기 임계 값 인터럽트 오프셋 레지스터

동시에 대기중인 여러 크기 임계 값 인터럽트를 가질 수 있습니다.
 크기 임계 값 인터럽트 오프셋 레지스터 (ADMAGINTOFF)는
 현재 보류중인 가장 높은 우선 순위 크기 임계 인터럽트의 인덱스를 보유합니다.
 크기 임계 값 인터럽트 1은 가장 높은 우선 순위를 가지고,
 크기 임계 값 인터럽트 3은 가장 낮은 우선 순위를가집니다.
읽기 전용 레지스터이며 크기 임계 값 인터럽트가 보류 중이 아닌 경우 0을 반환합니다.
이 레지스터에 대한 쓰기는 아무 효과가 없습니다.
이 레지스터를 읽으면 레지스터가 다음으로 
우선 순위가 높은 보류중인 크기 임계 값 인터럽트로 업데이트됩니다.
크기 임계값 인터럽트 플래그 레지스터에서 읽기는 또한 해당 플래그를 지운다.
그러나 에뮬레이션 모드에서 크기 임계 값 인터럽트 오프셋 레지스터에서
읽은 인터럽트 플래그 레지스터 또는 인터럽트 오프셋 레지스터에 영향을주지 않습니다.


22.2.6 ADC 특수모드

ADC 모듈은 진단 및 절전을 위해 몇 가지 특수 모드를 지원합니다.

22.2.6.1 ADC 오류 교정 모드

응용 프로그램은 자체 테스트 모드가 비활성화 될 때마다 
(SELF_TEST = 0) 교정 시퀀스를 활성화 할 수 있습니다.
이 교정 순서에는 내장 된 교정의 변환 오프셋 오차 보정 값의 계산이 뒤 따른다.

참고 : 보정 전 자체 테스트 모드 비활성화
교정 작업 중 오류를 방지하려면 교정 순서 중에 자가 테스트 모드를 활성화하지 않아야합니다.
또한 정확한 결과를 얻으려면 노이즈가 적은 환경에서 ADC를 보정하십시오. 
보정 모드는 CAL_EN 비트 (ADCALCR.0)를 설정하여 활성화됩니다.

응용 프로그램은 보정 모드가 활성화되어있을 때 변환 그룹이 서비스되고 있지 않은지 확인해야합니다.
입력 멀티플렉서는 디스 에이블되고 기준 전압 만이 ADC 코어 입력에 연결된다.
그림 22-13의 스위치 S5가 열립니다.
또한 변환으로 발생한 디지털 결과는 ADC 코어에서 보정 및 오프셋 오류 보정 레지스터 ADCALR로 출력됩니다.
ADC 결과의 메모리는 보정 변환의 영향을받지 않습니다.
보정 모드가 비활성화되면 ADC는 정상적인 변환을 위해 구성 될 수 있습니다.

22.2.6.1.1 교정 변환

교정 변환은 또한 ADC의 최소 샘플링 시간 사양을 충족시켜야합니다.
이 값은 일반적으로 1 us입니다.
이벤트 그룹 샘플 시간 레지스터 (ADEVSAMP)는 
교정 변환을위한 ADCLK 사이클의 수를 지정하는 데 사용됩니다.
BRIDGE_EN 및 HILO 비트 (ADCALCR.9 : 8)는 그림 22-15에 표시된 보정 참조 장치에 대한 전압을 제어합니다.
교정 모드에서 스위치의 위치는 표 22-2에 나열되어 있습니다.


CAL_ST (ADCALCR.16)이 설정되면 교정 변환이 시작됩니다.
BRIDGE_EN 및 HILO 비트를 통해 선택된 전압 소스는 한 번 변환되고 (단일 변환 모드)
디지털 결과는 보정 및 보정 레지스터 ADCALR로 반환됩니다.
ADCALR은 CPU에서 읽을 수 있습니다.
CAL_ST 비트는 플래그 역할을하며 CPU가 폴링해야합니다.
변환 프로세스 중에 설정되어 자동으로 지워져 기준 전압 변환의 끝을 나타냅니다.

NOTE:교정 종료시 인터럽트 없음

ADC는 보정 변환의 종료를 알리는 인터럽트를 생성하지 않습니다.
응용 프로그램은 CAL_ST 비트를 폴링하여 보정 변환의 끝을 결정해야합니다.
응용 프로그램에서 CAL_ST 비트를 설정 한 후에는 ADC 코어에서 생성 된 진행중인 변환의 끝까지 재설정 할 수 있습니다.

보정 변환이 중단되면 (CAL_EN 비트가 해제됩니다),
CAL_ST 비트는 새로운 보정 변환이 설정되고 완료 될 때까지 1로 유지됩니다.
보정이 비활성화 된 상태에서 CAL_ST 비트를 설정하면 (CAL_EN = 0) 효과가 없습니다.
그러나 이 상황에서 CAL_EN을 설정하면 즉시 교정 변환이 시작됩니다.
보정 변환이 ADC_Enable (ADC_EN = 0, CAL_EN = 1 및 CAL_ST = 1)에 의해 중단되면
ADC_Enable 비트가 해제되면 (ADC_EN = 1) 새 변환이 자동으로 다시 시작됩니다.

22.2.6.1.2 교정 및 오프셋 오류 수정 시퀀스

ADC 교정을위한 측정 횟수와 측정 소스는 애플리케이션에 따라 다릅니다.
측정 할 각 교정 소스에 대해 CAL_ST 비트를 설정해야합니다.
보정 모드가 활성화되어있는 동안 사용 가능한 모든 교정 소스를
BRIDGE_EN 및 HILO 비트 (표 22-2 참조)에 따라 변환 할 수 있습니다.
교정 값의 디지털 결과는 보정 값을 계산하여 
ADCALR에 다시 기록 할 수 있도록 각 참조 변환 후에 응용 프로그램에서 ADCALR로부터 읽어야합니다.
애플리케이션에 필요한 교정 데이터가 있으면 옵셋 오류 보정 값을 계산하여
보정 및 보정 레지스터 ADCALR에로드해야합니다.
CAL_EN 비트가 지워진 후, 
정상적인 변환 모드가 다시 시작되고 정지 된 곳부터 계속되지만 자기 수정 데이터가 추가됩니다.
정상 모드에서 자체 교정 시스템은 각 그룹의 FIFO에 기록되기 전에 
ADCALR에 저장된 보정 값을 각 디지털 결과에 추가합니다.

기본 보정 루틴은 다음과 같습니다.
1. CAL_EN (ADCALCR.0)을 통해 교정을 활성화하십시오.
2. BRIDGE_EN과 HILO (ADCALCR.9 : 8)를 통해 전압 소스를 선택하십시오.
3. CAL_ST (ADCALCR.16)로 변환을 시작하십시오.
4. CAL_ST가 0이 될 때까지 기다립니다.
5. ADCALR에서 결과를 가져 와서 메모리에 저장하십시오.
6. 원하는 기준 전압에 대해 교정 변환 데이터가 수집 될 때까지 2 단계로 반복합니다.
7. 메모리에 저장된 보정 데이터를 사용하여 오류 보정 값을 계산합니다.
8. ADCALR 레지스터에 계산 된 오류 보정 값의 2를 더합니다.
9. 교정 모드를 비활성화하십시오.


이 때 ADC는 정상 작동하도록 구성 할 수 있으며 
ADCALR에로드 된 오류 수정 값으로 각 디지털 결과를 수정합니다.

참고 : ADC 교정 데이터가 덮어 쓰기되는 것을 방지하십시오.

보정 모드에서 변환 결과는 이전 보정 데이터를 덮어 쓰는 ADCALR에 기록됩니다.
따라서 새로운 변환이 시작되기 전에 ADCALR 레지스터를 읽어야합니다.
수정하지 않으려면 0x0000 값을 ADCALR에 기록해야합니다.
비교정 모드에서는 ADCALR 레지스터를 읽고 쓸 수 있습니다.
정상 모드 (CAL_EN = 0)에서 ADCALR에 쓰여지는 값은 ADC 코어의 각 디지털 결과에 더해진다.

22.2.6.1.3 중간 지점 보정

ADC의 기준 전압 (VrefHi, VrefLo)과의 연결 때문에, 
교정 레퍼런스의 정밀도는 전압에 독립적이다.
반면 스위치드 브리지 저항 (R1 & R2)의 정확도는 제조 공정 편차에 의존합니다.
결과적으로 중간 전압의 정확도는 두 저항의 불완전 성으로 인해 영향을받을 수 있습니다 (예상 불일치 오차는 약 1.5 % 임).
스위칭 기준 전압 장치는 특히 중간 지점 전압의 차등 측정을 지원하도록 설계되었습니다.
이렇게하면 중간 점 참조의 정확성을 보장 할 수 있습니다.
따라서 교정의 효율성이 향상됩니다.
차등 중간 점 교정은 소프트웨어로 제어됩니다.
알고리즘 (전압 소스 측정 및 관련 계산)은 응용 프로그램에 포함 된 교정 소프트웨어 모듈 내에 삽입됩니다.

기본 차등 중간 점 보정 흐름은 다음에 설명됩니다.

1. 응용 프로그램은 전압 VrefHi를 R1에 연결하고 VrefLo를 R2에 연결하고 (BRIDGE_EN = 0, HILO = 0), 
입력 전압 V (cal1)의 변환을 시작하고 디지털 결과 D (cal1)를 메모리에 저장합니다 .
2. 그러면 응용 프로그램은 전압 VrefHi를 R2로 변경하고 VrefLo를 R1 (BRIDGE_EN = 0, HILO = 1)로 변경하고
 새 입력 전압 V (cal2)를 변환 한 다음 발행 된 디지털 결과 D (cal2)를 다시 메모리에 저장합니다.
3. 실제 중간 점의 실제 값은이 두 결과의 평균을 계산하여 구합니다.
[D (cal1) + D (cal2)] / 2; 그림 22-14는 중간 점 보정 흐름을 요약 한 것입니다.

22.2.6.2 ADC 자체 테스트 모드

ADC 모듈은 ADC 입력 채널의 개방 또는 단락을 감지하는 데 사용할 수있는 자가 테스트 모드를 지원합니다.
SELF_TEST 비트 (ADCALCR.24)를 설정하면 자체 테스트 모드가 활성화됩니다.
이 모드에서는 모든 변환 유형 (연속 또는 단일 변환, 동결 활성화 또는 비 동결 활성화, 
인터럽트 활성화 또는 비활성화)을 수행 할 수 있습니다.
일반 모드에서 변환 시퀀스가 진행되는 동안 자체 테스트 모드를 설정하면
현재 채널 변환 결과가 손상 될 수 있습니다.
그러나 시퀀스의 다음 채널은 추가 자체 테스트 사이클 중에 올바르게 변환됩니다.
자체 테스트 및 교정과 관련된 로직이 그림 22-15에 나와 있습니다.



자체 테스트 모드에서는 HILO 비트 (ADCALCR.8)로 정의 된 테스트 전압이 
레지스터를 통해 ADC 코어 입력에 제공된다 (표 22-3 참조).
테스트 소스를 변경하려면 HILO비트를 단일 변환 모드 요청 전에 토글 할수있습니다.
(여기서 토글은 스위치를 껐다 켰다 하는 행위)
변환이 진행되는 동안 이 비트를 변경하면 획득 기간동안 소스가 전환되면
결과가 손상 될 수 있습니다.
그림 22-15에 나와있는 스위치 S5는 자체 테스트 순서를 설명하기위한 목적으로 만 사용됩니다.
이것은물리적 스위치가 없습니다.


자체 테스트 모드의 변환은 정상 작동 모드와 마찬가지로 시작됩니다 (22.2.1.6 절 참조).
변환은 3 가지 모드 제어에서 설정된 구성에 따라 시작됩니다
레지스터 (ADEVMODECR, ADG1MODECR, ADG2MODECR) 및 샘플링 시간 제어 레지스터 (ADEVSAMP, ADG1SAMP, ADG2SAMP)가 있습니다.
자체 테스트 모드에서 각 변환의 획득 시간은 정상적인 구성 획득 시간의 두 배로 확장됩니다.
선택된 기준 전압과 ADINx 입력 채널로부터의 입력 전압은 이 연장 획득 기간 내내 ADC 내부 샘플링 커패시터에 모두 연결된다.
그림 22-16은 ADREFLO가 자체 테스트 모드 변환을위한 기준 전압으로 선택 될 때의 자체 테스트 모드 타이밍을 보여줍니다.
또한 ADC 입력 채널에 연결된 외부 커패시터를 추정한다.

22.2.6.2.1 ADC 입력 채널의 개방 / 단락을 결정하기위한자가 테스트 모드의 사용

ADC 핀 상태를 추론하는 데 다음 시퀀스를 사용해야합니다.

• 자체 테스트를 활성화하고 참조 전압을 Vreflo로 설정하여 채널을 변환합니다.
  변환 결과를 저장하십시오 (예 : Vd).

• 자체 테스트를 활성화하고 참조 전압을 Vrefhi로 설정하여 채널을 변환합니다.
  변환 결과를 저장합니다 (예 : Vu).

• 자체 테스트가 비활성화 된 채로 채널을 변환하십시오.
변환 결과를 저장하십시오 (예 : Vn).
결과는 다음 표를 사용하여 해석 할 수 있습니다.

22.2.6.3 ADC 파워 다운 모드

이는 ADC 모듈에 대한 클록이 정지 된 상태에서 모듈을 정지시킨 비활성 모드입니다.
진행중인 변환이 없을 때마다 ADC 코어 (ADCLK)에 대한 클럭이 중지됩니다.
이것은 클럭 게이팅 구현 요구 사항입니다.
또한 ADC 모듈은 ADC 코어를 파워 다운 모드로 전환하여 ADC 작동 및 레퍼런스 전원으로부터 최소의 전류를 끌어 낸다.

ADC 코어 전원 공급 중단하기 22.2.6.3.1

ADC 코어에 대한 클럭을 멈추지 않고 ADC 코어를 개별적으로 파워 다운 할 수있다.
이는 ADC 동작 모드 제어 레지스터 (ADOPMODECR.3)의 POWERDOWN 비트를 설정하여 수행 할 수있다.
변환이 필요할 때마다 POWERDOWN 비트를 지워야하며,
새로운 변환을 시작하기 전에 최소 시간 t d (PU-ADV) (실제 값에 대한 특정 장치 데이터 시트 참조)가 허용되어야합니다.
이 대기 시간은 응용 프로그램 소프트웨어에서 구현해야합니다.


22.2.6.3.2 강화 된 파워 다운 모드 

ADC 동작 모드 제어 레지스터 비트인 IDLE_PWRDN (ADOPMODECR.4)은 ADC의 향상된 파워 다운 모드를 가능하게한다.
이 비트가 설정되면, ADC 모듈은 ADC 변환이 계속되거나 보류 상태가 아닐 때마다 ADC 코어의 전원을 끕니다.
ADC 코어는 POWERDOWN 비트 (ADOPMODECR.3)와 관계없이 ADC 코어의 전원이 꺼집니다.


ADC 모듈은 새로운 변환이 요청되는 즉시 ADC 코어를 절전 모드에서 해제한다.
그러면 ADC 로직 상태 머신은 새로운 변환을 시작하기 전에 적어도 td (PU-ADV)를 기다려야한다
(실제 값은 디바이스 데이터 시트 참조).
IDLE_PWRDN 비트는 항상 설정 상태로 유지됩니다.

로직 상태 머신은 IDLE_PWRDN 비트를 사용하여 입력 채널을 샘플링하기 전에
프로그래밍 가능한 VCLK 사이클 수를 기다려야 하는지를 결정할 수있다.
이 시간은 ADC 파워 업 지연 제어 레지스터 (ADPWRUPDLYCTRL)에 의해 설정된다.
IDLE_PWRDN이 설정되지 않은 경우,
ADC 모듈은 입력 채널을 샘플링하기 전에 추가 지연을 기다리지 않으며 
애플리케이션 소프트웨어는 이러한 요구되는 지연을 고려해야합니다.

22.2.6.3.3 ADC 모듈에 대한 클록 관리 

ADC 모듈의 클럭은 적절한 PCR (Peripheral Central Resource) 컨트롤러 PSPWRDNSET 레지스터를 통해 꺼질 수 있습니다 
(레지스터 및 설정 비트를 식별하려면 특정 장치 데이터 시트를 확인하십시오).

레지스터 안에 비트가 설정되어있을 때 변환이 진행 중이면 
ADC 모듈은 ADC 모듈 클록이 정지되기 전에 현재 변환이 완료 될 때까지 대기합니다.

ADC 샘플 커패시터 방전 모드 22.2.6.4

이 모드는 다음 채널의 샘플링 단계를 시작하기 전에 
ADC 코어의 내부 샘플링 커패시터의 전하가 방전되도록한다.
(샘플링의 의미: 작업이나 동작을 이상적인 시간에 샘플링하고 그결과로부터 통계적으로 판단하는것)

ADC 샘플 캡 방전 모드는 그룹의 ADSAMPDISEN 레지스터의 SAMP_DIS_EN 비트를 설정함으로써 가능하다.
그림 22-17과 같이 샘플링 커패시터의 방전주기가 각 채널의 샘플링주기 전에 추가됩니다.
이 방전 기간은 ADSAMPDISEN 레지스터의 해당 그룹의 s_SYS_DIS_CYC 필드를 통해 구성 할 수 있습니다.
방전 시간은 ADCLK 사이클 수로 지정됩니다.
샘플 커패시터 방전 기간 동안 V REFLO 기준 전압은 ADC 코어의 입력 전압 단자에 연결된다.
이렇게하면 이전 변환에서 샘플링 커패시터에 수집 된 모든 전하가 접지로 방전 될 수 있습니다.
V REFLO 기준 전압은 대개 접지에 연결됩니다.


22.2.7 ADC 결과의 RAM 특수 기능

ADC모듈의 향상된 결과의 RAM의 가능성과 무결성을 위해 지원하는 몇가지 특수한 기능에 대한 설명이다.

22.2.7.1 ADC 결과의 RAM 자동 초기화

ADC 모듈을 사용하면 애플리케이션이 ADC 결과의 RAM을 모두 0으로 자동 초기화 할 수 있습니다.
애플리케이션은 자동 초기화 프로세스를 시작하기 전에 ADC 모듈이 변환 모드에 있지 않도록해야합니다.
자동 초기화 순서는 다음과 같습니다.

1. 시스템 모듈의 MINITGCR 레지스터의 비트 [3-0]에 1010 값을 프로그래밍하여 전역 하드웨어 메모리 초기화 키를 활성화합니다.
2. MSINENA 시스템 모듈 레지스터에서 ADC 결과의 RAM에 대한 제어 비트를 설정합니다.
MSINENA 레지스터의 비트 8은 ADC1 결과의 RAM 초기화를 제어하는 ​​데 사용되는 반면 
비트 14는 ADC2 결과의 RAM 초기화를 제어하는 ​​데 사용됩니다.
초기화 프로세스가 시작됩니다.
ADBNDEND 레지스터의 BUF_INIT_ACTIVE 플래그는 초기화가 진행 중임을 나타 내기 위해 설정됩니다.
3. 메모리 초기화가 완료되면 MINISTAT 레지스터의 해당 상태 비트가 설정됩니다.
또한 BUF_INIT_ACTIVE 플래그가 지워집니다.

22.2.7.2 ADC 결과의 RAM 테스트 모드

ADC의 정의 된 변환 모드에서, 애플리케이션은 ADC 결과의 RAM에서만 읽을 수 있습니다.
오직 ADC모듈의 쓰기는 결과의 RAM에 맞춰서 쓸수 있다.
응용 프로그램이 ADC 결과의 RAM에 쓸 수 있도록 특수 테스트 모드가 정의됩니다.
이 모드는 ADC 결과의 RAM 테스트 모드입니다.
이 테스트 모드에서는 ADC 결과의 RAM에 32 비트 읽기 및 쓰기 만 허용됩니다.

참고 : ADC결과RAM의 액세스 구성

ADC 모듈은 결과RAM에 응용프로그램이 쓰는것과 ADC가 결과RAM에 쓰는것 사이에서 속성을 다룰수 없다.
결과RAM의 테스트 모드가 활성화 된 경우 ADC가 결과 RAM에 새로운 변환 결과를 쓰지 않는지 확인해야한다.
ADC 결과의 RAM 테스트 모드는 ADOPMODECR의 RAM_TEST_EN 비트를 설정하여 활성화됩니다.

22.2.7.3 ADC 결과의 RAM 패리티

다음은 ADC 결과의 RAM 패리티 제어 레지스터를 보여줍니다.
패리티 검사는 ADC RAM에 대한 하프 워드 단위로 패리티를 사용하여 구현됩니다.
즉, ADC RAM의 16 비트로 구성된 하나의 패리티 비트가 있습니다.
ADC RAM 패리티의 극성은 시스템 모듈 (주소 = 0xFFFFFFDC)의 DEVCR1 레지스터에 의해 제어됩니다.
패리티 검사는 ADPARCR 레지스터에 의해 활성화된다.
재설정 후 패리티 검사가 비활성화되고 패리티 보호가 필요한 경우 활성화해야합니다.
읽기 액세스 중에는 패리티가 ADC RAM에서 읽은 데이터를 기반으로 계산되고
패리티 비트에 저장된 양호한 패리티 값과 비교됩니다.
어떤 단어가 패리티 검사에 실패하면 ADC는 오류 신호 모듈 (ESM)에 연결되는 오류 신호를 생성합니다.
패리티 오류를 생성 한 ADC RAM 주소는 호스트 시스템 디버깅을 위해 캡처되며 
응용 프로그램에서 읽을 때까지 업데이트되지 않습니다.

패리티 검사 메커니즘 테스트 :

패리티 검사 메커니즘 자체를 테스트하기 위해 패리티 RAM은 특수 테스트 모드에서 CPU에 의해 쓰기 가능하도록 만들어집니다.
이것은 AD PAR CR 레지스터의 TEST라는 제어 비트에 의해 수행됩니다.
이 비트가 설정되면 패리티 비트는 ADC RAM의 기본 주소에서 4KB의 주소 오프셋에서 시작하는 주소로 매핑됩니다.
그림 22-18을 참조하십시오.
이제 CPU가 수동으로 패리티 오류를 삽입 할 수 있습니다.
ADC RAM은 32 비트 액세스를 지원합니다.

22.2.8 ADEVT 핀 범용 I / O 기능

ADC1 용 AD1EVT 핀과 ADC2 용 AD2EVT 핀은 범용 I / O 신호로 구성 할 수 있습니다.
다음 섹션에서는 애플리케이션이 ADxEVT 핀을 구성 할 수있는 다양한 방법에 대해 설명한다.

22.2.8.1 GPIO 기능
그림 22-19는 ADxEVT 핀의 GPIO 기능을 설명합니다.

디바이스 파워 온 리셋이 해제되면 ADC 모듈은 ADxEVT 핀의 상태를 제어한다.

• 끌어 오기 제어 : 끌어 오기 제어는 기본적으로 활성화 또는 비활성화 될 수 있습니다
 (시스템 재설정이 활성화되어 있고 해제 된 후).
 끌어 오기 컨트롤의 실제 기본 상태는 장치 데이터 시트에 지정되어 있습니다.
애플리케이션은 ADEVTPDIS 레지스터의 PDIS (풀 제어 디스 에이블) 비트를 클리어함으로써 풀 제어를 가능하게 할 수있다.
이 경우 ADEVTPSEL 레지스터의 PSEL (풀 선택) 비트가 설정되면 핀에 풀업이 생깁니다.
PSEL 비트가 해제되면 핀은 풀다운을 갖게됩니다.
PDIS 비트가 제어 레지스터에 설정되면 핀에 풀업 또는 풀다운이 발생하지 않습니다.

참고 : ADxEVT가 output으로 구성된 경우의 풀 동작

ADxEVT 핀이 출력으로 구성된 경우 끌어 오기는 자동으로 비활성화됩니다.
핀이 입력으로 설정된 경우 풀 비활성화는
풀 비활성화 레지스터 ADEVTPDIS의 비트 PDIS에 따라 활성화 또는 비활성화됩니다.
출력 버퍼 : ADEVTDIR 비트가 핀 방향 제어 레지스터에 설정되면 ADxEVT 핀을 출력 핀으로 구동 할 수 있습니다.
오픈 드레인 기능 : 오픈 드레인 출력 기능은 ADEVTPDR 제어 레지스터를 통해 활성화됩니다.

ADxEVT 핀도 이 모드의 출력 핀이되도록 구성되어야한다.
- 핀에 로우 신호가 입력되면 출력 버퍼가 활성화됩니다.
- 핀에 높은 신호가 켜지면 출력 버퍼가 비활성화됩니다.

22.3부터는 ADC레지스터 입니다!





