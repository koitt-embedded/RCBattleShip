<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EDMA3 Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EDMA3 Functions<div class="ingroups"><a class="el" href="group___c_s_l___e_d_m_a3___a_p_i.html">EDMA3</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga588ede6cd00b9ae480f847010a9433e8"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gaa6e2443bbc7d672e0e66a66c2f059448">CSL_Edma3Context</a> *pContext)</td></tr>
<tr class="separator:ga588ede6cd00b9ae480f847010a9433e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b7e551e286eabb426729fcc8221eb87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga5ec70099d6fe560fcbc690e5501f92b7">CSL_Edma3Obj</a> *pEdmaObj, CSL_InstNum edmaNum, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gaaf0feb95229cadc3595103d84bae27bf">CSL_Edma3ModuleAttr</a> *pAttr, CSL_Status *pStatus)</td></tr>
<tr class="separator:ga0b7e551e286eabb426729fcc8221eb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9068b8c6350a7315324b839903a2f8e7"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9068b8c6350a7315324b839903a2f8e7">CSL_edma3Close</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hEdma)</td></tr>
<tr class="separator:ga9068b8c6350a7315324b839903a2f8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga886d978dc328ae551fe7c6e6d27e5760"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga886d978dc328ae551fe7c6e6d27e5760">CSL_edma3HwSetup</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hMod, const <a class="el" href="struct_c_s_l___edma3_hw_setup.html">CSL_Edma3HwSetup</a> *setup)</td></tr>
<tr class="separator:ga886d978dc328ae551fe7c6e6d27e5760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c76720c150fd720fe1f6804448a1201"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9c76720c150fd720fe1f6804448a1201">CSL_edma3GetHwSetup</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hMod, const <a class="el" href="struct_c_s_l___edma3_hw_setup.html">CSL_Edma3HwSetup</a> *setup)</td></tr>
<tr class="separator:ga9c76720c150fd720fe1f6804448a1201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb623f701478b59272d92cff3ba8d1a"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaffb623f701478b59272d92cff3ba8d1a">CSL_edma3HwControl</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hMod, <a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gaf441a2c75e8197725dab2ef511bdcb1b">CSL_Edma3HwControlCmd</a> cmd, const void *cmdArg)</td></tr>
<tr class="separator:gaffb623f701478b59272d92cff3ba8d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dce429cdb101c32e46ad00ba533f367"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9dce429cdb101c32e46ad00ba533f367">CSL_edma3ccGetModuleBaseAddr</a> (CSL_InstNum edmaNum, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gaaf0feb95229cadc3595103d84bae27bf">CSL_Edma3ModuleAttr</a> *pParam, <a class="el" href="struct_c_s_l___edma3_module_base_address.html">CSL_Edma3ModuleBaseAddress</a> *pBaseAddress, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga6b6ed78d35da8237fb46cd6d2988b881">CSL_Edma3CfgInfo</a> *pCfgInfo)</td></tr>
<tr class="separator:ga9dce429cdb101c32e46ad00ba533f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fce3d26dc2a3d38cbe0c573e197555f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga7fce3d26dc2a3d38cbe0c573e197555f">CSL_edma3GetHwStatus</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hMod, <a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#ga17d8879487a291855d58778ace1600a4">CSL_Edma3HwStatusQuery</a> myQuery, void *response)</td></tr>
<tr class="separator:ga7fce3d26dc2a3d38cbe0c573e197555f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59eef2276ba2cff959cc46a11b190a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga816e0605134d253cfc835aa26764f63e">CSL_Edma3ChannelObj</a> *pEdmaObj, CSL_InstNum edmaNum, const <a class="el" href="struct_c_s_l___edma3_channel_attr.html">CSL_Edma3ChannelAttr</a> *pChAttr, CSL_Status *pStatus)</td></tr>
<tr class="separator:ga59eef2276ba2cff959cc46a11b190a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6454a219ec499624a47a356053eb5c78"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga6454a219ec499624a47a356053eb5c78">CSL_edma3ChannelClose</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma)</td></tr>
<tr class="separator:ga6454a219ec499624a47a356053eb5c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e947bb8dfae54b3d824fa6fa4b9350c"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9e947bb8dfae54b3d824fa6fa4b9350c">CSL_edma3HwChannelSetupParam</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma, Uint16 paramNum)</td></tr>
<tr class="separator:ga9e947bb8dfae54b3d824fa6fa4b9350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga910b5dacecf2d7d8e381acdbee06e777"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga910b5dacecf2d7d8e381acdbee06e777">CSL_edma3HwChannelSetupTriggerWord</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma, Uint8 triggerWord)</td></tr>
<tr class="separator:ga910b5dacecf2d7d8e381acdbee06e777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111c2fac7c9b7c5b70d5d53a3b446e64"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga111c2fac7c9b7c5b70d5d53a3b446e64">CSL_edma3HwChannelSetupQue</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma, <a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gac24f2bf4e0f2e746622583a1e978426a">CSL_Edma3Que</a> evtQue)</td></tr>
<tr class="separator:ga111c2fac7c9b7c5b70d5d53a3b446e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bea1c818b898dfc4b4616dabb81e1c"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gab4bea1c818b898dfc4b4616dabb81e1c">CSL_edma3GetHwChannelSetupParam</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma, Uint16 *paramNum)</td></tr>
<tr class="separator:gab4bea1c818b898dfc4b4616dabb81e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daa8ec3510804d72a3cafd33986d85b"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga3daa8ec3510804d72a3cafd33986d85b">CSL_edma3GetHwChannelSetupTriggerWord</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma, Uint8 *triggerWord)</td></tr>
<tr class="separator:ga3daa8ec3510804d72a3cafd33986d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65d554238f8830b58aa434c6e82a5f6"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gac65d554238f8830b58aa434c6e82a5f6">CSL_edma3GetHwChannelSetupQue</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma, <a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gac24f2bf4e0f2e746622583a1e978426a">CSL_Edma3Que</a> *evtQue)</td></tr>
<tr class="separator:gac65d554238f8830b58aa434c6e82a5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a19f893f0b2239fe683b27214b9df9"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga78a19f893f0b2239fe683b27214b9df9">CSL_edma3HwChannelControl</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hCh, <a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#ga2c97e69b09f5e164f9ab3408e5593ff4">CSL_Edma3HwChannelControlCmd</a> cmd, void *cmdArg)</td></tr>
<tr class="separator:ga78a19f893f0b2239fe683b27214b9df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545cf03fe221d662b64b87539106056f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga545cf03fe221d662b64b87539106056f">CSL_edma3GetHwChannelStatus</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma, <a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gacb77d5063815d321691ee225c74bd2c7">CSL_Edma3HwChannelStatusQuery</a> myQuery, void *response)</td></tr>
<tr class="separator:ga545cf03fe221d662b64b87539106056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c954b177f482c066efddbbc3627ffad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga37e63265093e9e1a45c9e8b31f8608bd">CSL_Edma3ParamHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9c954b177f482c066efddbbc3627ffad">CSL_edma3GetParamHandle</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> hEdma, Int16 paramNum, CSL_Status *status)</td></tr>
<tr class="separator:ga9c954b177f482c066efddbbc3627ffad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168d4c4967d21076a562f6777d281a9b"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga168d4c4967d21076a562f6777d281a9b">CSL_edma3ParamSetup</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga37e63265093e9e1a45c9e8b31f8608bd">CSL_Edma3ParamHandle</a> hParamHndl, const <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga2c16ecb5df5dd2fe4c2fc8757bb7b61e">CSL_Edma3ParamSetup</a> *setup)</td></tr>
<tr class="separator:ga168d4c4967d21076a562f6777d281a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8387a3b68b4bc948580e0a1d301d66dd"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8387a3b68b4bc948580e0a1d301d66dd">CSL_edma3ParamWriteWord</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga37e63265093e9e1a45c9e8b31f8608bd">CSL_Edma3ParamHandle</a> hParamHndl, Uint16 wordOffset, Uint32 word)</td></tr>
<tr class="separator:ga8387a3b68b4bc948580e0a1d301d66dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae61cc100cdf1d62f35787426ca2b342d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gae61cc100cdf1d62f35787426ca2b342d">CSL_edma3GetInfo</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga57808bce667ae4dd7e46a849b68f83ac">CSL_Edma3QueryInfo</a> *response)</td></tr>
<tr class="separator:gae61cc100cdf1d62f35787426ca2b342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e8100aa3db1c61e789d74fb992e4a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga57e8100aa3db1c61e789d74fb992e4a5">CSL_edma3MapDMAChannelToParamBlock</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Uint16 paramId)</td></tr>
<tr class="separator:ga57e8100aa3db1c61e789d74fb992e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44779b99a16d35cc4b88944cec22514e"><td class="memItemLeft" align="right" valign="top">static Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga44779b99a16d35cc4b88944cec22514e">CSL_edma3GetDMAChannelToParamBlockMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga44779b99a16d35cc4b88944cec22514e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e25de939e1bcb1f714be5378058d9a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0e25de939e1bcb1f714be5378058d9a7">CSL_edma3MapQDMAChannelToParamBlock</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Uint16 paramId)</td></tr>
<tr class="separator:ga0e25de939e1bcb1f714be5378058d9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea0f5fb5768df2b80b10eaf8ea287d59"><td class="memItemLeft" align="right" valign="top">static Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaea0f5fb5768df2b80b10eaf8ea287d59">CSL_edma3GetQDMAChannelToParamBlockMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel)</td></tr>
<tr class="separator:gaea0f5fb5768df2b80b10eaf8ea287d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7627ac0aea91aa666b330d01c51e1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga6f7627ac0aea91aa666b330d01c51e1e">CSL_edma3SetQDMATriggerWord</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Uint8 trword)</td></tr>
<tr class="separator:ga6f7627ac0aea91aa666b330d01c51e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e8af206fafb44fe5b4233eb30bb205"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gab3e8af206fafb44fe5b4233eb30bb205">CSL_edma3GetQDMATriggerWord</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Uint8 *trword)</td></tr>
<tr class="separator:gab3e8af206fafb44fe5b4233eb30bb205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d5fa3b6f36d2e9dc63c4dc3412f0f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gac9d5fa3b6f36d2e9dc63c4dc3412f0f8">CSL_edma3MapDMAChannelToEventQueue</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Uint8 eventQueue)</td></tr>
<tr class="separator:gac9d5fa3b6f36d2e9dc63c4dc3412f0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de736c33c9bec94590ef201ebf2ead6"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8de736c33c9bec94590ef201ebf2ead6">CSL_edma3GetDMAChannelToEventQueueMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga8de736c33c9bec94590ef201ebf2ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6e2fe8687852b8d640cfbf72e34d07a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaa6e2fe8687852b8d640cfbf72e34d07a">CSL_edma3MapQDMAChannelToEventQueue</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Uint8 eventQueue)</td></tr>
<tr class="separator:gaa6e2fe8687852b8d640cfbf72e34d07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec01050a67942a6fcdd1ce8b3aed2d1"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga5ec01050a67942a6fcdd1ce8b3aed2d1">CSL_edma3GetQDMAChannelToEventQueueMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel)</td></tr>
<tr class="separator:ga5ec01050a67942a6fcdd1ce8b3aed2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d1b866c3c23f1c1f7970f9b5fbc5e6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga6d1b866c3c23f1c1f7970f9b5fbc5e6f">CSL_edma3MapEventQueueToTC</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 tcNum)</td></tr>
<tr class="separator:ga6d1b866c3c23f1c1f7970f9b5fbc5e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eaed8e6d7f20dac45eedcb71ebd6804"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9eaed8e6d7f20dac45eedcb71ebd6804">CSL_edma3GetEventQueueToTCMapping</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue)</td></tr>
<tr class="separator:ga9eaed8e6d7f20dac45eedcb71ebd6804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad8668228a1584b1201fa63e94d2498"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga5ad8668228a1584b1201fa63e94d2498">CSL_edma3SetEventQueuePriority</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 priority)</td></tr>
<tr class="separator:ga5ad8668228a1584b1201fa63e94d2498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404bacac2a4ea2fbef703034d003800e"><td class="memItemLeft" align="right" valign="top">static Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga404bacac2a4ea2fbef703034d003800e">CSL_edma3GetEventQueuePriority</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue)</td></tr>
<tr class="separator:ga404bacac2a4ea2fbef703034d003800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83e94b0bab125d21048a68935123e2f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gae83e94b0bab125d21048a68935123e2f">CSL_edma3GetEventMissed</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, CSL_BitMask32 *missedLo, CSL_BitMask32 *missedHi, CSL_BitMask32 *missedQdma)</td></tr>
<tr class="separator:gae83e94b0bab125d21048a68935123e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc0bc1999aa69769ca9e33215d7c614"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaffc0bc1999aa69769ca9e33215d7c614">CSL_edma3IsDMAChannelMissedEventSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Bool *response)</td></tr>
<tr class="separator:gaffc0bc1999aa69769ca9e33215d7c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c32de61c3988315043e6476ed3a3a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga64c32de61c3988315043e6476ed3a3a8">CSL_edma3IsQDMAChannelMissedEventSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Bool *response)</td></tr>
<tr class="separator:ga64c32de61c3988315043e6476ed3a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bd948c76d68bde4433984ef84eedb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gae6bd948c76d68bde4433984ef84eedb5">CSL_edma3EventsMissedClear</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, CSL_BitMask32 missedLo, CSL_BitMask32 missedHi, CSL_BitMask32 missedQdma)</td></tr>
<tr class="separator:gae6bd948c76d68bde4433984ef84eedb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4772e6598f65bac04d0c59ca7a1b3612"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga4772e6598f65bac04d0c59ca7a1b3612">CSL_edma3ClearDMAMissedEvent</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga4772e6598f65bac04d0c59ca7a1b3612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6219a158b58e7defea51a7f3f53f5855"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga6219a158b58e7defea51a7f3f53f5855">CSL_edma3ClearQDMAMissedEvent</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel)</td></tr>
<tr class="separator:ga6219a158b58e7defea51a7f3f53f5855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff82735cb56a5e4f20f4e0a89fbf2e3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaff82735cb56a5e4f20f4e0a89fbf2e3e">CSL_edma3GetControllerError</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga76304c2b9e36a2959a1bcaf63d84502b">CSL_Edma3CtrlErrStat</a> *ccStat)</td></tr>
<tr class="separator:gaff82735cb56a5e4f20f4e0a89fbf2e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5458556421487c2da32cbf1dc9bdb2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gafb5458556421487c2da32cbf1dc9bdb2">CSL_edma3ClearControllerError</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, const <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga76304c2b9e36a2959a1bcaf63d84502b">CSL_Edma3CtrlErrStat</a> *ccStat)</td></tr>
<tr class="separator:gafb5458556421487c2da32cbf1dc9bdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4110e49f4500afc5314104bb3c4d5673"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga4110e49f4500afc5314104bb3c4d5673">CSL_edma3ErrorEval</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule)</td></tr>
<tr class="separator:ga4110e49f4500afc5314104bb3c4d5673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fcbc17db5594f430851db0bdd785e03"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0fcbc17db5594f430851db0bdd785e03">CSL_edma3DmaRegionAccessEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int edmaRegion, CSL_BitMask32 drae, CSL_BitMask32 draeh)</td></tr>
<tr class="separator:ga0fcbc17db5594f430851db0bdd785e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070e9c2a86bd18ce0850dfc45e7d5551"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga070e9c2a86bd18ce0850dfc45e7d5551">CSL_edma3DmaRegionAccessDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int edmaRegion, CSL_BitMask32 drae, CSL_BitMask32 draeh)</td></tr>
<tr class="separator:ga070e9c2a86bd18ce0850dfc45e7d5551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c8815957d655fd903f7ff29719bfee5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga1c8815957d655fd903f7ff29719bfee5">CSL_edma3QdmaRegionAccessEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int edmaRegion, CSL_BitMask32 qrae)</td></tr>
<tr class="separator:ga1c8815957d655fd903f7ff29719bfee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1253d6e8d81dd6370fdbea203f62718c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga1253d6e8d81dd6370fdbea203f62718c">CSL_edma3QdmaRegionAccessDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int edmaRegion, CSL_BitMask32 qrae)</td></tr>
<tr class="separator:ga1253d6e8d81dd6370fdbea203f62718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dd2dfe416cd94e4ca3d9d0a1a6176a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga83dd2dfe416cd94e4ca3d9d0a1a6176a">CSL_edma3GetWaterMark</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 *waterMark)</td></tr>
<tr class="separator:ga83dd2dfe416cd94e4ca3d9d0a1a6176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc05b1eb70228c60531fbbb1c3921c3c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gadc05b1eb70228c60531fbbb1c3921c3c">CSL_edma3GetNumberValidEntries</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 *numValidEntries)</td></tr>
<tr class="separator:gadc05b1eb70228c60531fbbb1c3921c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3d8851f43a731dbbc084f5a9b2db8d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga7f3d8851f43a731dbbc084f5a9b2db8d">CSL_edma3GetStartPointer</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 *startPtr)</td></tr>
<tr class="separator:ga7f3d8851f43a731dbbc084f5a9b2db8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3284c3d8aa6cf1228c8b834581e9f7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaa3284c3d8aa6cf1228c8b834581e9f7a">CSL_edma3GetThresholdExceeded</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Bool *thresholdExceeded)</td></tr>
<tr class="separator:gaa3284c3d8aa6cf1228c8b834581e9f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8f408030d583005808e473ffbffecc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gada8f408030d583005808e473ffbffecc">CSL_edma3EventQueueThresholdSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 eventQueue, Uint8 threshold)</td></tr>
<tr class="separator:gada8f408030d583005808e473ffbffecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d54fbe4ac3a8808b4085b0785519a9a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga4d54fbe4ac3a8808b4085b0785519a9a">CSL_edma3GetActivityStatus</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga2ae058d6cba90191fa7e3ec7a319a52f">CSL_Edma3ActivityStat</a> *activityStat)</td></tr>
<tr class="separator:ga4d54fbe4ac3a8808b4085b0785519a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00186ec229dde02888eaf6a9ac4b2e95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga00186ec229dde02888eaf6a9ac4b2e95">CSL_edma3GetMemoryFaultError</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gac83cf570375046eeab358c62f4d34699">CSL_Edma3MemFaultStat</a> *memFault)</td></tr>
<tr class="separator:ga00186ec229dde02888eaf6a9ac4b2e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c24483db8373f8e4b8eae0a9ad295ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8c24483db8373f8e4b8eae0a9ad295ca">CSL_edma3MemFaultClear</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule)</td></tr>
<tr class="separator:ga8c24483db8373f8e4b8eae0a9ad295ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5194b8227d01a15dfdc53354e41b755"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gac5194b8227d01a15dfdc53354e41b755">CSL_edma3GetMemoryProtectionAttrib</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 *mppa)</td></tr>
<tr class="separator:gac5194b8227d01a15dfdc53354e41b755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c5d18de6e596e42437199c3601b881"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59c5d18de6e596e42437199c3601b881">CSL_edma3SetMemoryProtectionAttrib</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 mppa)</td></tr>
<tr class="separator:ga59c5d18de6e596e42437199c3601b881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866c9adb7b8e44f8cd62df238122c46d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga866c9adb7b8e44f8cd62df238122c46d">CSL_edma3IsDMAChannelEventPending</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Bool *response)</td></tr>
<tr class="separator:ga866c9adb7b8e44f8cd62df238122c46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015fd64ae0f97abb699b3a0950cce12e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga015fd64ae0f97abb699b3a0950cce12e">CSL_edma3ClearDMAChannelEvent</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga015fd64ae0f97abb699b3a0950cce12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b71a3e6c8bb5938e759d7abb1c071c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gab6b71a3e6c8bb5938e759d7abb1c071c">CSL_edma3SetDMAChannelEvent</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 dmaChannel)</td></tr>
<tr class="separator:gab6b71a3e6c8bb5938e759d7abb1c071c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b74b51ed885b086a933b1f971aecd7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga98b74b51ed885b086a933b1f971aecd7">CSL_edma3DMAChannelDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga98b74b51ed885b086a933b1f971aecd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa54eff8bdd357d4cc1827b15bce2d317"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaa54eff8bdd357d4cc1827b15bce2d317">CSL_edma3DMAChannelEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 dmaChannel)</td></tr>
<tr class="separator:gaa54eff8bdd357d4cc1827b15bce2d317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c6f7086fcc2f1f60d1ffa744d26b9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gac4c6f7086fcc2f1f60d1ffa744d26b9e">CSL_edma3GetDMASecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, CSL_BitMask32 *secEventLo, CSL_BitMask32 *secEventHi)</td></tr>
<tr class="separator:gac4c6f7086fcc2f1f60d1ffa744d26b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d6bf46947c559ac464a2856209cd65"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gad5d6bf46947c559ac464a2856209cd65">CSL_edma3IsDMAChannelSecondaryEventSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel, Bool *response)</td></tr>
<tr class="separator:gad5d6bf46947c559ac464a2856209cd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7980f171ac5f5cb2f7cd168944a9b88d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga7980f171ac5f5cb2f7cd168944a9b88d">CSL_edma3ClearDMASecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, CSL_BitMask32 secEventLo, CSL_BitMask32 secEventHi)</td></tr>
<tr class="separator:ga7980f171ac5f5cb2f7cd168944a9b88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b02edfc6f108291b61b89c448a699f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga22b02edfc6f108291b61b89c448a699f">CSL_edma3ClearDMAChannelSecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 dmaChannel)</td></tr>
<tr class="separator:ga22b02edfc6f108291b61b89c448a699f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cca9a54be594bf9b3d9642e9538797e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8cca9a54be594bf9b3d9642e9538797e">CSL_edma3InterruptLoDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrLo)</td></tr>
<tr class="separator:ga8cca9a54be594bf9b3d9642e9538797e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9b854d4799036131f82237bc877ca5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaec9b854d4799036131f82237bc877ca5">CSL_edma3InterruptHiDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrHi)</td></tr>
<tr class="separator:gaec9b854d4799036131f82237bc877ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d222265626a331066b9ec9aaa38d25e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga2d222265626a331066b9ec9aaa38d25e">CSL_edma3InterruptLoEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrLo)</td></tr>
<tr class="separator:ga2d222265626a331066b9ec9aaa38d25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd501db6edf23e9201e11cf63acd7bd6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gadd501db6edf23e9201e11cf63acd7bd6">CSL_edma3InterruptHiEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrHi)</td></tr>
<tr class="separator:gadd501db6edf23e9201e11cf63acd7bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743ae95c1373dc77ef523f848fb8f40d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga743ae95c1373dc77ef523f848fb8f40d">CSL_edma3GetLoPendingInterrupts</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 *intrLo)</td></tr>
<tr class="separator:ga743ae95c1373dc77ef523f848fb8f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99bde63badafa04c8ec1c9024ceb9179"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga99bde63badafa04c8ec1c9024ceb9179">CSL_edma3GetHiPendingInterrupts</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 *intrHi)</td></tr>
<tr class="separator:ga99bde63badafa04c8ec1c9024ceb9179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8649dce41be1f3eb9ab730f0b2f6dad9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8649dce41be1f3eb9ab730f0b2f6dad9">CSL_edma3ClearLoPendingInterrupts</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrLo)</td></tr>
<tr class="separator:ga8649dce41be1f3eb9ab730f0b2f6dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffcdd5be47e621d5dec4581e1f7166d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaffcdd5be47e621d5dec4581e1f7166d4">CSL_edma3ClearHiPendingInterrupts</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, CSL_BitMask32 intrHi)</td></tr>
<tr class="separator:gaffcdd5be47e621d5dec4581e1f7166d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c5e5d18e400c1706deafbe5ea5aed2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga61c5e5d18e400c1706deafbe5ea5aed2">CSL_edma3InterruptEval</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region)</td></tr>
<tr class="separator:ga61c5e5d18e400c1706deafbe5ea5aed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5bd1589917a92b8de77a997811706a1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gaa5bd1589917a92b8de77a997811706a1">CSL_edma3IsQDMAChannelEventPending</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Bool *response)</td></tr>
<tr class="separator:gaa5bd1589917a92b8de77a997811706a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18cbdd27ffd1b507768f64a22758323c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga18cbdd27ffd1b507768f64a22758323c">CSL_edma3QDMAChannelEnable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 qdmaChannel)</td></tr>
<tr class="separator:ga18cbdd27ffd1b507768f64a22758323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace982cddeda1d0afd516524cc4906756"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gace982cddeda1d0afd516524cc4906756">CSL_edma3QDMAChannelDisable</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Int region, Uint8 qdmaChannel)</td></tr>
<tr class="separator:gace982cddeda1d0afd516524cc4906756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae746e4d3ff996ac285846189be3eae51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gae746e4d3ff996ac285846189be3eae51">CSL_edma3GetQDMASecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint32 *qdmaSecEvent)</td></tr>
<tr class="separator:gae746e4d3ff996ac285846189be3eae51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d26ed086c003ea5942764bc83639326"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0d26ed086c003ea5942764bc83639326">CSL_edma3IsQDMAChannelSecondaryEventSet</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel, Bool *response)</td></tr>
<tr class="separator:ga0d26ed086c003ea5942764bc83639326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8890ca36df2fd1b2d296ee380812d1ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga8890ca36df2fd1b2d296ee380812d1ab">CSL_edma3ClearQDMASecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint32 qdmaSecEvent)</td></tr>
<tr class="separator:ga8890ca36df2fd1b2d296ee380812d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315b2794bb181cc094ce5b01006c3dfd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga315b2794bb181cc094ce5b01006c3dfd">CSL_edma3ClearQDMAChannelSecondaryEvents</a> (<a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> hModule, Uint8 qdmaChannel)</td></tr>
<tr class="separator:ga315b2794bb181cc094ce5b01006c3dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9dce429cdb101c32e46ad00ba533f367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3ccGetModuleBaseAddr </td>
          <td>(</td>
          <td class="paramtype">CSL_InstNum&#160;</td>
          <td class="paramname"><em>edmaNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gaaf0feb95229cadc3595103d84bae27bf">CSL_Edma3ModuleAttr</a> *&#160;</td>
          <td class="paramname"><em>pParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___edma3_module_base_address.html">CSL_Edma3ModuleBaseAddress</a> *&#160;</td>
          <td class="paramname"><em>pBaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga6b6ed78d35da8237fb46cd6d2988b881">CSL_Edma3CfgInfo</a> *&#160;</td>
          <td class="paramname"><em>pCfgInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ccGetModuleBaseAddr</b> </p>
<p><b>Description</b> <br />
 This function is used for getting the base-address of the peripheral instance. This function will be called inside the @ <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a>/ <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> function call.</p>
<p>Note: This function is open for re-implementing if the user wants to modify the base address of the peripheral object to point to a different location and there by allow CSL initiated write/reads into peripheral MMR's go to an alternate location.</p>
<p><b>Arguments</b> </p><pre class="fragment">         edmaNum         Specifies the instance of the edma to be opened.
         pParam          Module specific parameters.
         pBaseAddress    Pointer to baseaddress structure containing base 
                         address details.
         pCfgInfo        Pointer to the EDMA CC Instance information populated
                         by this API.</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_FAIL (Timer Instance is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Base Address structure is populated</p>
<p><b>Affects</b> <br />
 None.</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_Status                   status;
     CSL_Edma3ModuleBaseAddress   baseAddress;
     CSL_Edma3CfgInfo             cfgInfo;

     // Get the EDMA CC Instance 0 Information 
     status = CSL_edma3ccGetModuleBaseAddr(0, NULL, &amp;baseAddress, &amp;cfgInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6454a219ec499624a47a356053eb5c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3ChannelClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="csl__edma3_channel_close_8c.html" title="The file implements the API which is used to close a previously opened EDMA Channel. ">csl_edma3ChannelClose.c</a></b> </p>
<p><b>Description</b> <br />
 This function marks the channel cannot be accessed anymore using the handle. CSL for the EDMA channel need to be reopened before using any edma channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Handle to the channel to be closed.</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be invoked successfully in that order before this API can be invoked.</p>
<p><b> Post Condition </b> <br />
 The edma channel related CSL APIs can not be called until the edma channel is reopened again using <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a></p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Status                  status;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj, 0, NULL,&amp;status);

         // Channel 0 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum    = 0;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ...             
         // Close Channel
         CSL_edma3ChannelClose(hChannel);
         ... </pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga59eef2276ba2cff959cc46a11b190a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a> CSL_edma3ChannelOpen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga816e0605134d253cfc835aa26764f63e">CSL_Edma3ChannelObj</a> *&#160;</td>
          <td class="paramname"><em>pEdmaObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_InstNum&#160;</td>
          <td class="paramname"><em>edmaNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___edma3_channel_attr.html">CSL_Edma3ChannelAttr</a> *&#160;</td>
          <td class="paramname"><em>pChAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ChannelOpen</b> </p>
<p><b>Description</b> <br />
 The API returns a handle for the specified EDMA Channel for use. The channel can be re-opened anytime after it has been normally closed if so required. The handle returned by this call is input as an essential argument for many of the APIs described for this module.</p>
<p><b>Arguments</b> </p><pre class="fragment">         pEdmaObj         pointer to the object that holds reference to the
                          channel instance of the Specified DMA 
         edmaNum          Instance of EDMA whose channel is requested
         pChAttr          Channel Attributes which describe the channel to
                          be opened.
         status           Status of the function call</pre><p><b> Return Value </b> <br />
 Success - Channel Handle <br />
 Error - NULL</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> must be invoked successfully in that order before this API can be invoked</p>
<p><b> Post Condition </b> EDMA channel object structure is populated</p>
<p><b>Affects</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Status                  status;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj, 0, NULL,&amp;status);

         // Channel 0 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum    = 0;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ... </pre><hr/>
 
</div>
</div>
<a class="anchor" id="gafb5458556421487c2da32cbf1dc9bdb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearControllerError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga76304c2b9e36a2959a1bcaf63d84502b">CSL_Edma3CtrlErrStat</a> *&#160;</td>
          <td class="paramname"><em>ccStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearControllerError</b> </p>
<p><b>Description</b> <br />
 Channel Controller Error Fault.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle        
     ccStat            Error Status which is to be cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_CCERRCLR_QTHRXD0;TPCC_TPCC_CCERRCLR_QTHRXD1;TPCC_TPCC_CCERRCLR_QTHRXD2; TPCC_TPCC_CCERRCLR_QTHRXD3;TPCC_TPCC_CCERRCLR_QTHRXD4;TPCC_TPCC_CCERRCLR_QTHRXD5; TPCC_TPCC_CCERRCLR_QTHRXD6;TPCC_TPCC_CCERRCLR_QTHRXD7, TPCC_TPCC_CCERR_TCCERR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3CtrlErrStat    ccError;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get Controller Error
         status = CSL_edma3GetControllerError(hModule,&amp;ccError);
         ...
         // Clear the error. 
         CSL_edma3ClearControllerError(hModule,&amp;ccError);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga015fd64ae0f97abb699b3a0950cce12e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearDMAChannelEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearDMAChannelEvent</b> </p>
<p><b>Description</b> <br />
 This API clears the event for the specific DMA channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadow or Global)
     dmaChannel      DMA Channel for which the event is cleared. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_ECR_E0=1;TPCC_TPCC_ECR_E1=1;TPCC_TPCC_ECR_E2=1;TPCC_TPCC_ECR_E3=1; TPCC_TPCC_ECR_E4=1;TPCC_TPCC_ECR_E5=1;TPCC_TPCC_ECR_E6=1;TPCC_TPCC_ECR_E7=1; TPCC_TPCC_ECR_E8=1;TPCC_TPCC_ECR_E9=1;TPCC_TPCC_ECR_E10=1;TPCC_TPCC_ECR_E11=1; TPCC_TPCC_ECR_E12=1;TPCC_TPCC_ECR_E13=1;TPCC_TPCC_ECR_E14=1;TPCC_TPCC_ECR_E15=1; TPCC_TPCC_ECR_E16=1;TPCC_TPCC_ECR_E17=1;TPCC_TPCC_ECR_E18=1;TPCC_TPCC_ECR_E19=1; TPCC_TPCC_ECR_E20=1;TPCC_TPCC_ECR_E21=1;TPCC_TPCC_ECR_E22=1;TPCC_TPCC_ECR_E23=1; TPCC_TPCC_ECR_E24=1;TPCC_TPCC_ECR_E25=1;TPCC_TPCC_ECR_E26=1;TPCC_TPCC_ECR_E27=1; TPCC_TPCC_ECR_E28=1;TPCC_TPCC_ECR_E29=1;TPCC_TPCC_ECR_E30=1;TPCC_TPCC_ECR_E31=1; <br />
 TPCC_TPCC_ECRH_E32=1;TPCC_TPCC_ECRH_E33=1;TPCC_TPCC_ECRH_E34=1;TPCC_TPCC_ECRH_E35=1; TPCC_TPCC_ECRH_E36=1;TPCC_TPCC_ECRH_E37=1;TPCC_TPCC_ECRH_E38=1;TPCC_TPCC_ECRH_E39=1; TPCC_TPCC_ECRH_E40=1;TPCC_TPCC_ECRH_E41=1;TPCC_TPCC_ECRH_E42=1;TPCC_TPCC_ECRH_E43=1; TPCC_TPCC_ECRH_E44=1;TPCC_TPCC_ECRH_E45=1;TPCC_TPCC_ECRH_E46=1;TPCC_TPCC_ECRH_E47=1; TPCC_TPCC_ECRH_E48=1;TPCC_TPCC_ECRH_E49=1;TPCC_TPCC_ECRH_E50=1;TPCC_TPCC_ECRH_E51=1; TPCC_TPCC_ECRH_E52=1;TPCC_TPCC_ECRH_E53=1;TPCC_TPCC_ECRH_E54=1;TPCC_TPCC_ECRH_E55=1; TPCC_TPCC_ECRH_E56=1;TPCC_TPCC_ECRH_E57=1;TPCC_TPCC_ECRH_E58=1;TPCC_TPCC_ECRH_E59=1; TPCC_TPCC_ECRH_E60=1;TPCC_TPCC_ECRH_E61=1;TPCC_TPCC_ECRH_E62=1;TPCC_TPCC_ECRH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    dmaStatus;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get DMA Channel 0 Status 
         CSL_edma3GetDMAChannelEvent(hModule, 0, &amp;dmaStatus);
         if (dmaStatus == TRUE)
         {
             // DMA Channel 0 is active... 
             ...
             // Clear DMA Channel 0.
             CSL_edma3ClearDMAChannelEvent (hModule, CSL_EDMA3_REGION_GLOBAL, 0);
         }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga22b02edfc6f108291b61b89c448a699f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearDMAChannelSecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearDMAChannelSecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API clears the DMA Secondary Event for a specific DMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     DMA Channel for which the secondary event is to be cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_SECR_SECR0=1;TPCC_TPCC_SECR_SECR1=1;TPCC_TPCC_SECR_SECR2=1; TPCC_TPCC_SECR_SECR3=1;TPCC_TPCC_SECR_SECR4=1;TPCC_TPCC_SECR_SECR5=1; TPCC_TPCC_SECR_SECR6=1;TPCC_TPCC_SECR_SECR7=1;TPCC_TPCC_SECR_SECR8=1; TPCC_TPCC_SECR_SECR9=1;TPCC_TPCC_SECR_SECR10=1;TPCC_TPCC_SECR_SECR11=1; TPCC_TPCC_SECR_SECR12=1;TPCC_TPCC_SECR_SECR13=1;TPCC_TPCC_SECR_SECR14=1; TPCC_TPCC_SECR_SECR15=1;TPCC_TPCC_SECR_SECR16=1;TPCC_TPCC_SECR_SECR17=1; TPCC_TPCC_SECR_SECR18=1;TPCC_TPCC_SECR_SECR19=1;TPCC_TPCC_SECR_SECR20=1; TPCC_TPCC_SECR_SECR21=1;TPCC_TPCC_SECR_SECR22=1;TPCC_TPCC_SECR_SECR23=1; TPCC_TPCC_SECR_SECR24=1;TPCC_TPCC_SECR_SECR25=1;TPCC_TPCC_SECR_SECR26=1; TPCC_TPCC_SECR_SECR27=1;TPCC_TPCC_SECR_SECR28=1;TPCC_TPCC_SECR_SECR29=1; TPCC_TPCC_SECR_SECR30=1;TPCC_TPCC_SECR_SECR31=1; <br />
 TPCC_TPCC_SECRH_SECR32=1;TPCC_TPCC_SECRH_SECR33=1;TPCC_TPCC_SECRH_SECR34=1; TPCC_TPCC_SECRH_SECR35=1;TPCC_TPCC_SECRH_SECR36=1;TPCC_TPCC_SECRH_SECR37=1; TPCC_TPCC_SECRH_SECR38=1;TPCC_TPCC_SECRH_SECR39=1;TPCC_TPCC_SECRH_SECR40=1; TPCC_TPCC_SECRH_SECR41=1;TPCC_TPCC_SECRH_SECR42=1;TPCC_TPCC_SECRH_SECR43=1; TPCC_TPCC_SECRH_SECR44=1;TPCC_TPCC_SECRH_SECR45=1;TPCC_TPCC_SECRH_SECR46=1; TPCC_TPCC_SECRH_SECR47=1;TPCC_TPCC_SECRH_SECR48=1;TPCC_TPCC_SECRH_SECR49=1; TPCC_TPCC_SECRH_SECR50=1;TPCC_TPCC_SECRH_SECR51=1;TPCC_TPCC_SECRH_SECR52=1; TPCC_TPCC_SECRH_SECR53=1;TPCC_TPCC_SECRH_SECR54=1;TPCC_TPCC_SECRH_SECR55=1; TPCC_TPCC_SECRH_SECR56=1;TPCC_TPCC_SECRH_SECR57=1;TPCC_TPCC_SECRH_SECR58=1; TPCC_TPCC_SECRH_SECR59=1;TPCC_TPCC_SECRH_SECR60=1;TPCC_TPCC_SECRH_SECR61=1; TPCC_TPCC_SECRH_SECR62=1;TPCC_TPCC_SECRH_SECR63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         Uint32                  qdmaSecEvent;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Clear the DMA Secondary Event for DMA channel 1
         CSL_edma3ClearDMAChannelSecondaryEvents(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4772e6598f65bac04d0c59ca7a1b3612"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearDMAMissedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearDMAMissedEvent</b> </p>
<p><b>Description</b> <br />
 The API clears the missed event for the specific DMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     dmaChannel      DMA Channel for which the event is cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Clears all the missed events</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EMCR_EMCR0;TPCC_TPCC_EMCR_EMCR1;TPCC_TPCC_EMCR_EMCR2; TPCC_TPCC_EMCR_EMCR3;TPCC_TPCC_EMCR_EMCR4;TPCC_TPCC_EMCR_EMCR5; TPCC_TPCC_EMCR_EMCR6;TPCC_TPCC_EMCR_EMCR7;TPCC_TPCC_EMCR_EMCR8; TPCC_TPCC_EMCR_EMCR9;TPCC_TPCC_EMCR_EMCR10;TPCC_TPCC_EMCR_EMCR11; TPCC_TPCC_EMCR_EMCR12;TPCC_TPCC_EMCR_EMCR13;TPCC_TPCC_EMCR_EMCR14; TPCC_TPCC_EMCR_EMCR15;TPCC_TPCC_EMCR_EMCR16;TPCC_TPCC_EMCR_EMCR17; TPCC_TPCC_EMCR_EMCR18;TPCC_TPCC_EMCR_EMCR19;TPCC_TPCC_EMCR_EMCR20; TPCC_TPCC_EMCR_EMCR21;TPCC_TPCC_EMCR_EMCR22;TPCC_TPCC_EMCR_EMCR23; TPCC_TPCC_EMCR_EMCR24;TPCC_TPCC_EMCR_EMCR25;TPCC_TPCC_EMCR_EMCR26; TPCC_TPCC_EMCR_EMCR27;TPCC_TPCC_EMCR_EMCR28;TPCC_TPCC_EMCR_EMCR29; TPCC_TPCC_EMCR_EMCR30;TPCC_TPCC_EMCR_EMCR31; TPCC_TPCC_EMCRH_EMCR32;TPCC_TPCC_EMCRH_EMCR33;TPCC_TPCC_EMCRH_EMCR34 TPCC_TPCC_EMCRH_EMCR35;TPCC_TPCC_EMCRH_EMCR36;TPCC_TPCC_EMCRH_EMCR37 TPCC_TPCC_EMCRH_EMCR38;TPCC_TPCC_EMCRH_EMCR39;TPCC_TPCC_EMCRH_EMCR40 TPCC_TPCC_EMCRH_EMCR41;TPCC_TPCC_EMCRH_EMCR42;TPCC_TPCC_EMCRH_EMCR43 TPCC_TPCC_EMCRH_EMCR44;TPCC_TPCC_EMCRH_EMCR45;TPCC_TPCC_EMCRH_EMCR46 TPCC_TPCC_EMCRH_EMCR47;TPCC_TPCC_EMCRH_EMCR48;TPCC_TPCC_EMCRH_EMCR49 TPCC_TPCC_EMCRH_EMCR50;TPCC_TPCC_EMCRH_EMCR51;TPCC_TPCC_EMCRH_EMCR52 TPCC_TPCC_EMCRH_EMCR53;TPCC_TPCC_EMCRH_EMCR54;TPCC_TPCC_EMCRH_EMCR55 TPCC_TPCC_EMCRH_EMCR56;TPCC_TPCC_EMCRH_EMCR57;TPCC_TPCC_EMCRH_EMCR58 TPCC_TPCC_EMCRH_EMCR59;TPCC_TPCC_EMCRH_EMCR60;TPCC_TPCC_EMCRH_EMCR61 TPCC_TPCC_EMCRH_EMCR62;TPCC_TPCC_EMCRH_EMCR63;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           missedLo, missedHi, missedQdma;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...            
         // Clear missed DMA 1 channel event.
         CSL_edma3ClearDMAMissedEvent(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7980f171ac5f5cb2f7cd168944a9b88d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearDMASecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>secEventLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>secEventHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearDMASecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API clears the DMA secondary events</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     secEventLo      Lower order 32 bits of secondary events to be cleared
     secEventHi      Higher order 32 bits of secondary events to be cleared</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_SECR,TPCC_TPCC_SECRH</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           secEventLo;
         CSL_BitMask32           secEventHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Get the DMA Secondary Events.
         CSL_edma3GetDMASecondaryEvents(hModule, &amp;secEventLo, &amp;secEventHi);            
         ...
         // Clear the DMA Secondary Events
         CSL_edma3ClearDMASecondaryEvents(hModule, secEventLo, secEventHi);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaffcdd5be47e621d5dec4581e1f7166d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearHiPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearHiPendingInterrupts</b> </p>
<p><b>Description</b> <br />
 This API clears the High pending interrupts using the interrupt bitmasks provided</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)
     intrHi            Interrupt 32-63 (BitMask32) to be cleared</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_ICRH</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get all the pending interrupts for the global region. 
         CSL_edma3GetHiPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, &amp;edmaIntrHi);
         ...
         // Clear the pending interrupts for the global region.
         CSL_edma3ClearHiPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, edmaIntrHi);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8649dce41be1f3eb9ab730f0b2f6dad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearLoPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearLoPendingInterrupts</b> </p>
<p><b>Description</b> <br />
 This API clears the low pending interrupts using the interrupt bitmasks provided</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)
     intrLo            Interrupt 0-31 (BitMask32) to be cleared        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_ICR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrLo;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get all the pending interrupts for the global region. 
         CSL_edma3GetLoPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, &amp;edmaIntrLo);
         ...
         // Clear the pending interrupts for the global region.
         CSL_edma3ClearLoPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, edmaIntrLo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga315b2794bb181cc094ce5b01006c3dfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearQDMAChannelSecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearQDMAChannelSecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API clears the QDMA Secondary Event for a specific QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel for which the secondary event is to be cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QSECR_QSECR0=1;TPCC_TPCC_QSECR_QSECR1=1;TPCC_TPCC_QSECR_QSECR2=1; TPCC_TPCC_QSECR_QSECR3=1;TPCC_TPCC_QSECR_QSECR4=1;TPCC_TPCC_QSECR_QSECR5=1; TPCC_TPCC_QSECR_QSECR6=1;TPCC_TPCC_QSECR_QSECR7=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         Uint32                  qdmaSecEvent;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Clear the QDMA Secondary Event for QDMA channel 1
         CSL_edma3ClearQDMAChannelSecondaryEvents(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6219a158b58e7defea51a7f3f53f5855"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearQDMAMissedEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearQDMAMissedEvent</b> </p>
<p><b>Description</b> <br />
 The API clears the missed event for the specific QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel for which the event is cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Clears all the missed events</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QEMCR_QEMCR0;TPCC_TPCC_QEMCR_QEMCR1;TPCC_TPCC_QEMCR_QEMCR2; TPCC_TPCC_QEMCR_QEMCR3;TPCC_TPCC_QEMCR_QEMCR4;TPCC_TPCC_QEMCR_QEMCR5; TPCC_TPCC_QEMCR_QEMCR6;TPCC_TPCC_QEMCR_QEMCR7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           missedLo, missedHi, missedQdma;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...            
         // Clear missed QDMA Channel 1 event.
         CSL_edma3ClearQDMAMissedEvent(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8890ca36df2fd1b2d296ee380812d1ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ClearQDMASecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>qdmaSecEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ClearQDMASecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API clears the QDMA Secondary Event.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaSecEvent    QDMA Secondary Event to be cleared.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QSECR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         Uint32                  qdmaSecEvent;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get the QDMA Secondary Event
         CSL_edma3GetQDMASecondaryEvents(hModule, &amp;qdmaSecEvent);
         ...            
         // Clear the QDMA Secondary Event
         CSL_edma3ClearQDMASecondaryEvents(hModule, qdmaSecEvent);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9068b8c6350a7315324b839903a2f8e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3Close.c</b> </p>
<p><b>Description</b> <br />
 This is a module level close require to invalidate the module handle. The module handle must not be used after this API call.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Handle to the Edma Instance</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> have to be called in that order successfully before calling this function.</p>
<p><b> Post Condition </b> <br />
 The edma CSL APIs can not be called until the edma CSL is reopened again using <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle     hModule;
         CSL_Edma3Obj        edmaObj;
         CSL_Status          status;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);
         ...
         // Close the Module.         
         CSL_edma3Close(hModule);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga98b74b51ed885b086a933b1f971aecd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3DMAChannelDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3DMAChannelDisable</b> </p>
<p><b>Description</b> <br />
 This API disables the specified DMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadow or Global)
     dmaChannel      DMA Channel to be disabled. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EECR_E0=1;TPCC_TPCC_EECR_E1=1;TPCC_TPCC_EECR_E2=1; TPCC_TPCC_EECR_E3=1;TPCC_TPCC_EECR_E4=1;TPCC_TPCC_EECR_E5=1; TPCC_TPCC_EECR_E6=1;TPCC_TPCC_EECR_E7=1;TPCC_TPCC_EECR_E8=1; TPCC_TPCC_EECR_E9=1;TPCC_TPCC_EECR_E10=1;TPCC_TPCC_EECR_E11=1; TPCC_TPCC_EECR_E12=1;TPCC_TPCC_EECR_E13=1;TPCC_TPCC_EECR_E14=1; TPCC_TPCC_EECR_E15=1;TPCC_TPCC_EECR_E16=1;TPCC_TPCC_EECR_E17=1; TPCC_TPCC_EECR_E18=1;TPCC_TPCC_EECR_E19=1;TPCC_TPCC_EECR_E20=1; TPCC_TPCC_EECR_E21=1;TPCC_TPCC_EECR_E22=1;TPCC_TPCC_EECR_E23=1; TPCC_TPCC_EECR_E24=1;TPCC_TPCC_EECR_E25=1;TPCC_TPCC_EECR_E26=1; TPCC_TPCC_EECR_E27=1;TPCC_TPCC_EECR_E28=1;TPCC_TPCC_EECR_E29=1; TPCC_TPCC_EECR_E30=1;TPCC_TPCC_EECR_E31=1; <br />
 TPCC_TPCC_EECRH_E32=1;TPCC_TPCC_EECRH_E33=1;TPCC_TPCC_EECRH_E34=1; TPCC_TPCC_EECRH_E35=1;TPCC_TPCC_EECRH_E36=1;TPCC_TPCC_EECRH_E37=1; TPCC_TPCC_EECRH_E38=1;TPCC_TPCC_EECRH_E39=1;TPCC_TPCC_EECRH_E40=1; TPCC_TPCC_EECRH_E41=1;TPCC_TPCC_EECRH_E42=1;TPCC_TPCC_EECRH_E43=1; TPCC_TPCC_EECRH_E44=1;TPCC_TPCC_EECRH_E45=1;TPCC_TPCC_EECRH_E46=1; TPCC_TPCC_EECRH_E47=1;TPCC_TPCC_EECRH_E48=1;TPCC_TPCC_EECRH_E49=1; TPCC_TPCC_EECRH_E50=1;TPCC_TPCC_EECRH_E51=1;TPCC_TPCC_EECRH_E52=1; TPCC_TPCC_EECRH_E53=1;TPCC_TPCC_EECRH_E54=1;TPCC_TPCC_EECRH_E55=1; TPCC_TPCC_EECRH_E56=1;TPCC_TPCC_EECRH_E57=1;TPCC_TPCC_EECRH_E58=1; TPCC_TPCC_EECRH_E59=1;TPCC_TPCC_EECRH_E60=1;TPCC_TPCC_EECRH_E61=1; TPCC_TPCC_EECRH_E62=1;TPCC_TPCC_EECRH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
       
         // Disables DMA Channel 0
         CSL_edma3DMAChannelDisable(hModule, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa54eff8bdd357d4cc1827b15bce2d317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3DMAChannelEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3DMAChannelEnable</b> </p>
<p><b>Description</b> <br />
 This API enables the specified DMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadow or Global)
     dmaChannel      DMA Channel to be enabled. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EESR_E0=1;TPCC_TPCC_EESR_E1=1;TPCC_TPCC_EESR_E2=1; TPCC_TPCC_EESR_E3=1;TPCC_TPCC_EESR_E4=1;TPCC_TPCC_EESR_E5=1; TPCC_TPCC_EESR_E6=1;TPCC_TPCC_EESR_E7=1;TPCC_TPCC_EESR_E8=1; TPCC_TPCC_EESR_E9=1;TPCC_TPCC_EESR_E10=1;TPCC_TPCC_EESR_E11=1; TPCC_TPCC_EESR_E12=1;TPCC_TPCC_EESR_E13=1;TPCC_TPCC_EESR_E14=1; TPCC_TPCC_EESR_E15=1;TPCC_TPCC_EESR_E16=1;TPCC_TPCC_EESR_E17=1; TPCC_TPCC_EESR_E18=1;TPCC_TPCC_EESR_E19=1;TPCC_TPCC_EESR_E20=1; TPCC_TPCC_EESR_E21=1;TPCC_TPCC_EESR_E22=1;TPCC_TPCC_EESR_E23=1; TPCC_TPCC_EESR_E24=1;TPCC_TPCC_EESR_E25=1;TPCC_TPCC_EESR_E26=1; TPCC_TPCC_EESR_E27=1;TPCC_TPCC_EESR_E28=1;TPCC_TPCC_EESR_E29=1; TPCC_TPCC_EESR_E30=1;TPCC_TPCC_EESR_E31=1; <br />
 TPCC_TPCC_EESRH_E32=1;TPCC_TPCC_EESRH_E33=1;TPCC_TPCC_EESRH_E34=1; TPCC_TPCC_EESRH_E35=1;TPCC_TPCC_EESRH_E36=1;TPCC_TPCC_EESRH_E37=1; TPCC_TPCC_EESRH_E38=1;TPCC_TPCC_EESRH_E39=1;TPCC_TPCC_EESRH_E40=1; TPCC_TPCC_EESRH_E41=1;TPCC_TPCC_EESRH_E42=1;TPCC_TPCC_EESRH_E43=1; TPCC_TPCC_EESRH_E44=1;TPCC_TPCC_EESRH_E45=1;TPCC_TPCC_EESRH_E46=1; TPCC_TPCC_EESRH_E47=1;TPCC_TPCC_EESRH_E48=1;TPCC_TPCC_EESRH_E49=1; TPCC_TPCC_EESRH_E50=1;TPCC_TPCC_EESRH_E51=1;TPCC_TPCC_EESRH_E52=1; TPCC_TPCC_EESRH_E53=1;TPCC_TPCC_EESRH_E54=1;TPCC_TPCC_EESRH_E55=1; TPCC_TPCC_EESRH_E56=1;TPCC_TPCC_EESRH_E57=1;TPCC_TPCC_EESRH_E58=1; TPCC_TPCC_EESRH_E59=1;TPCC_TPCC_EESRH_E60=1;TPCC_TPCC_EESRH_E61=1; TPCC_TPCC_EESRH_E62=1;TPCC_TPCC_EESRH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
       
         // Enables DMA Channel 0 for the global region.
         CSL_edma3DMAChannelEnable(hModule, CSL_EDMA3_REGION_GLOBAL, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga070e9c2a86bd18ce0850dfc45e7d5551"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3DmaRegionAccessDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>edmaRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>drae</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>draeh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3DmaRegionAccessDisable</b> </p>
<p><b>Description</b> <br />
 This API disables read/write access to the shadow regions for the specific DMA channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     edmaRegion        Shadow Region 
     access            Region bits to be programmed
     drae              Bitmask to be disabled in DRAE
     draeh             Bitmask to be disabled in DRAEH</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DRA_DRAE_E0=0;TPCC_TPCC_DRA_DRAE_E1=0;TPCC_TPCC_DRA_DRAE_E2=0; TPCC_TPCC_DRA_DRAE_E3=0;TPCC_TPCC_DRA_DRAE_E4=0;TPCC_TPCC_DRA_DRAE_E5=0; TPCC_TPCC_DRA_DRAE_E6=0;TPCC_TPCC_DRA_DRAE_E7=0;TPCC_TPCC_DRA_DRAE_E8=0; TPCC_TPCC_DRA_DRAE_E9=0;TPCC_TPCC_DRA_DRAE_E10=0;TPCC_TPCC_DRA_DRAE_E11=0; TPCC_TPCC_DRA_DRAE_E12=0;TPCC_TPCC_DRA_DRAE_E13=0;TPCC_TPCC_DRA_DRAE_E14=0; TPCC_TPCC_DRA_DRAE_E15=0;TPCC_TPCC_DRA_DRAE_E16=0;TPCC_TPCC_DRA_DRAE_E17=0; TPCC_TPCC_DRA_DRAE_E18=0;TPCC_TPCC_DRA_DRAE_E19=0;TPCC_TPCC_DRA_DRAE_E20=0; TPCC_TPCC_DRA_DRAE_E21=0;TPCC_TPCC_DRA_DRAE_E22=0;TPCC_TPCC_DRA_DRAE_E23=0; TPCC_TPCC_DRA_DRAE_E24=0;TPCC_TPCC_DRA_DRAE_E25=0;TPCC_TPCC_DRA_DRAE_E26=0; TPCC_TPCC_DRA_DRAE_E27=0;TPCC_TPCC_DRA_DRAE_E28=0;TPCC_TPCC_DRA_DRAE_E29=0; TPCC_TPCC_DRA_DRAE_E30=0;TPCC_TPCC_DRA_DRAE_E31=0; <br />
 TPCC_TPCC_DRA_DRAEH_E32=0;TPCC_TPCC_DRA_DRAEH_E33=0;TPCC_TPCC_DRA_DRAEH_E34=0; TPCC_TPCC_DRA_DRAEH_E35=0;TPCC_TPCC_DRA_DRAEH_E36=0;TPCC_TPCC_DRA_DRAEH_E37=0; TPCC_TPCC_DRA_DRAEH_E38=0;TPCC_TPCC_DRA_DRAEH_E39=0;TPCC_TPCC_DRA_DRAEH_E40=0; TPCC_TPCC_DRA_DRAEH_E41=0;TPCC_TPCC_DRA_DRAEH_E42=0;TPCC_TPCC_DRA_DRAEH_E43=0; TPCC_TPCC_DRA_DRAEH_E44=0;TPCC_TPCC_DRA_DRAEH_E45=0;TPCC_TPCC_DRA_DRAEH_E46=0; TPCC_TPCC_DRA_DRAEH_E47=0;TPCC_TPCC_DRA_DRAEH_E48=0;TPCC_TPCC_DRA_DRAEH_E49=0; TPCC_TPCC_DRA_DRAEH_E50=0;TPCC_TPCC_DRA_DRAEH_E51=0;TPCC_TPCC_DRA_DRAEH_E52=0; TPCC_TPCC_DRA_DRAEH_E53=0;TPCC_TPCC_DRA_DRAEH_E54=0;TPCC_TPCC_DRA_DRAEH_E55=0; TPCC_TPCC_DRA_DRAEH_E56=0;TPCC_TPCC_DRA_DRAEH_E57=0;TPCC_TPCC_DRA_DRAEH_E58=0; TPCC_TPCC_DRA_DRAEH_E59=0;TPCC_TPCC_DRA_DRAEH_E60=0;TPCC_TPCC_DRA_DRAEH_E61=0; TPCC_TPCC_DRA_DRAEH_E62=0;TPCC_TPCC_DRA_DRAEH_E63=0;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Disable read/write access in Region 0 for DMA Channel 0 to 7
         CSL_edma3DmaRegionAccessDisable(hModule, 0, 0x000000FF, 0x0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0fcbc17db5594f430851db0bdd785e03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3DmaRegionAccessEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>edmaRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>drae</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>draeh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3DmaRegionAccessEnable</b> </p>
<p><b>Description</b> <br />
 This API enables read/write access to the shadow regions for the specific DMA channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     edmaRegion        Shadow Region 
     access            Region bits to be programmed
     drae              Bitmask to be enabled in DRAE
     draeh             Bitmask to be enabled in DRAEH</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DRA_DRAE_E0=1;TPCC_TPCC_DRA_DRAE_E1=1;TPCC_TPCC_DRA_DRAE_E2=1; TPCC_TPCC_DRA_DRAE_E3=1;TPCC_TPCC_DRA_DRAE_E4=1;TPCC_TPCC_DRA_DRAE_E5=1; TPCC_TPCC_DRA_DRAE_E6=1;TPCC_TPCC_DRA_DRAE_E7=1;TPCC_TPCC_DRA_DRAE_E8=1; TPCC_TPCC_DRA_DRAE_E9=1;TPCC_TPCC_DRA_DRAE_E10=1;TPCC_TPCC_DRA_DRAE_E11=1; TPCC_TPCC_DRA_DRAE_E12=1;TPCC_TPCC_DRA_DRAE_E13=1;TPCC_TPCC_DRA_DRAE_E14=1; TPCC_TPCC_DRA_DRAE_E15=1;TPCC_TPCC_DRA_DRAE_E16=1;TPCC_TPCC_DRA_DRAE_E17=1; TPCC_TPCC_DRA_DRAE_E18=1;TPCC_TPCC_DRA_DRAE_E19=1;TPCC_TPCC_DRA_DRAE_E20=1; TPCC_TPCC_DRA_DRAE_E21=1;TPCC_TPCC_DRA_DRAE_E22=1;TPCC_TPCC_DRA_DRAE_E23=1; TPCC_TPCC_DRA_DRAE_E24=1;TPCC_TPCC_DRA_DRAE_E25=1;TPCC_TPCC_DRA_DRAE_E26=1; TPCC_TPCC_DRA_DRAE_E27=1;TPCC_TPCC_DRA_DRAE_E28=1;TPCC_TPCC_DRA_DRAE_E29=1; TPCC_TPCC_DRA_DRAE_E30=1;TPCC_TPCC_DRA_DRAE_E31=1; <br />
 TPCC_TPCC_DRA_DRAEH_E32=1;TPCC_TPCC_DRA_DRAEH_E33=1;TPCC_TPCC_DRA_DRAEH_E34=1; TPCC_TPCC_DRA_DRAEH_E35=1;TPCC_TPCC_DRA_DRAEH_E36=1;TPCC_TPCC_DRA_DRAEH_E37=1; TPCC_TPCC_DRA_DRAEH_E38=1;TPCC_TPCC_DRA_DRAEH_E39=1;TPCC_TPCC_DRA_DRAEH_E40=1; TPCC_TPCC_DRA_DRAEH_E41=1;TPCC_TPCC_DRA_DRAEH_E42=1;TPCC_TPCC_DRA_DRAEH_E43=1; TPCC_TPCC_DRA_DRAEH_E44=1;TPCC_TPCC_DRA_DRAEH_E45=1;TPCC_TPCC_DRA_DRAEH_E46=1; TPCC_TPCC_DRA_DRAEH_E47=1;TPCC_TPCC_DRA_DRAEH_E48=1;TPCC_TPCC_DRA_DRAEH_E49=1; TPCC_TPCC_DRA_DRAEH_E50=1;TPCC_TPCC_DRA_DRAEH_E51=1;TPCC_TPCC_DRA_DRAEH_E52=1; TPCC_TPCC_DRA_DRAEH_E53=1;TPCC_TPCC_DRA_DRAEH_E54=1;TPCC_TPCC_DRA_DRAEH_E55=1; TPCC_TPCC_DRA_DRAEH_E56=1;TPCC_TPCC_DRA_DRAEH_E57=1;TPCC_TPCC_DRA_DRAEH_E58=1; TPCC_TPCC_DRA_DRAEH_E59=1;TPCC_TPCC_DRA_DRAEH_E60=1;TPCC_TPCC_DRA_DRAEH_E61=1; TPCC_TPCC_DRA_DRAEH_E62=1;TPCC_TPCC_DRA_DRAEH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Enable read/write access in Region 0 for DMA Channel 0 to 7
         CSL_edma3DmaRegionAccessEnable(hModule, 0, 0x000000FF, 0x0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4110e49f4500afc5314104bb3c4d5673"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3ErrorEval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ErrorEval</b> </p>
<p><b>Description</b> <br />
 This API enables enables evaluation of errros for the specified view/shadow region.Sets EVAL bit of the EEVAL register in the Global register space</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EEVAL_EVAL=1</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Set the Error Interrupt Evaluation 
         CSL_edma3ErrorEval(hModule);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gada8f408030d583005808e473ffbffecc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3EventQueueThresholdSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3EventQueueThresholdSet</b> </p>
<p><b>Description</b> <br />
 The function configures the queue threshold.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue for which the threshold is configured                          
     threshold         Target threshold value.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QWMTHRA_Q0;TPCC_TPCC_QWMTHRA_Q1;TPCC_TPCC_QWMTHRA_Q2; TPCC_TPCC_QWMTHRA_Q3; <br />
 TPCC_TPCC_QWMTHRB_Q4;TPCC_TPCC_QWMTHRB_Q1;TPCC_TPCC_QWMTHRB_Q2; TPCC_TPCC_QWMTHRB_Q3</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Set the Queue threshold for Event Queue 0 to be 9
         CSL_edma3EventQueueThresholdSet(hModule, 0, 9);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae6bd948c76d68bde4433984ef84eedb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3EventsMissedClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>missedLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>missedHi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>missedQdma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3EventMissedClear</b> </p>
<p><b>Description</b> <br />
 Clear the Event missed errors</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     missedLo          Lower 32 of of the Event Missed register needing to 
                       be cleared (This is the same value as EMR)
     missedHi          Upper 32 of of the Event Missed register needing to 
                       be cleared (This is the same value as EMRH)
     missedQdma        Bit mask of Qdma events missed needing to be cleared</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Clears all the missed events</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_EMCR,TPCC_TPCC_EMCRH,TPCC_TPCC_QEMCR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           missedLo, missedHi, missedQdma;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...            
         // Get the missed events 
         CSL_edma3GetEventMissed(hModule, &amp;missedEdma, &amp;missedEdmaHi, &amp;missedQdma);
         ...
         // Clear the error 
         CSL_edma3EventMissedClear(hModule,missedLo, missedHi,qdmamissed);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4d54fbe4ac3a8808b4085b0785519a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetActivityStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga2ae058d6cba90191fa7e3ec7a319a52f">CSL_Edma3ActivityStat</a> *&#160;</td>
          <td class="paramname"><em>activityStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetActivityStatus</b> </p>
<p><b>Description</b> <br />
 Obtains the Channel Controller Activity Status</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     activityStat      Activity Status populated by this API.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_CCSTAT_EVTACTV,TPCC_TPCC_CCSTAT_QEVTACTV,TPCC_TPCC_CCSTAT_TRACTV, TPCC_TPCC_CCSTAT_ACTV,TPCC_TPCC_CCSTAT_COMP_ACTV</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3ActivityStat   activityStat;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get the CC activity status.
         CSL_edma3GetActivityStatus(hModule,&amp;activityStat);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaff82735cb56a5e4f20f4e0a89fbf2e3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetControllerError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga76304c2b9e36a2959a1bcaf63d84502b">CSL_Edma3CtrlErrStat</a> *&#160;</td>
          <td class="paramname"><em>ccStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetControllerError</b> </p>
<p><b>Description</b> <br />
 The function gets the status of the controller error.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     ccStat      Controller Error populated by this API </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_CCERR_QTHRXD0;TPCC_TPCC_CCERR_QTHRXD1;TPCC_TPCC_CCERR_QTHRXD2; TPCC_TPCC_CCERR_QTHRXD3;TPCC_TPCC_CCERR_QTHRXD4;TPCC_TPCC_CCERR_QTHRXD5; TPCC_TPCC_CCERR_QTHRXD6;TPCC_TPCC_CCERR_QTHRXD7, TPCC_TPCC_CCERR_TCCERR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3CtrlErrStat    ccError;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get Controller Error
         status = CSL_edma3GetControllerError(hModule,&amp;ccError);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8de736c33c9bec94590ef201ebf2ead6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_edma3GetDMAChannelToEventQueueMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetDMAChannelToEventQueueMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the mapping of the DMA Channel to the Event Queue</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     dmaChannel  DMA Channel for which the mapping is to be retreived.</pre><p><b> Return Value </b> <br />
 Event Queue to which the DMA channel is mapped to</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_DMAQNUM_E0;TPCC_TPCC_DMAQNUM_E1;TPCC_TPCC_DMAQNUM_E2; TPCC_TPCC_DMAQNUM_E3;TPCC_TPCC_DMAQNUM_E4;TPCC_TPCC_DMAQNUM_E5; TPCC_TPCC_DMAQNUM_E6;TPCC_TPCC_DMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   eventQueue;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the Event Queue mapping of DMA Channel 1
         eventQueue = CSL_edma3GetDMAChannelToEventQueueMapping(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga44779b99a16d35cc4b88944cec22514e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint16 CSL_edma3GetDMAChannelToParamBlockMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetDMAChannelToParamBlockMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the PARAM Entry ID to which a specific DMA Channel is mapped.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     dmaChannel  DMA Channel Number whose mapping is to be found.</pre><p><b> Return Value </b> <br />
 Paramater ID to which the specific DMA Channel is mapped to.</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_DCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint16                  paramId;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the mapping information for DMA channel 1.
         paramId = CSL_edma3GetDMAChannelToParamBlockMapping(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac4c6f7086fcc2f1f60d1ffa744d26b9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetDMASecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>secEventLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>secEventHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetDMASecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API gets the DMA secondary events</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     secEventLo      Lower order 32 bits of secondary events populated by the API
     secEventHi      Higher order 32 bits of secondary events populated by the API</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_SER,TPCC_TPCC_SERH</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           secEventLo;
         CSL_BitMask32           secEventHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Get the DMA Secondary Events.
         CSL_edma3GetDMASecondaryEvents(hModule, &amp;secEventLo, &amp;secEventHi);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae83e94b0bab125d21048a68935123e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetEventMissed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>missedLo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>missedHi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>missedQdma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetEventMissed</b> </p>
<p><b>Description</b> <br />
 Queries all the events missed.Since there may be upto 64 EDMA channels + upto 8 QDMA channels,this points to an array of 3, 32 bit elements.Gets the status of the missed events.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     missedLo          missed [0] - holds status from EMR
     missedHi          missed [1] - holds status from EMRH
     missedQdma        missed [2] - holds status from QEMR</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_EMR,TPCC_TPCC_EMRH,TPCC_TPCC_QEMR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           missedLo, missedHi, missedQdma;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get the missed events 
         CSL_edma3GetEventMissed(hModule, &amp;missedEdma, &amp;missedEdmaHi, &amp;missedQdma);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga404bacac2a4ea2fbef703034d003800e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_edma3GetEventQueuePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetEventQueuePriority</b> </p>
<p><b>Description</b> <br />
 The function gets the priority of the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle        
     eventQueue  Event Queue whose priority is to be retrieved.</pre><p><b> Return Value </b> <br />
 Priority to which the Event Queue is mapped to.</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Event Queue is configured to the specific priority.</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QUEPRI_PRIQ0;TPCC_TPCC_QUEPRI_PRIQ1;TPCC_TPCC_QUEPRI_PRIQ2; TPCC_TPCC_QUEPRI_PRIQ3;TPCC_TPCC_QUEPRI_PRIQ4;TPCC_TPCC_QUEPRI_PRIQ5; TPCC_TPCC_QUEPRI_PRIQ6;TPCC_TPCC_QUEPRI_PRIQ7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   priority;         

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the priority of Event Queue 2.
         priority = CSL_edma3GetEventQueuePriority(hModule, 2);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9eaed8e6d7f20dac45eedcb71ebd6804"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_edma3GetEventQueueToTCMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetEventQueueToTCMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the TC mapping for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle        
     eventQueue  Event Queue which for which the mapping is needed.</pre><p><b> Return Value </b> <br />
 TC Number to which the event queue is mapped to</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Event Queue is mapped to the specific TC</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QUETCMAP_TCNUMQ0;TPCC_TPCC_QUETCMAP_TCNUMQ1;TPCC_TPCC_QUETCMAP_TCNUMQ2; TPCC_TPCC_QUETCMAP_TCNUMQ3;TPCC_TPCC_QUETCMAP_TCNUMQ4;TPCC_TPCC_QUETCMAP_TCNUMQ5; TPCC_TPCC_QUETCMAP_TCNUMQ6;TPCC_TPCC_QUETCMAP_TCNUMQ7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   tcNum;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the TC mapping for Event Queue 1 
         tcNum = CSL_edma3GetEventQueueToTCMapping(hModule, 1, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga99bde63badafa04c8ec1c9024ceb9179"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetHiPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>intrHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetHiPendingInterrupts</b> </p>
<p><b>Description</b> <br />
 The API gets a bitmask of all high pending interrupts.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)
     intrHi            Status 32-63 of the interrupts       </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_IPRH</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get all the high pending interrupts for the global region.
         CSL_edma3GetHiPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, &amp;edmaIntrHi);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab4bea1c818b898dfc4b4616dabb81e1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3GetHwChannelSetupParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>paramNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetHwChannelSetupParam</b> </p>
<p><b>Description</b> <br />
 The function gets the DMA/QDMA Channel to PARAM Entry Mapping.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Channel Handle
         paramNum        Pointer to parameter entry to which the channel 
                         is mapped.</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameters passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gab4bea1c818b898dfc4b4616dabb81e1c">CSL_edma3GetHwChannelSetupParam()</a> can be invoked.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_DCHMAP_PAENTRY; <br />
 TPCC_TPCC_QCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Status                  status;
         Uint16                      paramNum;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj, 0, NULL,&amp;status);

         // Channel 0 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum    = 0;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ...               
         // Get the parameter entry number to which a channel is mapped to 
         CSL_edma3GetHwChannelSetupParam(hChannel,&amp;paramNum);            
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac65d554238f8830b58aa434c6e82a5f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3GetHwChannelSetupQue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gac24f2bf4e0f2e746622583a1e978426a">CSL_Edma3Que</a> *&#160;</td>
          <td class="paramname"><em>evtQue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetHwChannelSetupQue</b> </p>
<p><b>Description</b> <br />
 The function gets the event queue to which the specific DMA/QDMA channel is mapped.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Channel Handle 
         evtQue          Event Queue to which the DMA/QDMA channel is mapped.</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameters passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#gac65d554238f8830b58aa434c6e82a5f6">CSL_edma3GetHwChannelSetupQue()</a> can be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QDMAQNUM_E0;TPCC_TPCC_QDMAQNUM_E1;TPCC_TPCC_QDMAQNUM_E2; TPCC_TPCC_QDMAQNUM_E3;TPCC_TPCC_QDMAQNUM_E4;TPCC_TPCC_QDMAQNUM_E5; TPCC_TPCC_QDMAQNUM_E6;TPCC_TPCC_QDMAQNUM_E7; <br />
 TPCC_TPCC_DMAQNUM_E0;TPCC_TPCC_DMAQNUM_E1;TPCC_TPCC_DMAQNUM_E2; TPCC_TPCC_DMAQNUM_E3;TPCC_TPCC_DMAQNUM_E4;TPCC_TPCC_DMAQNUM_E5; TPCC_TPCC_DMAQNUM_E6;TPCC_TPCC_DMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Status                  status;
         CSL_Edma3Que                evtQue;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj, 0, NULL,&amp;status);

         // Channel 0 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum    = 0;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ...
         // Get the trigger word programmed for the channel
         CSL_edma3GetHwChannelSetupQue(hChannel, &amp;evtQue);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3daa8ec3510804d72a3cafd33986d85b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3GetHwChannelSetupTriggerWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>triggerWord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetHwChannelSetupTriggerWord</b> </p>
<p><b>Description</b> <br />
 The function gets the Trigger word for a specific QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Channel Handle (Only QDMA Channels)
         triggerWord     Pointer to Trigger word populated by this API.</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameters passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga3daa8ec3510804d72a3cafd33986d85b">CSL_edma3GetHwChannelSetupTriggerWord()</a> can be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QCHMAP0_TRWORD</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Status                  status;
         Uint8                       triggerWord;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj, 0, NULL,&amp;status);

         // Channel 0 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum    = 0;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ...
         // Get the trigger word programmed for the channel
         CSL_edma3GetHwChannelSetupTriggerWord(hChannel,&amp;triggerWord);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga545cf03fe221d662b64b87539106056f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3GetHwChannelStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gacb77d5063815d321691ee225c74bd2c7">CSL_Edma3HwChannelStatusQuery</a>&#160;</td>
          <td class="paramname"><em>myQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetHwChannelStatus</b> </p>
<p><b>Description</b> <br />
 The function is to used to get the status of entities specific to an EDMA Channel. The channel specific entity to be queried is specified in the argument.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Channel Handle
         myQuery         Query to be performed
         response        Pointer to buffer to return the data requested by
                         the query passed </pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gacb77d5063815d321691ee225c74bd2c7" title="CHANNEL Queries. ">CSL_Edma3HwChannelStatusQuery</a></dd></dl>
<p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVQUERY (The query passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before this API can be invoked.If a Shadow region is used then care of the DRAE settings must be taken</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_ER_E0;TPCC_TPCC_ER_E1;TPCC_TPCC_ER_E2;TPCC_TPCC_ER_E3; TPCC_TPCC_ER_E4;TPCC_TPCC_ER_E5;TPCC_TPCC_ER_E6;TPCC_TPCC_ER_E7; TPCC_TPCC_ER_E8;TPCC_TPCC_ER_E9;TPCC_TPCC_ER_E10;TPCC_TPCC_ER_E11; TPCC_TPCC_ER_E12;TPCC_TPCC_ER_E13;TPCC_TPCC_ER_E14;TPCC_TPCC_ER_E15; TPCC_TPCC_ER_E16;TPCC_TPCC_ER_E17;TPCC_TPCC_ER_E18;TPCC_TPCC_ER_E19; TPCC_TPCC_ER_E20;TPCC_TPCC_ER_E21;TPCC_TPCC_ER_E22;TPCC_TPCC_ER_E23; TPCC_TPCC_ER_E24;TPCC_TPCC_ER_E25;TPCC_TPCC_ER_E26;TPCC_TPCC_ER_E27; TPCC_TPCC_ER_E28;TPCC_TPCC_ER_E29;TPCC_TPCC_ER_E30;TPCC_TPCC_ER_E31; <br />
 TPCC_TPCC_ERH_E32;TPCC_TPCC_ERH_E33;TPCC_TPCC_ERH_E34;TPCC_TPCC_ERH_E35; TPCC_TPCC_ERH_E36;TPCC_TPCC_ERH_E37;TPCC_TPCC_ERH_E38;TPCC_TPCC_ERH_E39; TPCC_TPCC_ERH_E40;TPCC_TPCC_ERH_E41;TPCC_TPCC_ERH_E42;TPCC_TPCC_ERH_E43; TPCC_TPCC_ERH_E44;TPCC_TPCC_ERH_E45;TPCC_TPCC_ERH_E46;TPCC_TPCC_ERH_E47; TPCC_TPCC_ERH_E48;TPCC_TPCC_ERH_E49;TPCC_TPCC_ERH_E50;TPCC_TPCC_ERH_E51; TPCC_TPCC_ERH_E52;TPCC_TPCC_ERH_E53;TPCC_TPCC_ERH_E54;TPCC_TPCC_ERH_E55; TPCC_TPCC_ERH_E56;TPCC_TPCC_ERH_E57;TPCC_TPCC_ERH_E58;TPCC_TPCC_ERH_E59; TPCC_TPCC_ERH_E60;TPCC_TPCC_ERH_E61;TPCC_TPCC_ERH_E62;TPCC_TPCC_ERH_E63; <br />
 TPCC_TPCC_QER_QER0;TPCC_TPCC_QER_QER1;TPCC_TPCC_QER_QER2;TPCC_TPCC_QER_QER3; TPCC_TPCC_QER_QER4;TPCC_TPCC_QER_QER5;TPCC_TPCC_QER_QER6;TPCC_TPCC_QER_QER7; <br />
 TPCC_TPCC_EMR_EMR0;TPCC_TPCC_EMR_EMR1;TPCC_TPCC_EMR_EMR2; TPCC_TPCC_EMR_EMR3;TPCC_TPCC_EMR_EMR4;TPCC_TPCC_EMR_EMR5; TPCC_TPCC_EMR_EMR6;TPCC_TPCC_EMR_EMR7;TPCC_TPCC_EMR_EMR8; TPCC_TPCC_EMR_EMR9;TPCC_TPCC_EMR_EMR10;TPCC_TPCC_EMR_EMR11; TPCC_TPCC_EMR_EMR12;TPCC_TPCC_EMR_EMR13;TPCC_TPCC_EMR_EMR14; TPCC_TPCC_EMR_EMR15;TPCC_TPCC_EMR_EMR16;TPCC_TPCC_EMR_EMR17; TPCC_TPCC_EMR_EMR18;TPCC_TPCC_EMR_EMR19;TPCC_TPCC_EMR_EMR20; TPCC_TPCC_EMR_EMR21;TPCC_TPCC_EMR_EMR22;TPCC_TPCC_EMR_EMR23; TPCC_TPCC_EMR_EMR24;TPCC_TPCC_EMR_EMR25;TPCC_TPCC_EMR_EMR26; TPCC_TPCC_EMR_EMR27;TPCC_TPCC_EMR_EMR28;TPCC_TPCC_EMR_EMR29; TPCC_TPCC_EMR_EMR30;TPCC_TPCC_EMR_EMR31; <br />
 TPCC_TPCC_EMRH_EMR32;TPCC_TPCC_EMRH_EMR33;TPCC_TPCC_EMRH_EMR34; TPCC_TPCC_EMRH_EMR35;TPCC_TPCC_EMRH_EMR36;TPCC_TPCC_EMRH_EMR37; TPCC_TPCC_EMRH_EMR38;TPCC_TPCC_EMRH_EMR39;TPCC_TPCC_EMRH_EMR40; TPCC_TPCC_EMRH_EMR41;TPCC_TPCC_EMRH_EMR42;TPCC_TPCC_EMRH_EMR43; TPCC_TPCC_EMRH_EMR44;TPCC_TPCC_EMRH_EMR45;TPCC_TPCC_EMRH_EMR46; TPCC_TPCC_EMRH_EMR47;TPCC_TPCC_EMRH_EMR48;TPCC_TPCC_EMRH_EMR49; TPCC_TPCC_EMRH_EMR50;TPCC_TPCC_EMRH_EMR51;TPCC_TPCC_EMRH_EMR52; TPCC_TPCC_EMRH_EMR53;TPCC_TPCC_EMRH_EMR54;TPCC_TPCC_EMRH_EMR55; TPCC_TPCC_EMRH_EMR56;TPCC_TPCC_EMRH_EMR57;TPCC_TPCC_EMRH_EMR58; TPCC_TPCC_EMRH_EMR59;TPCC_TPCC_EMRH_EMR60;TPCC_TPCC_EMRH_EMR61; TPCC_TPCC_EMRH_EMR62;TPCC_TPCC_EMRH_EMR63, <br />
 TPCC_TPCC_SER_SER0;TPCC_TPCC_SER_SER1;TPCC_TPCC_SER_SER2; TPCC_TPCC_SER_SER3;TPCC_TPCC_SER_SER4;TPCC_TPCC_SER_SER5; TPCC_TPCC_SER_SER6;TPCC_TPCC_SER_SER7;TPCC_TPCC_SER_SER8; TPCC_TPCC_SER_SER9;TPCC_TPCC_SER_SER10;TPCC_TPCC_SER_SER11; TPCC_TPCC_SER_SER12;TPCC_TPCC_SER_SER13;TPCC_TPCC_SER_SER14; TPCC_TPCC_SER_SER15;TPCC_TPCC_SER_SER16;TPCC_TPCC_SER_SER17; TPCC_TPCC_SER_SER18;TPCC_TPCC_SER_SER19;TPCC_TPCC_SER_SER20; TPCC_TPCC_SER_SER21;TPCC_TPCC_SER_SER22;TPCC_TPCC_SER_SER23; TPCC_TPCC_SER_SER24;TPCC_TPCC_SER_SER25;TPCC_TPCC_SER_SER26; TPCC_TPCC_SER_SER27;TPCC_TPCC_SER_SER28;TPCC_TPCC_SER_SER29; TPCC_TPCC_SER_SER30;TPCC_TPCC_SER_SER31; <br />
 TPCC_TPCC_SERH_SER32;TPCC_TPCC_SERH_SER33;TPCC_TPCC_SERH_SER34; TPCC_TPCC_SERH_SER35;TPCC_TPCC_SERH_SER36;TPCC_TPCC_SERH_SER37; TPCC_TPCC_SERH_SER38;TPCC_TPCC_SERH_SER39;TPCC_TPCC_SERH_SER40; TPCC_TPCC_SERH_SER41;TPCC_TPCC_SERH_SER42;TPCC_TPCC_SERH_SER43; TPCC_TPCC_SERH_SER44;TPCC_TPCC_SERH_SER45;TPCC_TPCC_SERH_SER46; TPCC_TPCC_SERH_SER47;TPCC_TPCC_SERH_SER48;TPCC_TPCC_SERH_SER49; TPCC_TPCC_SERH_SER50;TPCC_TPCC_SERH_SER51;TPCC_TPCC_SERH_SER52; TPCC_TPCC_SERH_SER53;TPCC_TPCC_SERH_SER54;TPCC_TPCC_SERH_SER55; TPCC_TPCC_SERH_SER56;TPCC_TPCC_SERH_SER57;TPCC_TPCC_SERH_SER58; TPCC_TPCC_SERH_SER59;TPCC_TPCC_SERH_SER60;TPCC_TPCC_SERH_SER61; TPCC_TPCC_SERH_SER62;TPCC_TPCC_SERH_SER63; <br />
 TPCC_TPCC_QEMR_QEMR0;TPCC_TPCC_QEMR_QEMR1;TPCC_TPCC_QEMR_QEMR2; TPCC_TPCC_QEMR_QEMR3;TPCC_TPCC_QEMR_QEMR4;TPCC_TPCC_QEMR_QEMR5; TPCC_TPCC_QEMR_QEMR6;TPCC_TPCC_QEMR_QEMR7, <br />
 TPCC_TPCC_QSER_QSER0;TPCC_TPCC_QSER_QSER1;TPCC_TPCC_QSER_QSER2; TPCC_TPCC_QSER_QSER3;TPCC_TPCC_QSER_QSER4;TPCC_TPCC_QSER_QSER5; TPCC_TPCC_QSER_QSER6;TPCC_TPCC_QSER_QSER7;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Status                  status;
         CSL_Edma3ChannelErr         errStat;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj, 0, NULL,&amp;status);

         // Channel 0 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum    = 0;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ...               
         // Get the Channel 0 Error Status
         CSL_edma3GetHwChannelStatus(hChannel, CSL_EDMA3_QUERY_CHANNEL_ERR, &amp;errStat);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9c76720c150fd720fe1f6804448a1201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3GetHwSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hMod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___edma3_hw_setup.html">CSL_Edma3HwSetup</a> *&#160;</td>
          <td class="paramname"><em>setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetHwSetup</b> </p>
<p><b>Description</b> <br />
 The function gets the hardware setup for all DMA/QDMA Channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hMod            EDMA Handle
         setup           Setup structure which is populated by this API.</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> must be called successfully in that order before <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9c76720c150fd720fe1f6804448a1201">CSL_edma3GetHwSetup()</a> can be called.</p>
<p><b> Post Condition </b> <br />
 The hardware setup structure is populated with the hardware setup parameters</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_DCHMAP_PAENTRY, <br />
 TPCC_TPCC_DMAQNUM_E0;TPCC_TPCC_DMAQNUM_E1;TPCC_TPCC_DMAQNUM_E2; TPCC_TPCC_DMAQNUM_E3;TPCC_TPCC_DMAQNUM_E4;TPCC_TPCC_DMAQNUM_E5; TPCC_TPCC_DMAQNUM_E6;TPCC_TPCC_DMAQNUM_E7; <br />
 TPCC_TPCC_QCHMAP_PAENTRY, <br />
 TPCC_TPCC_QCHMAP_TRWORD, <br />
 TPCC_TPCC_QDMAQNUM_E0;TPCC_TPCC_QDMAQNUM_E1;TPCC_TPCC_QDMAQNUM_E2; TPCC_TPCC_QDMAQNUM_E3;TPCC_TPCC_QDMAQNUM_E4;TPCC_TPCC_QDMAQNUM_E5; TPCC_TPCC_QDMAQNUM_E6;TPCC_TPCC_QDMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Status                  status;
         CSL_Edma3QueryInfo          info;
         CSL_Edma3HwSetup            setup;
         CSL_Edma3HwDmaChannelSetup  dmahwSetup;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get DMA Channel Setup for all channels.
         setup.dmaChaSetup  = &amp;dmahwSetup[0];
         setup.qdmaChaSetup = NULL;
         CSL_edma3GetHwSetup(hModule,&amp;setup);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7fce3d26dc2a3d38cbe0c573e197555f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3GetHwStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hMod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#ga17d8879487a291855d58778ace1600a4">CSL_Edma3HwStatusQuery</a>&#160;</td>
          <td class="paramname"><em>myQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetHwStatus</b> </p>
<p><b>Description</b> <br />
 The function gets the status of various entities in the EDMA module. The entity whose status needs to be retreived is specified in the query and the response is populated in the 'response'.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hMod            Edma module handle
         myQuery         Query to be performed
         response        Pointer to buffer to return the data requested by
                         the query passed</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#ga17d8879487a291855d58778ace1600a4" title="MODULE Level Queries. ">CSL_Edma3HwStatusQuery</a></dd></dl>
<p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid) <br />
 Error - CSL_ESYS_INVQUERY (The query is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> must be called successfully in that order before this API can be invoked.argument type that can be void* casted &amp; passed with a particular command refer to CSL_Edma3HwStatusQuery</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_CFG,TPCC_TPCC_PID; <br />
 <b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Status                  status;
         CSL_Edma3QueryInfo          info;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Query Module Info 
         CSL_edma3GetHwStatus(hModule,CSL_EDMA3_QUERY_INFO,&amp;info);  
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae61cc100cdf1d62f35787426ca2b342d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga57808bce667ae4dd7e46a849b68f83ac">CSL_Edma3QueryInfo</a> *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetInfo</b> </p>
<p><b>Description</b> <br />
 The function gets the EDMA Channel Controller Configuration Information which includes reading the peripheral revision register and configuration register.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     response    Output parameter populated with the configuration information.      </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_CFG,TPCC_TPCC_PID</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3QueryInfo      info;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get Module Info
         CSL_edma3GetInfo(hModule,&amp;info);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga743ae95c1373dc77ef523f848fb8f40d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetLoPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>intrLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetLoPendingInterrupts</b> </p>
<p><b>Description</b> <br />
 The API gets a bitmask of all low pending interrupts.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)
     intrLo            Status 0-31 of the interrupts</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_IPR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrLo;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get all low pending interrupts for the global region.
         CSL_edma3GetLoPendingInterrupts(hModule, CSL_EDMA3_REGION_GLOBAL, &amp;edmaIntrLo);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga00186ec229dde02888eaf6a9ac4b2e95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetMemoryFaultError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gac83cf570375046eeab358c62f4d34699">CSL_Edma3MemFaultStat</a> *&#160;</td>
          <td class="paramname"><em>memFault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetMemoryFaultError</b> </p>
<p><b>Description</b> <br />
 The function gets the Controllers memory fault error and the error attributes.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     memFault          The structure is populated by this API.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_MPFAR_FADDR,TPCC_TPCC_MPFSR_FID, TPCC_TPCC_MPFSR_UXE,TPCC_TPCC_MPFSR_UWE,TPCC_TPCC_MPFSR_URE, TPCC_TPCC_MPFSR_SXE,TPCC_TPCC_MPFSR_SWE,TPCC_TPCC_MPFSR_SRE, TPCC_TPCC_MPFSR_SECE</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_Edma3MemFaultStat   memFault;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get memory protection fault 
         CSL_edma3GetMemoryFaultError(hModule, &amp;memFault);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac5194b8227d01a15dfdc53354e41b755"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetMemoryProtectionAttrib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32 *&#160;</td>
          <td class="paramname"><em>mppa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetMemoryProtectionAttrib</b> </p>
<p><b>Description</b> <br />
 The function gets the memory access/protection attributes of the specific region.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region being queried.
     mppa              Memory Access/Protection Attributes populated by this API</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_MPPAG;TPCC_TPCC_MPPA</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           mppa;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get memory protection attributes for the Global Region.
         CSL_edma3GetMemoryProtectionAttrib(hModule, -1, &amp;mppa);
         ...
         // Get memory protection attributes for region 2 
         CSL_edma3GetMemoryProtectionAttrib(hModule, 2, &amp;mppa);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadc05b1eb70228c60531fbbb1c3921c3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetNumberValidEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>numValidEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetNumberValidEntries</b> </p>
<p><b>Description</b> <br />
 The function gets the Number of valid entries for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue number for which the watermark is retreived.
     numValidEntries   This is populated by the API to the number of valid entries</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSTAT_NUMVAL</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   numVal;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Get the Number of valid entries in event queue 0.
         CSL_edma3GetNumberValidEntries(hModule, 0, &amp;numVal);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9c954b177f482c066efddbbc3627ffad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga37e63265093e9e1a45c9e8b31f8608bd">CSL_Edma3ParamHandle</a> CSL_edma3GetParamHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int16&#160;</td>
          <td class="paramname"><em>paramNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetParamHandle</b> </p>
<p><b>Description</b> <br />
 The function is used to get a specific PARAM Entry handle.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Channel Handle
         paramNum        Parameter entry number
         status          Status of the function call</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before this API can be invoked</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Status              status;
         CSL_Edma3ChannelHandle  hChannel;
         CSL_Edma3ChannelAttr    chAttr;
         CSL_Edma3ParamHandle    hParamBasic;
         
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Open DMA Channel 1.
         chAttr.regionNum = CSL_EDMA3_REGION_GLOBAL;
         chAttr.chaNum    = 1;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         if ((hChannel == NULL) || (status != CSL_SOK)) 
         {
             printf ("Error: Unable to open EDMA Channel:%d\n", channelNum);
             return -1;
         }
         ...
         // Obtain a handle to PARAM Entry 0
         hParamBasic = CSL_edma3GetParamHandle(hChannel,0,&amp;status);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5ec01050a67942a6fcdd1ce8b3aed2d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint8 CSL_edma3GetQDMAChannelToEventQueueMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetQDMAChannelToEventQueueMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the mapping of the QDMA Channel to the Event Queue</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel for which the mapping is to be retreived.</pre><p><b> Return Value </b> <br />
 Event Queue to which the QDMA channel is mapped to</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QDMAQNUM_E0;TPCC_TPCC_QDMAQNUM_E1;TPCC_TPCC_QDMAQNUM_E2; TPCC_TPCC_QDMAQNUM_E3;TPCC_TPCC_QDMAQNUM_E4;TPCC_TPCC_QDMAQNUM_E5; TPCC_TPCC_QDMAQNUM_E6;TPCC_TPCC_QDMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   eventQueue;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the Event Queue mapping of QDMA Channel 1
         eventQueue = CSL_edma3GetQDMAChannelToEventQueueMapping(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaea0f5fb5768df2b80b10eaf8ea287d59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint16 CSL_edma3GetQDMAChannelToParamBlockMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetQDMAChannelToParamBlockMapping</b> </p>
<p><b>Description</b> <br />
 The function gets the PARAM Entry ID to which a specific QDMA Channel is mapped.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel Number whose mapping is to be found.</pre><p><b> Return Value </b> <br />
 Paramater ID to which the specific QDMA Channel is mapped to.</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the mapping information for QDMA channel 1.
         paramId = CSL_edma3GetQDMAChannelMap(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae746e4d3ff996ac285846189be3eae51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetQDMASecondaryEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>qdmaSecEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetQDMASecondaryEvents</b> </p>
<p><b>Description</b> <br />
 This API reads the QDMA Secondary Event.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaSecEvent    QDMA Secondary Event which is populated by this API</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSER</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         Uint32                  qdmaSecEvent;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Get the QDMA Secondary Event
         CSL_edma3GetQDMASecondaryEvents(hModule, &amp;qdmaSecEvent);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab3e8af206fafb44fe5b4233eb30bb205"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetQDMATriggerWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>trword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetQDMATriggerWord</b> </p>
<p><b>Description</b> <br />
 The function gets the trigger word of the PaRAM Entry block.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel Number which is to be configured.
     trword      Trigger Word to be retreived populated by this API.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 QDMA Channel is mapped to the specified PARAM Block.</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QCHMAP_TRWORD</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   trWord;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Get the QDMA Channel 1 Trigger Word
         trWord = CSL_edma3SetQDMATriggerWord(hModule, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7f3d8851f43a731dbbc084f5a9b2db8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetStartPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>startPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetStartPointer</b> </p>
<p><b>Description</b> <br />
 The function gets the Number of valid entries for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue number for which the watermark is retreived.
     startPtr          This is populated by the API to the start pointer</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSTAT_STRPTR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   startPtr;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Get the Number of valid entries in event queue 0.
         CSL_edma3GetStartPointer(hModule, 0, &amp;startPtr);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa3284c3d8aa6cf1228c8b834581e9f7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetThresholdExceeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>thresholdExceeded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetThresholdExceeded</b> </p>
<p><b>Description</b> <br />
 The function gets the threshold exceeded flag for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue number for which the watermark is retreived.
     thresholdExceeded This is populated by the API to the threshold exceeded flag
                       for the specific event queue.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSTAT_THRXCD</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   thresholdExceeded;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Determine if the threshold has been exceeded or not for Queue 1
         CSL_edma3GetThresholdExceeded(hModule, 1, &amp;thresholdExceeded);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga83dd2dfe416cd94e4ca3d9d0a1a6176a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3GetWaterMark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>waterMark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3GetWaterMark</b> </p>
<p><b>Description</b> <br />
 The function gets the Queue Watermark for the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     eventQueue        Event queue number for which the watermark is retreived.
     waterMark         This is populated by the API to the configured water mark </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSTAT_WM</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Uint8                   waterMark;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Get the Water Mark Queue for event queue 0
         CSL_edma3GetWaterMark(hModule, 0, &amp;waterMark);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga78a19f893f0b2239fe683b27214b9df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3HwChannelControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#ga2c97e69b09f5e164f9ab3408e5593ff4">CSL_Edma3HwChannelControlCmd</a>&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cmdArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3HwChannelControl</b> </p>
<p><b>Description</b> <br />
 This API is used to control the EDMA Channel. The function accepts a command as an argument on the type of operation which is to be performed on the specific channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hCh             Channel Handle
         cmd             Command/Action to be performed on the channel handle.
         cmdArg          Pointer to the argument specific to the command                             </pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before this API can be invoked. If a Shadow region is used then care of the DRAE settings must be taken care of.</p>
<p><b> Post Condition </b> <br />
 Edma registers are configured according to the command and the command arguements. The command determines which registers are modified.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QEESR_QEESR0=1;TPCC_TPCC_QEESR_QEESR1=1;TPCC_TPCC_QEESR_QEESR2=1; TPCC_TPCC_QEESR_QEESR3=1;TPCC_TPCC_QEESR_QEESR4=1;TPCC_TPCC_QEESR_QEESR5=1; TPCC_TPCC_QEESR_QEESR6=1;TPCC_TPCC_QEESR_QEESR7=1; <br />
 TPCC_TPCC_EESR_E0=1;TPCC_TPCC_EESR_E1=1;TPCC_TPCC_EESR_E2=1; TPCC_TPCC_EESR_E3=1;TPCC_TPCC_EESR_E4=1;TPCC_TPCC_EESR_E5=1; TPCC_TPCC_EESR_E6=1;TPCC_TPCC_EESR_E7=1;TPCC_TPCC_EESR_E8=1; TPCC_TPCC_EESR_E9=1;TPCC_TPCC_EESR_E10=1;TPCC_TPCC_EESR_E11=1; TPCC_TPCC_EESR_E12=1;TPCC_TPCC_EESR_E13=1;TPCC_TPCC_EESR_E14=1; TPCC_TPCC_EESR_E15=1;TPCC_TPCC_EESR_E16=1;TPCC_TPCC_EESR_E17=1; TPCC_TPCC_EESR_E18=1;TPCC_TPCC_EESR_E19=1;TPCC_TPCC_EESR_E20=1; TPCC_TPCC_EESR_E21=1;TPCC_TPCC_EESR_E22=1;TPCC_TPCC_EESR_E23=1; TPCC_TPCC_EESR_E24=1;TPCC_TPCC_EESR_E25=1;TPCC_TPCC_EESR_E26=1; TPCC_TPCC_EESR_E27=1;TPCC_TPCC_EESR_E28=1;TPCC_TPCC_EESR_E29=1; TPCC_TPCC_EESR_E30=1;TPCC_TPCC_EESR_E31=1; <br />
 TPCC_TPCC_EESRH_E32=1;TPCC_TPCC_EESRH_E33=1;TPCC_TPCC_EESRH_E34=1; TPCC_TPCC_EESRH_E35=1;TPCC_TPCC_EESRH_E36=1;TPCC_TPCC_EESRH_E37=1; TPCC_TPCC_EESRH_E38=1;TPCC_TPCC_EESRH_E39=1;TPCC_TPCC_EESRH_E40=1; TPCC_TPCC_EESRH_E41=1;TPCC_TPCC_EESRH_E42=1;TPCC_TPCC_EESRH_E43=1; TPCC_TPCC_EESRH_E44=1;TPCC_TPCC_EESRH_E45=1;TPCC_TPCC_EESRH_E46=1; TPCC_TPCC_EESRH_E47=1;TPCC_TPCC_EESRH_E48=1;TPCC_TPCC_EESRH_E49=1; TPCC_TPCC_EESRH_E50=1;TPCC_TPCC_EESRH_E51=1;TPCC_TPCC_EESRH_E52=1; TPCC_TPCC_EESRH_E53=1;TPCC_TPCC_EESRH_E54=1;TPCC_TPCC_EESRH_E55=1; TPCC_TPCC_EESRH_E56=1;TPCC_TPCC_EESRH_E57=1;TPCC_TPCC_EESRH_E58=1; TPCC_TPCC_EESRH_E59=1;TPCC_TPCC_EESRH_E60=1;TPCC_TPCC_EESRH_E61=1; TPCC_TPCC_EESRH_E62=1;TPCC_TPCC_EESRH_E63=1; <br />
 TPCC_TPCC_QEECR_QEECR0=1;TPCC_TPCC_QEECR_QEECR1=1;TPCC_TPCC_QEECR_QEECR2=1; TPCC_TPCC_QEECR_QEECR3=1;TPCC_TPCC_QEECR_QEECR4=1;TPCC_TPCC_QEECR_QEECR5=1; TPCC_TPCC_QEECR_QEECR6=1;TPCC_TPCC_QEECR_QEECR7=1; <br />
 TPCC_TPCC_EECR_E0=1;TPCC_TPCC_EECR_E1=1;TPCC_TPCC_EECR_E2=1; TPCC_TPCC_EECR_E3=1;TPCC_TPCC_EECR_E4=1;TPCC_TPCC_EECR_E5=1; TPCC_TPCC_EECR_E6=1;TPCC_TPCC_EECR_E7=1;TPCC_TPCC_EECR_E8=1; TPCC_TPCC_EECR_E9=1;TPCC_TPCC_EECR_E10=1;TPCC_TPCC_EECR_E11=1; TPCC_TPCC_EECR_E12=1;TPCC_TPCC_EECR_E13=1;TPCC_TPCC_EECR_E14=1; TPCC_TPCC_EECR_E15=1;TPCC_TPCC_EECR_E16=1;TPCC_TPCC_EECR_E17=1; TPCC_TPCC_EECR_E18=1;TPCC_TPCC_EECR_E19=1;TPCC_TPCC_EECR_E20=1; TPCC_TPCC_EECR_E21=1;TPCC_TPCC_EECR_E22=1;TPCC_TPCC_EECR_E23=1; TPCC_TPCC_EECR_E24=1;TPCC_TPCC_EECR_E25=1;TPCC_TPCC_EECR_E26=1; TPCC_TPCC_EECR_E27=1;TPCC_TPCC_EECR_E28=1;TPCC_TPCC_EECR_E29=1; TPCC_TPCC_EECR_E30=1;TPCC_TPCC_EECR_E31=1; <br />
 TPCC_TPCC_EECRH_E32=1;TPCC_TPCC_EECRH_E33=1;TPCC_TPCC_EECRH_E34=1; TPCC_TPCC_EECRH_E35=1;TPCC_TPCC_EECRH_E36=1;TPCC_TPCC_EECRH_E37=1; TPCC_TPCC_EECRH_E38=1;TPCC_TPCC_EECRH_E39=1;TPCC_TPCC_EECRH_E40=1; TPCC_TPCC_EECRH_E41=1;TPCC_TPCC_EECRH_E42=1;TPCC_TPCC_EECRH_E43=1; TPCC_TPCC_EECRH_E44=1;TPCC_TPCC_EECRH_E45=1;TPCC_TPCC_EECRH_E46=1; TPCC_TPCC_EECRH_E47=1;TPCC_TPCC_EECRH_E48=1;TPCC_TPCC_EECRH_E49=1; TPCC_TPCC_EECRH_E50=1;TPCC_TPCC_EECRH_E51=1;TPCC_TPCC_EECRH_E52=1; TPCC_TPCC_EECRH_E53=1;TPCC_TPCC_EECRH_E54=1;TPCC_TPCC_EECRH_E55=1; TPCC_TPCC_EECRH_E56=1;TPCC_TPCC_EECRH_E57=1;TPCC_TPCC_EECRH_E58=1; TPCC_TPCC_EECRH_E59=1;TPCC_TPCC_EECRH_E60=1;TPCC_TPCC_EECRH_E61=1; TPCC_TPCC_EECRH_E62=1;TPCC_TPCC_EECRH_E63=1; <br />
 TPCC_TPCC_ESR_E0=1;TPCC_TPCC_ESR_E1=1;TPCC_TPCC_ESR_E2=1;TPCC_TPCC_ESR_E3=1; TPCC_TPCC_ESR_E4=1;TPCC_TPCC_ESR_E5=1;TPCC_TPCC_ESR_E6=1;TPCC_TPCC_ESR_E7=1; TPCC_TPCC_ESR_E8=1;TPCC_TPCC_ESR_E9=1;TPCC_TPCC_ESR_E10=1;TPCC_TPCC_ESR_E11=1; TPCC_TPCC_ESR_E12=1;TPCC_TPCC_ESR_E13=1;TPCC_TPCC_ESR_E14=1;TPCC_TPCC_ESR_E15=1; TPCC_TPCC_ESR_E16=1;TPCC_TPCC_ESR_E17=1;TPCC_TPCC_ESR_E18=1;TPCC_TPCC_ESR_E19=1; TPCC_TPCC_ESR_E20=1;TPCC_TPCC_ESR_E21=1;TPCC_TPCC_ESR_E22=1;TPCC_TPCC_ESR_E23=1; TPCC_TPCC_ESR_E24=1;TPCC_TPCC_ESR_E25=1;TPCC_TPCC_ESR_E26=1;TPCC_TPCC_ESR_E27=1; TPCC_TPCC_ESR_E28=1;TPCC_TPCC_ESR_E29=1;TPCC_TPCC_ESR_E30=1;TPCC_TPCC_ESR_E31=1; <br />
 TPCC_TPCC_ESRH_E32=1;TPCC_TPCC_ESRH_E33=1;TPCC_TPCC_ESRH_E34=1;TPCC_TPCC_ESRH_E35=1; TPCC_TPCC_ESRH_E36=1;TPCC_TPCC_ESRH_E37=1;TPCC_TPCC_ESRH_E38=1;TPCC_TPCC_ESRH_E39=1; TPCC_TPCC_ESRH_E40=1;TPCC_TPCC_ESRH_E41=1;TPCC_TPCC_ESRH_E42=1;TPCC_TPCC_ESRH_E43=1; TPCC_TPCC_ESRH_E44=1;TPCC_TPCC_ESRH_E45=1;TPCC_TPCC_ESRH_E46=1;TPCC_TPCC_ESRH_E47=1; TPCC_TPCC_ESRH_E48=1;TPCC_TPCC_ESRH_E49=1;TPCC_TPCC_ESRH_E50=1;TPCC_TPCC_ESRH_E51=1; TPCC_TPCC_ESRH_E52=1;TPCC_TPCC_ESRH_E53=1;TPCC_TPCC_ESRH_E54=1;TPCC_TPCC_ESRH_E55=1; TPCC_TPCC_ESRH_E56=1;TPCC_TPCC_ESRH_E57=1;TPCC_TPCC_ESRH_E58=1;TPCC_TPCC_ESRH_E59=1; TPCC_TPCC_ESRH_E60=1;TPCC_TPCC_ESRH_E61=1;TPCC_TPCC_ESRH_E62=1;TPCC_TPCC_ESRH_E63=1; <br />
 TPCC_TPCC_ECR_E0=1;TPCC_TPCC_ECR_E1=1;TPCC_TPCC_ECR_E2=1;TPCC_TPCC_ECR_E3=1; TPCC_TPCC_ECR_E4=1;TPCC_TPCC_ECR_E5=1;TPCC_TPCC_ECR_E6=1;TPCC_TPCC_ECR_E7=1; TPCC_TPCC_ECR_E8=1;TPCC_TPCC_ECR_E9=1;TPCC_TPCC_ECR_E10=1;TPCC_TPCC_ECR_E11=1; TPCC_TPCC_ECR_E12=1;TPCC_TPCC_ECR_E13=1;TPCC_TPCC_ECR_E14=1;TPCC_TPCC_ECR_E15=1; TPCC_TPCC_ECR_E16=1;TPCC_TPCC_ECR_E17=1;TPCC_TPCC_ECR_E18=1;TPCC_TPCC_ECR_E19=1; TPCC_TPCC_ECR_E20=1;TPCC_TPCC_ECR_E21=1;TPCC_TPCC_ECR_E22=1;TPCC_TPCC_ECR_E23=1; TPCC_TPCC_ECR_E24=1;TPCC_TPCC_ECR_E25=1;TPCC_TPCC_ECR_E26=1;TPCC_TPCC_ECR_E27=1; TPCC_TPCC_ECR_E28=1;TPCC_TPCC_ECR_E29=1;TPCC_TPCC_ECR_E30=1;TPCC_TPCC_ECR_E31=1; <br />
 TPCC_TPCC_ECRH_E32=1;TPCC_TPCC_ECRH_E33=1;TPCC_TPCC_ECRH_E34=1;TPCC_TPCC_ECRH_E35=1; TPCC_TPCC_ECRH_E36=1;TPCC_TPCC_ECRH_E37=1;TPCC_TPCC_ECRH_E38=1;TPCC_TPCC_ECRH_E39=1; TPCC_TPCC_ECRH_E40=1;TPCC_TPCC_ECRH_E41=1;TPCC_TPCC_ECRH_E42=1;TPCC_TPCC_ECRH_E43=1; TPCC_TPCC_ECRH_E44=1;TPCC_TPCC_ECRH_E45=1;TPCC_TPCC_ECRH_E46=1;TPCC_TPCC_ECRH_E47=1; TPCC_TPCC_ECRH_E48=1;TPCC_TPCC_ECRH_E49=1;TPCC_TPCC_ECRH_E50=1;TPCC_TPCC_ECRH_E51=1; TPCC_TPCC_ECRH_E52=1;TPCC_TPCC_ECRH_E53=1;TPCC_TPCC_ECRH_E54=1;TPCC_TPCC_ECRH_E55=1; TPCC_TPCC_ECRH_E56=1;TPCC_TPCC_ECRH_E57=1;TPCC_TPCC_ECRH_E58=1;TPCC_TPCC_ECRH_E59=1; TPCC_TPCC_ECRH_E60=1;TPCC_TPCC_ECRH_E61=1;TPCC_TPCC_ECRH_E62=1;TPCC_TPCC_ECRH_E63=1; <br />
 TPCC_TPCC_EMCR_EMCR0;TPCC_TPCC_EMCR_EMCR1;TPCC_TPCC_EMCR_EMCR2; TPCC_TPCC_EMCR_EMCR3;TPCC_TPCC_EMCR_EMCR4;TPCC_TPCC_EMCR_EMCR5; TPCC_TPCC_EMCR_EMCR6;TPCC_TPCC_EMCR_EMCR7;TPCC_TPCC_EMCR_EMCR8; TPCC_TPCC_EMCR_EMCR9;TPCC_TPCC_EMCR_EMCR10;TPCC_TPCC_EMCR_EMCR11; TPCC_TPCC_EMCR_EMCR12;TPCC_TPCC_EMCR_EMCR13;TPCC_TPCC_EMCR_EMCR14; TPCC_TPCC_EMCR_EMCR15;TPCC_TPCC_EMCR_EMCR16;TPCC_TPCC_EMCR_EMCR17; TPCC_TPCC_EMCR_EMCR18;TPCC_TPCC_EMCR_EMCR19;TPCC_TPCC_EMCR_EMCR20; TPCC_TPCC_EMCR_EMCR21;TPCC_TPCC_EMCR_EMCR22;TPCC_TPCC_EMCR_EMCR23; TPCC_TPCC_EMCR_EMCR24;TPCC_TPCC_EMCR_EMCR25;TPCC_TPCC_EMCR_EMCR26; TPCC_TPCC_EMCR_EMCR27;TPCC_TPCC_EMCR_EMCR28;TPCC_TPCC_EMCR_EMCR29; TPCC_TPCC_EMCR_EMCR30;TPCC_TPCC_EMCR_EMCR31; <br />
 TPCC_TPCC_EMCRH_EMCR32;TPCC_TPCC_EMCRH_EMCR33;TPCC_TPCC_EMCRH_EMCR34 TPCC_TPCC_EMCRH_EMCR35;TPCC_TPCC_EMCRH_EMCR36;TPCC_TPCC_EMCRH_EMCR37 TPCC_TPCC_EMCRH_EMCR38;TPCC_TPCC_EMCRH_EMCR39;TPCC_TPCC_EMCRH_EMCR40 TPCC_TPCC_EMCRH_EMCR41;TPCC_TPCC_EMCRH_EMCR42;TPCC_TPCC_EMCRH_EMCR43 TPCC_TPCC_EMCRH_EMCR44;TPCC_TPCC_EMCRH_EMCR45;TPCC_TPCC_EMCRH_EMCR46 TPCC_TPCC_EMCRH_EMCR47;TPCC_TPCC_EMCRH_EMCR48;TPCC_TPCC_EMCRH_EMCR49 TPCC_TPCC_EMCRH_EMCR50;TPCC_TPCC_EMCRH_EMCR51;TPCC_TPCC_EMCRH_EMCR52 TPCC_TPCC_EMCRH_EMCR53;TPCC_TPCC_EMCRH_EMCR54;TPCC_TPCC_EMCRH_EMCR55 TPCC_TPCC_EMCRH_EMCR56;TPCC_TPCC_EMCRH_EMCR57;TPCC_TPCC_EMCRH_EMCR58 TPCC_TPCC_EMCRH_EMCR59;TPCC_TPCC_EMCRH_EMCR60;TPCC_TPCC_EMCRH_EMCR61 TPCC_TPCC_EMCRH_EMCR62;TPCC_TPCC_EMCRH_EMCR63, <br />
 TPCC_TPCC_SECR_SECR0=1;TPCC_TPCC_SECR_SECR1=1;TPCC_TPCC_SECR_SECR2=1; TPCC_TPCC_SECR_SECR3=1;TPCC_TPCC_SECR_SECR4=1;TPCC_TPCC_SECR_SECR5=1; TPCC_TPCC_SECR_SECR6=1;TPCC_TPCC_SECR_SECR7=1;TPCC_TPCC_SECR_SECR8=1; TPCC_TPCC_SECR_SECR9=1;TPCC_TPCC_SECR_SECR10=1;TPCC_TPCC_SECR_SECR11=1; TPCC_TPCC_SECR_SECR12=1;TPCC_TPCC_SECR_SECR13=1;TPCC_TPCC_SECR_SECR14=1; TPCC_TPCC_SECR_SECR15=1;TPCC_TPCC_SECR_SECR16=1;TPCC_TPCC_SECR_SECR17=1; TPCC_TPCC_SECR_SECR18=1;TPCC_TPCC_SECR_SECR19=1;TPCC_TPCC_SECR_SECR20=1; TPCC_TPCC_SECR_SECR21=1;TPCC_TPCC_SECR_SECR22=1;TPCC_TPCC_SECR_SECR23=1; TPCC_TPCC_SECR_SECR24=1;TPCC_TPCC_SECR_SECR25=1;TPCC_TPCC_SECR_SECR26=1; TPCC_TPCC_SECR_SECR27=1;TPCC_TPCC_SECR_SECR28=1;TPCC_TPCC_SECR_SECR29=1; TPCC_TPCC_SECR_SECR30=1;TPCC_TPCC_SECR_SECR31=1; <br />
 TPCC_TPCC_SECRH_SECR32=1;TPCC_TPCC_SECRH_SECR33=1;TPCC_TPCC_SECRH_SECR34=1; TPCC_TPCC_SECRH_SECR35=1;TPCC_TPCC_SECRH_SECR36=1;TPCC_TPCC_SECRH_SECR37=1; TPCC_TPCC_SECRH_SECR38=1;TPCC_TPCC_SECRH_SECR39=1;TPCC_TPCC_SECRH_SECR40=1; TPCC_TPCC_SECRH_SECR41=1;TPCC_TPCC_SECRH_SECR42=1;TPCC_TPCC_SECRH_SECR43=1; TPCC_TPCC_SECRH_SECR44=1;TPCC_TPCC_SECRH_SECR45=1;TPCC_TPCC_SECRH_SECR46=1; TPCC_TPCC_SECRH_SECR47=1;TPCC_TPCC_SECRH_SECR48=1;TPCC_TPCC_SECRH_SECR49=1; TPCC_TPCC_SECRH_SECR50=1;TPCC_TPCC_SECRH_SECR51=1;TPCC_TPCC_SECRH_SECR52=1; TPCC_TPCC_SECRH_SECR53=1;TPCC_TPCC_SECRH_SECR54=1;TPCC_TPCC_SECRH_SECR55=1; TPCC_TPCC_SECRH_SECR56=1;TPCC_TPCC_SECRH_SECR57=1;TPCC_TPCC_SECRH_SECR58=1; TPCC_TPCC_SECRH_SECR59=1;TPCC_TPCC_SECRH_SECR60=1;TPCC_TPCC_SECRH_SECR61=1; TPCC_TPCC_SECRH_SECR62=1;TPCC_TPCC_SECRH_SECR63=1; <br />
 TPCC_TPCC_QEMCR_QEMCR0;TPCC_TPCC_QEMCR_QEMCR1;TPCC_TPCC_QEMCR_QEMCR2; TPCC_TPCC_QEMCR_QEMCR3;TPCC_TPCC_QEMCR_QEMCR4;TPCC_TPCC_QEMCR_QEMCR5; TPCC_TPCC_QEMCR_QEMCR6;TPCC_TPCC_QEMCR_QEMCR7, <br />
 TPCC_TPCC_QSECR_QSECR0=1;TPCC_TPCC_QSECR_QSECR1=1;TPCC_TPCC_QSECR_QSECR2=1; TPCC_TPCC_QSECR_QSECR3=1;TPCC_TPCC_QSECR_QSECR4=1;TPCC_TPCC_QSECR_QSECR5=1; TPCC_TPCC_QSECR_QSECR6=1;TPCC_TPCC_QSECR_QSECR7=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Status                  status;
     
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Channel 0 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum    = 0;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, CSL_EDMA3, &amp;chAttr, &amp;status);
         ...               
         // Enable Channel 
         CSL_edma3HwChannelControl(hChannel,CSL_EDMA3_CMD_CHANNEL_ENABLE,NULL);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga9e947bb8dfae54b3d824fa6fa4b9350c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3HwChannelSetupParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>paramNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3HwChannelSetupParam</b> </p>
<p><b>Description</b> <br />
 The function maps a DMA/QDMA channel to the specific PARAM Entry.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Channel Handle
         paramNum        Parameter Entry</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before this API can be invoked</p>
<p><b> Post Condition </b> <br />
 Channel is mapped to the PARAM Entry.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DCHMAP_PAENTRY; <br />
 TPCC_TPCC_QCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Status                  status;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;

         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Channel 0 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum    = 0;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ...
         // Map the channel to PARAM Entry 1
         CSL_edma3HwChannelSetupParam(hChannel, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga111c2fac7c9b7c5b70d5d53a3b446e64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3HwChannelSetupQue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gac24f2bf4e0f2e746622583a1e978426a">CSL_Edma3Que</a>&#160;</td>
          <td class="paramname"><em>evtQue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3HwChannelSetupQue</b> </p>
<p><b>Description</b> <br />
 The function maps the DMA/QDMA channels to the specified event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Channel Handle
         evtQue          Queue Setup</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before this API can be invoked</p>
<p><b> Post Condition </b> <br />
 Sets up the channel to Queue mapping</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QDMAQNUM_E0;TPCC_TPCC_QDMAQNUM_E1;TPCC_TPCC_QDMAQNUM_E2; TPCC_TPCC_QDMAQNUM_E3;TPCC_TPCC_QDMAQNUM_E4;TPCC_TPCC_QDMAQNUM_E5; TPCC_TPCC_QDMAQNUM_E6;TPCC_TPCC_QDMAQNUM_E7; <br />
 TPCC_TPCC_DMAQNUM_E0;TPCC_TPCC_DMAQNUM_E1;TPCC_TPCC_DMAQNUM_E2; TPCC_TPCC_DMAQNUM_E3;TPCC_TPCC_DMAQNUM_E4;TPCC_TPCC_DMAQNUM_E5; TPCC_TPCC_DMAQNUM_E6;TPCC_TPCC_DMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Status                  status;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;

         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Channel 1 Open in context of Shadow region 0
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum = 16;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ...
         // Map the channel 1 to Event Queue 3.
         CSL_edma3HwChannelSetupQue(hChannel,CSL_EDMA3_QUE_3);
         ...                </pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga910b5dacecf2d7d8e381acdbee06e777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3HwChannelSetupTriggerWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga3fa15a5a5563e7f34240387f1261b797">CSL_Edma3ChannelHandle</a>&#160;</td>
          <td class="paramname"><em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>triggerWord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3HwChannelSetupTriggerWord</b> </p>
<p><b>Description</b> <br />
 The function is used to setup the trigger word for QDMA Channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hEdma           Channel Handle
         triggerWord     Trigger Word to be configured.                            </pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before this API can be invoked</p>
<p><b> Post Condition </b> <br />
 Sets up the QDMA Channel to trigger Word</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QCHMAP_TRWORD</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Status                  status;
         CSL_Edma3ChannelAttr        chAttr;
         CSL_Edma3ChannelObj         chObj;
         CSL_Edma3ChannelHandle      hChannel;

         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Channel 16 Open in context of Shadow region 0 (This is a QDMA Channel)
         chAttr.regionNum = CSL_EDMA3_REGION_0;
         chAttr.chaNum = 16;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         ...        
         // Sets up the QDMA Channel 0 trigger Word to the 3rd trigger word.
         CSL_edma3HwChannelSetupTriggerWord(hChannel,3);
         ...     </pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaffb623f701478b59272d92cff3ba8d1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3HwControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hMod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gaf441a2c75e8197725dab2ef511bdcb1b">CSL_Edma3HwControlCmd</a>&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cmdArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3HwControl</b> </p>
<p><b>Description</b> <br />
 This API takes a command with an optional argument and performs the appropriate action. This can be used to perform various operations on the EDMA module.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hMod        EDMA Module Handle 
         cmd         Command which needs to be executed.
         cmdArg      Pointer to the argument specific to the command</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___c_s_l___e_d_m_a3___e_n_u_m.html#gaf441a2c75e8197725dab2ef511bdcb1b">CSL_Edma3HwControlCmd</a></dd></dl>
<p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVCMD (The command passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Functions <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> must be called successfully in that order before this API can be invoked</p>
<p><b> Post Condition </b> <br />
 EDMA registers are configured according to the command and the command arguments. The command determines which registers are modified.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_MPPAG;TPCC_TPCC_MPPA; <br />
 TPCC_TPCC_MPFCR_MPFCLR=1; <br />
 TPCC_TPCC_DRA_DRAE_E0=1;TPCC_TPCC_DRA_DRAE_E1=1;TPCC_TPCC_DRA_DRAE_E2=1; TPCC_TPCC_DRA_DRAE_E3=1;TPCC_TPCC_DRA_DRAE_E4=1;TPCC_TPCC_DRA_DRAE_E5=1; TPCC_TPCC_DRA_DRAE_E6=1;TPCC_TPCC_DRA_DRAE_E7=1;TPCC_TPCC_DRA_DRAE_E8=1; TPCC_TPCC_DRA_DRAE_E9=1;TPCC_TPCC_DRA_DRAE_E10=1;TPCC_TPCC_DRA_DRAE_E11=1; TPCC_TPCC_DRA_DRAE_E12=1;TPCC_TPCC_DRA_DRAE_E13=1;TPCC_TPCC_DRA_DRAE_E14=1; TPCC_TPCC_DRA_DRAE_E15=1;TPCC_TPCC_DRA_DRAE_E16=1;TPCC_TPCC_DRA_DRAE_E17=1; TPCC_TPCC_DRA_DRAE_E18=1;TPCC_TPCC_DRA_DRAE_E19=1;TPCC_TPCC_DRA_DRAE_E20=1; TPCC_TPCC_DRA_DRAE_E21=1;TPCC_TPCC_DRA_DRAE_E22=1;TPCC_TPCC_DRA_DRAE_E23=1; TPCC_TPCC_DRA_DRAE_E24=1;TPCC_TPCC_DRA_DRAE_E25=1;TPCC_TPCC_DRA_DRAE_E26=1; TPCC_TPCC_DRA_DRAE_E27=1;TPCC_TPCC_DRA_DRAE_E28=1;TPCC_TPCC_DRA_DRAE_E29=1; TPCC_TPCC_DRA_DRAE_E30=1;TPCC_TPCC_DRA_DRAE_E31=1; <br />
 TPCC_TPCC_DRA_DRAEH_E32=1;TPCC_TPCC_DRA_DRAEH_E33=1;TPCC_TPCC_DRA_DRAEH_E34=1; TPCC_TPCC_DRA_DRAEH_E35=1;TPCC_TPCC_DRA_DRAEH_E36=1;TPCC_TPCC_DRA_DRAEH_E37=1; TPCC_TPCC_DRA_DRAEH_E38=1;TPCC_TPCC_DRA_DRAEH_E39=1;TPCC_TPCC_DRA_DRAEH_E40=1; TPCC_TPCC_DRA_DRAEH_E41=1;TPCC_TPCC_DRA_DRAEH_E42=1;TPCC_TPCC_DRA_DRAEH_E43=1; TPCC_TPCC_DRA_DRAEH_E44=1;TPCC_TPCC_DRA_DRAEH_E45=1;TPCC_TPCC_DRA_DRAEH_E46=1; TPCC_TPCC_DRA_DRAEH_E47=1;TPCC_TPCC_DRA_DRAEH_E48=1;TPCC_TPCC_DRA_DRAEH_E49=1; TPCC_TPCC_DRA_DRAEH_E50=1;TPCC_TPCC_DRA_DRAEH_E51=1;TPCC_TPCC_DRA_DRAEH_E52=1; TPCC_TPCC_DRA_DRAEH_E53=1;TPCC_TPCC_DRA_DRAEH_E54=1;TPCC_TPCC_DRA_DRAEH_E55=1; TPCC_TPCC_DRA_DRAEH_E56=1;TPCC_TPCC_DRA_DRAEH_E57=1;TPCC_TPCC_DRA_DRAEH_E58=1; TPCC_TPCC_DRA_DRAEH_E59=1;TPCC_TPCC_DRA_DRAEH_E60=1;TPCC_TPCC_DRA_DRAEH_E61=1; TPCC_TPCC_DRA_DRAEH_E62=1;TPCC_TPCC_DRA_DRAEH_E63=1; <br />
 TPCC_TPCC_DRA_DRAE_E0=0;TPCC_TPCC_DRA_DRAE_E1=0;TPCC_TPCC_DRA_DRAE_E2=0; TPCC_TPCC_DRA_DRAE_E3=0;TPCC_TPCC_DRA_DRAE_E4=0;TPCC_TPCC_DRA_DRAE_E5=0; TPCC_TPCC_DRA_DRAE_E6=0;TPCC_TPCC_DRA_DRAE_E7=0;TPCC_TPCC_DRA_DRAE_E8=0; TPCC_TPCC_DRA_DRAE_E9=0;TPCC_TPCC_DRA_DRAE_E10=0;TPCC_TPCC_DRA_DRAE_E11=0; TPCC_TPCC_DRA_DRAE_E12=0;TPCC_TPCC_DRA_DRAE_E13=0;TPCC_TPCC_DRA_DRAE_E14=0; TPCC_TPCC_DRA_DRAE_E15=0;TPCC_TPCC_DRA_DRAE_E16=0;TPCC_TPCC_DRA_DRAE_E17=0; TPCC_TPCC_DRA_DRAE_E18=0;TPCC_TPCC_DRA_DRAE_E19=0;TPCC_TPCC_DRA_DRAE_E20=0; TPCC_TPCC_DRA_DRAE_E21=0;TPCC_TPCC_DRA_DRAE_E22=0;TPCC_TPCC_DRA_DRAE_E23=0; TPCC_TPCC_DRA_DRAE_E24=0;TPCC_TPCC_DRA_DRAE_E25=0;TPCC_TPCC_DRA_DRAE_E26=0; TPCC_TPCC_DRA_DRAE_E27=0;TPCC_TPCC_DRA_DRAE_E28=0;TPCC_TPCC_DRA_DRAE_E29=0; TPCC_TPCC_DRA_DRAE_E30=0;TPCC_TPCC_DRA_DRAE_E31=0; <br />
 TPCC_TPCC_DRA_DRAEH_E32=0;TPCC_TPCC_DRA_DRAEH_E33=0;TPCC_TPCC_DRA_DRAEH_E34=0; TPCC_TPCC_DRA_DRAEH_E35=0;TPCC_TPCC_DRA_DRAEH_E36=0;TPCC_TPCC_DRA_DRAEH_E37=0; TPCC_TPCC_DRA_DRAEH_E38=0;TPCC_TPCC_DRA_DRAEH_E39=0;TPCC_TPCC_DRA_DRAEH_E40=0; TPCC_TPCC_DRA_DRAEH_E41=0;TPCC_TPCC_DRA_DRAEH_E42=0;TPCC_TPCC_DRA_DRAEH_E43=0; TPCC_TPCC_DRA_DRAEH_E44=0;TPCC_TPCC_DRA_DRAEH_E45=0;TPCC_TPCC_DRA_DRAEH_E46=0; TPCC_TPCC_DRA_DRAEH_E47=0;TPCC_TPCC_DRA_DRAEH_E48=0;TPCC_TPCC_DRA_DRAEH_E49=0; TPCC_TPCC_DRA_DRAEH_E50=0;TPCC_TPCC_DRA_DRAEH_E51=0;TPCC_TPCC_DRA_DRAEH_E52=0; TPCC_TPCC_DRA_DRAEH_E53=0;TPCC_TPCC_DRA_DRAEH_E54=0;TPCC_TPCC_DRA_DRAEH_E55=0; TPCC_TPCC_DRA_DRAEH_E56=0;TPCC_TPCC_DRA_DRAEH_E57=0;TPCC_TPCC_DRA_DRAEH_E58=0; TPCC_TPCC_DRA_DRAEH_E59=0;TPCC_TPCC_DRA_DRAEH_E60=0;TPCC_TPCC_DRA_DRAEH_E61=0; TPCC_TPCC_DRA_DRAEH_E62=0;TPCC_TPCC_DRA_DRAEH_E63=0; <br />
 TPCC_TPCC_QRAE_E0=1;TPCC_TPCC_QRAE_E1=1;TPCC_TPCC_QRAE_E2=1; TPCC_TPCC_QRAE_E3=1;TPCC_TPCC_QRAE_E4=1;TPCC_TPCC_QRAE_E5=1; TPCC_TPCC_QRAE_E6=1;TPCC_TPCC_QRAE_E7=1; <br />
 TPCC_TPCC_QRAE_E0=0;TPCC_TPCC_QRAE_E1=0;TPCC_TPCC_QRAE_E2=0; TPCC_TPCC_QRAE_E3=0;TPCC_TPCC_QRAE_E4=0;TPCC_TPCC_QRAE_E5=0; TPCC_TPCC_QRAE_E6=0;TPCC_TPCC_QRAE_E7=0; <br />
 TPCC_TPCC_QUEPRI_PRIQ0;TPCC_TPCC_QUEPRI_PRIQ1;TPCC_TPCC_QUEPRI_PRIQ2; TPCC_TPCC_QUEPRI_PRIQ3;TPCC_TPCC_QUEPRI_PRIQ4;TPCC_TPCC_QUEPRI_PRIQ5; TPCC_TPCC_QUEPRI_PRIQ6;TPCC_TPCC_QUEPRI_PRIQ7; <br />
 TPCC_TPCC_QWMTHRA_Q0;TPCC_TPCC_QWMTHRA_Q1;TPCC_TPCC_QWMTHRA_Q2; TPCC_TPCC_QWMTHRA_Q3; <br />
 TPCC_TPCC_QWMTHRB_Q4;TPCC_TPCC_QWMTHRB_Q1;TPCC_TPCC_QWMTHRB_Q2; TPCC_TPCC_QWMTHRB_Q3; <br />
 TPCC_TPCC_EEVAL_EVAL=1; <br />
 TPCC_TPCC_ICR,TPCC_TPCC_ICRH; <br />
 TPCC_TPCC_IESR_IESR0=1;TPCC_TPCC_IESR_IESR1=1;TPCC_TPCC_IESR_IESR2=1; TPCC_TPCC_IESR_IESR3=1;TPCC_TPCC_IESR_IESR4=1;TPCC_TPCC_IESR_IESR5=1; TPCC_TPCC_IESR_IESR6=1;TPCC_TPCC_IESR_IESR7=1;TPCC_TPCC_IESR_IESR8=1; TPCC_TPCC_IESR_IESR9=1;TPCC_TPCC_IESR_IESR10=1;TPCC_TPCC_IESR_IESR11=1; TPCC_TPCC_IESR_IESR12=1;TPCC_TPCC_IESR_IESR13=1;TPCC_TPCC_IESR_IESR14=1; TPCC_TPCC_IESR_IESR15=1;TPCC_TPCC_IESR_IESR16=1;TPCC_TPCC_IESR_IESR17=1; TPCC_TPCC_IESR_IESR18=1;TPCC_TPCC_IESR_IESR19=1;TPCC_TPCC_IESR_IESR20=1; TPCC_TPCC_IESR_IESR21=1;TPCC_TPCC_IESR_IESR22=1;TPCC_TPCC_IESR_IESR23=1; TPCC_TPCC_IESR_IESR24=1;TPCC_TPCC_IESR_IESR25=1;TPCC_TPCC_IESR_IESR26=1; TPCC_TPCC_IESR_IESR27=1;TPCC_TPCC_IESR_IESR28=1;TPCC_TPCC_IESR_IESR29=1; TPCC_TPCC_IESR_IESR30=1;TPCC_TPCC_IESR_IESR31=1; <br />
 TPCC_TPCC_IESRH_IESR32=1;TPCC_TPCC_IESRH_IESR33=1;TPCC_TPCC_IESRH_IESR34=1; TPCC_TPCC_IESRH_IESR35=1;TPCC_TPCC_IESRH_IESR36=1;TPCC_TPCC_IESRH_IESR37=1; TPCC_TPCC_IESRH_IESR38=1;TPCC_TPCC_IESRH_IESR39=1;TPCC_TPCC_IESRH_IESR40=1; TPCC_TPCC_IESRH_IESR41=1;TPCC_TPCC_IESRH_IESR42=1;TPCC_TPCC_IESRH_IESR43=1; TPCC_TPCC_IESRH_IESR44=1;TPCC_TPCC_IESRH_IESR45=1;TPCC_TPCC_IESRH_IESR46=1; TPCC_TPCC_IESRH_IESR47=1;TPCC_TPCC_IESRH_IESR48=1;TPCC_TPCC_IESRH_IESR49=1; TPCC_TPCC_IESRH_IESR50=1;TPCC_TPCC_IESRH_IESR51=1;TPCC_TPCC_IESRH_IESR52=1; TPCC_TPCC_IESRH_IESR53=1;TPCC_TPCC_IESRH_IESR54=1;TPCC_TPCC_IESRH_IESR55=1; TPCC_TPCC_IESRH_IESR56=1;TPCC_TPCC_IESRH_IESR57=1;TPCC_TPCC_IESRH_IESR58=1; TPCC_TPCC_IESRH_IESR59=1;TPCC_TPCC_IESRH_IESR60=1;TPCC_TPCC_IESRH_IESR61=1; TPCC_TPCC_IESRH_IESR62=1;TPCC_TPCC_IESRH_IESR63=1; <br />
 TPCC_TPCC_IECR_IECR0=1;TPCC_TPCC_IECR_IECR1=1;TPCC_TPCC_IECR_IECR2=1; TPCC_TPCC_IECR_IECR3=1;TPCC_TPCC_IECR_IECR4=1;TPCC_TPCC_IECR_IECR5=1; TPCC_TPCC_IECR_IECR6=1;TPCC_TPCC_IECR_IECR7=1;TPCC_TPCC_IECR_IECR8=1; TPCC_TPCC_IECR_IECR9=1;TPCC_TPCC_IECR_IECR10=1;TPCC_TPCC_IECR_IECR11=1; TPCC_TPCC_IECR_IECR12=1;TPCC_TPCC_IECR_IECR13=1;TPCC_TPCC_IECR_IECR14=1; TPCC_TPCC_IECR_IECR15=1;TPCC_TPCC_IECR_IECR16=1;TPCC_TPCC_IECR_IECR17=1; TPCC_TPCC_IECR_IECR18=1;TPCC_TPCC_IECR_IECR19=1;TPCC_TPCC_IECR_IECR20=1; TPCC_TPCC_IECR_IECR21=1;TPCC_TPCC_IECR_IECR22=1;TPCC_TPCC_IECR_IECR23=1; TPCC_TPCC_IECR_IECR24=1;TPCC_TPCC_IECR_IECR25=1;TPCC_TPCC_IECR_IECR26=1; TPCC_TPCC_IECR_IECR27=1;TPCC_TPCC_IECR_IECR28=1;TPCC_TPCC_IECR_IECR29=1; TPCC_TPCC_IECR_IECR30=1;TPCC_TPCC_IECR_IECR31=1; <br />
 TPCC_TPCC_IECRH_IECR32=1;TPCC_TPCC_IECRH_IECR33=1;TPCC_TPCC_IECRH_IECR34=1; TPCC_TPCC_IECRH_IECR35=1;TPCC_TPCC_IECRH_IECR36=1;TPCC_TPCC_IECRH_IECR37=1; TPCC_TPCC_IECRH_IECR38=1;TPCC_TPCC_IECRH_IECR39=1;TPCC_TPCC_IECRH_IECR40=1; TPCC_TPCC_IECRH_IECR41=1;TPCC_TPCC_IECRH_IECR42=1;TPCC_TPCC_IECRH_IECR43=1; TPCC_TPCC_IECRH_IECR44=1;TPCC_TPCC_IECRH_IECR45=1;TPCC_TPCC_IECRH_IECR46=1; TPCC_TPCC_IECRH_IECR47=1;TPCC_TPCC_IECRH_IECR48=1;TPCC_TPCC_IECRH_IECR49=1; TPCC_TPCC_IECRH_IECR50=1;TPCC_TPCC_IECRH_IECR51=1;TPCC_TPCC_IECRH_IECR52=1; TPCC_TPCC_IECRH_IECR53=1;TPCC_TPCC_IECRH_IECR54=1;TPCC_TPCC_IECRH_IECR55=1; TPCC_TPCC_IECRH_IECR56=1;TPCC_TPCC_IECRH_IECR57=1;TPCC_TPCC_IECRH_IECR58=1; TPCC_TPCC_IECRH_IECR59=1;TPCC_TPCC_IECRH_IECR60=1;TPCC_TPCC_IECRH_IECR61=1; TPCC_TPCC_IECRH_IECR62=1;TPCC_TPCC_IECRH_IECR63=1; <br />
 TPCC_TPCC_IEVAL_EVAL=1; <br />
 TPCC_TPCC_CCERRCLR_QTHRXD0;TPCC_TPCC_CCERRCLR_QTHRXD1;TPCC_TPCC_CCERRCLR_QTHRXD2; TPCC_TPCC_CCERRCLR_QTHRXD3;TPCC_TPCC_CCERRCLR_QTHRXD4;TPCC_TPCC_CCERRCLR_QTHRXD5; TPCC_TPCC_CCERRCLR_QTHRXD6;TPCC_TPCC_CCERRCLR_QTHRXD7, TPCC_TPCC_CCERR_TCCERR; <br />
 TPCC_TPCC_EMCR,TPCC_TPCC_EMCRH,TPCC_TPCC_QEMCR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Status                  status;
         CSL_Edma3CmdDrae            regionAccess;

         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // DRAE Enable(Bits 0-15) for the Shadow Region 0.
         regionAccess.region = CSL_EDMA3_REGION_0 ;
         regionAccess.drae =   0xFFFF ;   
         regionAccess.draeh =  0x0000 ;
         CSL_edma3HwControl(hModule,CSL_EDMA3_CMD_DMAREGION_ENABLE, &amp;regionAccess);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga886d978dc328ae551fe7c6e6d27e5760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3HwSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hMod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___edma3_hw_setup.html">CSL_Edma3HwSetup</a> *&#160;</td>
          <td class="paramname"><em>setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3HwSetup</b> </p>
<p><b>Description</b> <br />
 This function does the setup for all DMA/QDMA channels by doing the following operations:-</p><ul>
<li>Mapping DMA/QDMA Channels to PARAM Blocks.</li>
<li>Mapping DMA/QDMA Channels to Event Queues.</li>
<li>Setting up the trigger word for QDMA channels.</li>
</ul>
<p><b>Arguments</b> </p><pre class="fragment">         hMod            Edma module Handle
         setup           Pointer to the setup structure</pre><p><b> Return Value </b> CSL_Status <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_c_s_l___edma3_hw_setup.html" title="Edma Hw Setup Structure. ">CSL_Edma3HwSetup</a></dd></dl>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> must be called successfully in that order before this API can be invoked</p>
<p><b> Post Condition </b> <br />
 EDMA registers are configured according to the hardware setup parameters</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DCHMAP_PAENTRY, <br />
 TPCC_TPCC_DMAQNUM_E0;TPCC_TPCC_DMAQNUM_E1;TPCC_TPCC_DMAQNUM_E2; TPCC_TPCC_DMAQNUM_E3;TPCC_TPCC_DMAQNUM_E4;TPCC_TPCC_DMAQNUM_E5; TPCC_TPCC_DMAQNUM_E6;TPCC_TPCC_DMAQNUM_E7; <br />
 TPCC_TPCC_QCHMAP_PAENTRY, <br />
 TPCC_TPCC_QCHMAP_TRWORD, <br />
 TPCC_TPCC_QDMAQNUM_E0;TPCC_TPCC_QDMAQNUM_E1;TPCC_TPCC_QDMAQNUM_E2; TPCC_TPCC_QDMAQNUM_E3;TPCC_TPCC_QDMAQNUM_E4;TPCC_TPCC_QDMAQNUM_E5; TPCC_TPCC_QDMAQNUM_E6;TPCC_TPCC_QDMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle             hModule;
         CSL_Edma3Obj                edmaObj;
         CSL_Status                  status;
         CSL_Edma3HwSetup            hwSetup;
         CSL_Edma3HwDmaChannelSetup  dmahwSetup[64];
         CSL_Edma3HwQdmaChannelSetup qdmahwSetup[8];

         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Module Setup
         hwSetup.dmaChaSetup  = &amp;dmahwSetup[0];
         hwSetup.qdmaChaSetup = &amp;qdmaSetup[0];
         CSL_edma3HwSetup(hModule,&amp;hwSetup);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga588ede6cd00b9ae480f847010a9433e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gaa6e2443bbc7d672e0e66a66c2f059448">CSL_Edma3Context</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3Init</b> </p>
<p><b>Description</b> <br />
 This is the initialization function for the EDMA CSL. The function must be called before calling any other API from this CSL.This function is idem-potent. Currently, the function just return status CSL_SOK, without doing anything.</p>
<p><b>Arguments</b> </p><pre class="fragment">         pContext    Pointer to module-context. As EDMA doesn't have
                     any context based information user is expected 
                     to pass NULL.</pre><p><b> Return Value </b> <br />
 Always returns CSL_SOK</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The CSL for EDMA is initialized</p>
<p><b>Affects</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">         // Initialize the EDMA3 Module.          
         CSL_edma3Init(NULL);
         ...
         // All EDMA Functions should follow this.
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga61c5e5d18e400c1706deafbe5ea5aed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptEval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptEval</b> </p>
<p><b>Description</b> <br />
 The API is used to set the EVAL bit which will cause an interrupt to be generated if any enabled interrupts are still pending.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadown Region or Global)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IEVAL_EVAL=1</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         CSL_BitMask32           edmaIntrLo;
         CSL_BitMask32           edmaIntrHi;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...        
         // Interrupt Evaluate for Global Region.
         status = CSL_edma3InterruptEval(hModule, CSL_EDMA3_REGION_GLOBAL);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaec9b854d4799036131f82237bc877ca5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptHiDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptHiDisable</b> </p>
<p><b>Description</b> <br />
 The API disables the specified high interrupt Number.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadow or Global)
     intrHi            Interrupt 32-63 (BitMask32) to be disabled</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IECRH_IECR32=1;TPCC_TPCC_IECRH_IECR33=1;TPCC_TPCC_IECRH_IECR34=1; TPCC_TPCC_IECRH_IECR35=1;TPCC_TPCC_IECRH_IECR36=1;TPCC_TPCC_IECRH_IECR37=1; TPCC_TPCC_IECRH_IECR38=1;TPCC_TPCC_IECRH_IECR39=1;TPCC_TPCC_IECRH_IECR40=1; TPCC_TPCC_IECRH_IECR41=1;TPCC_TPCC_IECRH_IECR42=1;TPCC_TPCC_IECRH_IECR43=1; TPCC_TPCC_IECRH_IECR44=1;TPCC_TPCC_IECRH_IECR45=1;TPCC_TPCC_IECRH_IECR46=1; TPCC_TPCC_IECRH_IECR47=1;TPCC_TPCC_IECRH_IECR48=1;TPCC_TPCC_IECRH_IECR49=1; TPCC_TPCC_IECRH_IECR50=1;TPCC_TPCC_IECRH_IECR51=1;TPCC_TPCC_IECRH_IECR52=1; TPCC_TPCC_IECRH_IECR53=1;TPCC_TPCC_IECRH_IECR54=1;TPCC_TPCC_IECRH_IECR55=1; TPCC_TPCC_IECRH_IECR56=1;TPCC_TPCC_IECRH_IECR57=1;TPCC_TPCC_IECRH_IECR58=1; TPCC_TPCC_IECRH_IECR59=1;TPCC_TPCC_IECRH_IECR60=1;TPCC_TPCC_IECRH_IECR61=1; TPCC_TPCC_IECRH_IECR62=1;TPCC_TPCC_IECRH_IECR63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
     
         // Interrupts 32 disabled for Global Region.
         CSL_edma3InterruptHiDisable(hModule, CSL_EDMA3_REGION_GLOBAL, 0x1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadd501db6edf23e9201e11cf63acd7bd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptHiEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptHiEnable</b> </p>
<p><b>Description</b> <br />
 The API enables the specific High interrupt.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule          Module Handle
     region           Region (Shadow or Global) 
     intrHi           Interrupt 32-63 (BitMask32) to be enabled</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IESRH_IESR32=1;TPCC_TPCC_IESRH_IESR33=1;TPCC_TPCC_IESRH_IESR34=1; TPCC_TPCC_IESRH_IESR35=1;TPCC_TPCC_IESRH_IESR36=1;TPCC_TPCC_IESRH_IESR37=1; TPCC_TPCC_IESRH_IESR38=1;TPCC_TPCC_IESRH_IESR39=1;TPCC_TPCC_IESRH_IESR40=1; TPCC_TPCC_IESRH_IESR41=1;TPCC_TPCC_IESRH_IESR42=1;TPCC_TPCC_IESRH_IESR43=1; TPCC_TPCC_IESRH_IESR44=1;TPCC_TPCC_IESRH_IESR45=1;TPCC_TPCC_IESRH_IESR46=1; TPCC_TPCC_IESRH_IESR47=1;TPCC_TPCC_IESRH_IESR48=1;TPCC_TPCC_IESRH_IESR49=1; TPCC_TPCC_IESRH_IESR50=1;TPCC_TPCC_IESRH_IESR51=1;TPCC_TPCC_IESRH_IESR52=1; TPCC_TPCC_IESRH_IESR53=1;TPCC_TPCC_IESRH_IESR54=1;TPCC_TPCC_IESRH_IESR55=1; TPCC_TPCC_IESRH_IESR56=1;TPCC_TPCC_IESRH_IESR57=1;TPCC_TPCC_IESRH_IESR58=1; TPCC_TPCC_IESRH_IESR59=1;TPCC_TPCC_IESRH_IESR60=1;TPCC_TPCC_IESRH_IESR61=1; TPCC_TPCC_IESRH_IESR62=1;TPCC_TPCC_IESRH_IESR63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
     
         // Interrupts 32 enabled for the global region.
         CSL_edma3InterruptHiEnable(hModule,CSL_EDMA3_REGION_GLOBAL, 0x1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8cca9a54be594bf9b3d9642e9538797e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptLoDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptLoDisable</b> </p>
<p><b>Description</b> <br />
 The API disables the specified low interrupt Number.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     region            Region (Shadow or Global)
     intrLo            Interrupt 0-31 (BitMask32) to be disabled</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IECR_IECR0=1;TPCC_TPCC_IECR_IECR1=1;TPCC_TPCC_IECR_IECR2=1; TPCC_TPCC_IECR_IECR3=1;TPCC_TPCC_IECR_IECR4=1;TPCC_TPCC_IECR_IECR5=1; TPCC_TPCC_IECR_IECR6=1;TPCC_TPCC_IECR_IECR7=1;TPCC_TPCC_IECR_IECR8=1; TPCC_TPCC_IECR_IECR9=1;TPCC_TPCC_IECR_IECR10=1;TPCC_TPCC_IECR_IECR11=1; TPCC_TPCC_IECR_IECR12=1;TPCC_TPCC_IECR_IECR13=1;TPCC_TPCC_IECR_IECR14=1; TPCC_TPCC_IECR_IECR15=1;TPCC_TPCC_IECR_IECR16=1;TPCC_TPCC_IECR_IECR17=1; TPCC_TPCC_IECR_IECR18=1;TPCC_TPCC_IECR_IECR19=1;TPCC_TPCC_IECR_IECR20=1; TPCC_TPCC_IECR_IECR21=1;TPCC_TPCC_IECR_IECR22=1;TPCC_TPCC_IECR_IECR23=1; TPCC_TPCC_IECR_IECR24=1;TPCC_TPCC_IECR_IECR25=1;TPCC_TPCC_IECR_IECR26=1; TPCC_TPCC_IECR_IECR27=1;TPCC_TPCC_IECR_IECR28=1;TPCC_TPCC_IECR_IECR29=1; TPCC_TPCC_IECR_IECR30=1;TPCC_TPCC_IECR_IECR31=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
     
         // Interrupts 5-7 disabled for Global Region.
         CSL_edma3InterruptLoDisable(hModule, CSL_EDMA3_REGION_GLOBAL, 0x000000E0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2d222265626a331066b9ec9aaa38d25e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3InterruptLoEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>intrLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3InterruptLoEnable</b> </p>
<p><b>Description</b> <br />
 The API enables the specific lower interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule          Module Handle
     region           Region (Shadow or Global) 
     intrLo           Interrupt 0-31 (BitMask32) to be enabled</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_IESR_IESR0=1;TPCC_TPCC_IESR_IESR1=1;TPCC_TPCC_IESR_IESR2=1; TPCC_TPCC_IESR_IESR3=1;TPCC_TPCC_IESR_IESR4=1;TPCC_TPCC_IESR_IESR5=1; TPCC_TPCC_IESR_IESR6=1;TPCC_TPCC_IESR_IESR7=1;TPCC_TPCC_IESR_IESR8=1; TPCC_TPCC_IESR_IESR9=1;TPCC_TPCC_IESR_IESR10=1;TPCC_TPCC_IESR_IESR11=1; TPCC_TPCC_IESR_IESR12=1;TPCC_TPCC_IESR_IESR13=1;TPCC_TPCC_IESR_IESR14=1; TPCC_TPCC_IESR_IESR15=1;TPCC_TPCC_IESR_IESR16=1;TPCC_TPCC_IESR_IESR17=1; TPCC_TPCC_IESR_IESR18=1;TPCC_TPCC_IESR_IESR19=1;TPCC_TPCC_IESR_IESR20=1; TPCC_TPCC_IESR_IESR21=1;TPCC_TPCC_IESR_IESR22=1;TPCC_TPCC_IESR_IESR23=1; TPCC_TPCC_IESR_IESR24=1;TPCC_TPCC_IESR_IESR25=1;TPCC_TPCC_IESR_IESR26=1; TPCC_TPCC_IESR_IESR27=1;TPCC_TPCC_IESR_IESR28=1;TPCC_TPCC_IESR_IESR29=1; TPCC_TPCC_IESR_IESR30=1;TPCC_TPCC_IESR_IESR31=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
     
         // Interrupts 5-7 enabled for the global region.
         CSL_edma3InterruptLoEnable(hModule,CSL_EDMA3_REGION_GLOBAL, 0x000000E0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga866c9adb7b8e44f8cd62df238122c46d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsDMAChannelEventPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsDMAChannelEventPending</b> </p>
<p><b>Description</b> <br />
 The function gets the status of the specified DMA channel i.e. if there is a pending event on the specific channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     dmaChannel      DMA Channel for which status is being inquired.
     response        Place holder for whether an event is set(TRUE) or not (FALSE)</pre><p><b> Return Value </b> <br />
 None.</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_ER_E0;TPCC_TPCC_ER_E1;TPCC_TPCC_ER_E2;TPCC_TPCC_ER_E3; TPCC_TPCC_ER_E4;TPCC_TPCC_ER_E5;TPCC_TPCC_ER_E6;TPCC_TPCC_ER_E7; TPCC_TPCC_ER_E8;TPCC_TPCC_ER_E9;TPCC_TPCC_ER_E10;TPCC_TPCC_ER_E11; TPCC_TPCC_ER_E12;TPCC_TPCC_ER_E13;TPCC_TPCC_ER_E14;TPCC_TPCC_ER_E15; TPCC_TPCC_ER_E16;TPCC_TPCC_ER_E17;TPCC_TPCC_ER_E18;TPCC_TPCC_ER_E19; TPCC_TPCC_ER_E20;TPCC_TPCC_ER_E21;TPCC_TPCC_ER_E22;TPCC_TPCC_ER_E23; TPCC_TPCC_ER_E24;TPCC_TPCC_ER_E25;TPCC_TPCC_ER_E26;TPCC_TPCC_ER_E27; TPCC_TPCC_ER_E28;TPCC_TPCC_ER_E29;TPCC_TPCC_ER_E30;TPCC_TPCC_ER_E31; <br />
 TPCC_TPCC_ERH_E32;TPCC_TPCC_ERH_E33;TPCC_TPCC_ERH_E34;TPCC_TPCC_ERH_E35; TPCC_TPCC_ERH_E36;TPCC_TPCC_ERH_E37;TPCC_TPCC_ERH_E38;TPCC_TPCC_ERH_E39; TPCC_TPCC_ERH_E40;TPCC_TPCC_ERH_E41;TPCC_TPCC_ERH_E42;TPCC_TPCC_ERH_E43; TPCC_TPCC_ERH_E44;TPCC_TPCC_ERH_E45;TPCC_TPCC_ERH_E46;TPCC_TPCC_ERH_E47; TPCC_TPCC_ERH_E48;TPCC_TPCC_ERH_E49;TPCC_TPCC_ERH_E50;TPCC_TPCC_ERH_E51; TPCC_TPCC_ERH_E52;TPCC_TPCC_ERH_E53;TPCC_TPCC_ERH_E54;TPCC_TPCC_ERH_E55; TPCC_TPCC_ERH_E56;TPCC_TPCC_ERH_E57;TPCC_TPCC_ERH_E58;TPCC_TPCC_ERH_E59; TPCC_TPCC_ERH_E60;TPCC_TPCC_ERH_E61;TPCC_TPCC_ERH_E62;TPCC_TPCC_ERH_E63;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    dmaStatus;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Determine if there is an event pending on DMA Channel 0.
         CSL_edma3IsDMAChannelEventPending(hModule, 0, &amp;dmaStatus);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaffc0bc1999aa69769ca9e33215d7c614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsDMAChannelMissedEventSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsDMAChannelMissedEventSet</b> </p>
<p><b>Description</b> <br />
 The API checks determines if there is a missed Event for a specific DMA channel</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     dmaChannel      DMA Channel to be checked
     response        This is populated by the API and returns TRUE if the
                     event was missed else it returns FALSE.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_EMR_EMR0;TPCC_TPCC_EMR_EMR1;TPCC_TPCC_EMR_EMR2; TPCC_TPCC_EMR_EMR3;TPCC_TPCC_EMR_EMR4;TPCC_TPCC_EMR_EMR5; TPCC_TPCC_EMR_EMR6;TPCC_TPCC_EMR_EMR7;TPCC_TPCC_EMR_EMR8; TPCC_TPCC_EMR_EMR9;TPCC_TPCC_EMR_EMR10;TPCC_TPCC_EMR_EMR11; TPCC_TPCC_EMR_EMR12;TPCC_TPCC_EMR_EMR13;TPCC_TPCC_EMR_EMR14; TPCC_TPCC_EMR_EMR15;TPCC_TPCC_EMR_EMR16;TPCC_TPCC_EMR_EMR17; TPCC_TPCC_EMR_EMR18;TPCC_TPCC_EMR_EMR19;TPCC_TPCC_EMR_EMR20; TPCC_TPCC_EMR_EMR21;TPCC_TPCC_EMR_EMR22;TPCC_TPCC_EMR_EMR23; TPCC_TPCC_EMR_EMR24;TPCC_TPCC_EMR_EMR25;TPCC_TPCC_EMR_EMR26; TPCC_TPCC_EMR_EMR27;TPCC_TPCC_EMR_EMR28;TPCC_TPCC_EMR_EMR29; TPCC_TPCC_EMR_EMR30;TPCC_TPCC_EMR_EMR31; TPCC_TPCC_EMRH_EMR32;TPCC_TPCC_EMRH_EMR33;TPCC_TPCC_EMRH_EMR34; TPCC_TPCC_EMRH_EMR35;TPCC_TPCC_EMRH_EMR36;TPCC_TPCC_EMRH_EMR37; TPCC_TPCC_EMRH_EMR38;TPCC_TPCC_EMRH_EMR39;TPCC_TPCC_EMRH_EMR40; TPCC_TPCC_EMRH_EMR41;TPCC_TPCC_EMRH_EMR42;TPCC_TPCC_EMRH_EMR43; TPCC_TPCC_EMRH_EMR44;TPCC_TPCC_EMRH_EMR45;TPCC_TPCC_EMRH_EMR46; TPCC_TPCC_EMRH_EMR47;TPCC_TPCC_EMRH_EMR48;TPCC_TPCC_EMRH_EMR49; TPCC_TPCC_EMRH_EMR50;TPCC_TPCC_EMRH_EMR51;TPCC_TPCC_EMRH_EMR52; TPCC_TPCC_EMRH_EMR53;TPCC_TPCC_EMRH_EMR54;TPCC_TPCC_EMRH_EMR55; TPCC_TPCC_EMRH_EMR56;TPCC_TPCC_EMRH_EMR57;TPCC_TPCC_EMRH_EMR58; TPCC_TPCC_EMRH_EMR59;TPCC_TPCC_EMRH_EMR60;TPCC_TPCC_EMRH_EMR61; TPCC_TPCC_EMRH_EMR62;TPCC_TPCC_EMRH_EMR63;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    missed;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Check if DMA Channel 1 has an event missed.
         CSL_edma3IsDMAChannelMissedEventSet(hModule, 1, &amp;missed);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad5d6bf46947c559ac464a2856209cd65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsDMAChannelSecondaryEventSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsDMAChannelSecondaryEventSet</b> </p>
<p><b>Description</b> <br />
 This API is used to determine if the secondary Event for a specific DMA channel is set or not?</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     dmaChannel      DMA Channel for which secondary Events are being checked
     response        Status of the check populated by the API (TRUE if event
                     is missed else FALSE)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_SER_SER0;TPCC_TPCC_SER_SER1;TPCC_TPCC_SER_SER2; TPCC_TPCC_SER_SER3;TPCC_TPCC_SER_SER4;TPCC_TPCC_SER_SER5; TPCC_TPCC_SER_SER6;TPCC_TPCC_SER_SER7;TPCC_TPCC_SER_SER8; TPCC_TPCC_SER_SER9;TPCC_TPCC_SER_SER10;TPCC_TPCC_SER_SER11; TPCC_TPCC_SER_SER12;TPCC_TPCC_SER_SER13;TPCC_TPCC_SER_SER14; TPCC_TPCC_SER_SER15;TPCC_TPCC_SER_SER16;TPCC_TPCC_SER_SER17; TPCC_TPCC_SER_SER18;TPCC_TPCC_SER_SER19;TPCC_TPCC_SER_SER20; TPCC_TPCC_SER_SER21;TPCC_TPCC_SER_SER22;TPCC_TPCC_SER_SER23; TPCC_TPCC_SER_SER24;TPCC_TPCC_SER_SER25;TPCC_TPCC_SER_SER26; TPCC_TPCC_SER_SER27;TPCC_TPCC_SER_SER28;TPCC_TPCC_SER_SER29; TPCC_TPCC_SER_SER30;TPCC_TPCC_SER_SER31; <br />
 TPCC_TPCC_SERH_SER32;TPCC_TPCC_SERH_SER33;TPCC_TPCC_SERH_SER34; TPCC_TPCC_SERH_SER35;TPCC_TPCC_SERH_SER36;TPCC_TPCC_SERH_SER37; TPCC_TPCC_SERH_SER38;TPCC_TPCC_SERH_SER39;TPCC_TPCC_SERH_SER40; TPCC_TPCC_SERH_SER41;TPCC_TPCC_SERH_SER42;TPCC_TPCC_SERH_SER43; TPCC_TPCC_SERH_SER44;TPCC_TPCC_SERH_SER45;TPCC_TPCC_SERH_SER46; TPCC_TPCC_SERH_SER47;TPCC_TPCC_SERH_SER48;TPCC_TPCC_SERH_SER49; TPCC_TPCC_SERH_SER50;TPCC_TPCC_SERH_SER51;TPCC_TPCC_SERH_SER52; TPCC_TPCC_SERH_SER53;TPCC_TPCC_SERH_SER54;TPCC_TPCC_SERH_SER55; TPCC_TPCC_SERH_SER56;TPCC_TPCC_SERH_SER57;TPCC_TPCC_SERH_SER58; TPCC_TPCC_SERH_SER59;TPCC_TPCC_SERH_SER60;TPCC_TPCC_SERH_SER61; TPCC_TPCC_SERH_SER62;TPCC_TPCC_SERH_SER63;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    response;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Check if the DMA Channel 1 Secondary Event is set or not? 
         CSL_edma3IsDMAChannelSecondaryEventSet(hModule, 1, &amp;response);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa5bd1589917a92b8de77a997811706a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsQDMAChannelEventPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsQDMAChannelEventPending</b> </p>
<p><b>Description</b> <br />
 The function gets the status of the specified QDMA channel i.e. if there is a pending event on the specific channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel for which status is being inquired.
     response        Place holder for whether an event is set(TRUE) or not (FALSE)</pre><p><b> Return Value </b> <br />
 None.</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QER_QER0;TPCC_TPCC_QER_QER1;TPCC_TPCC_QER_QER2;TPCC_TPCC_QER_QER3; TPCC_TPCC_QER_QER4;TPCC_TPCC_QER_QER5;TPCC_TPCC_QER_QER6;TPCC_TPCC_QER_QER7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    qdmaStatus;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Is QDMA Channel 1 event pending.
         CSL_edma3IsQDMAChannelEventPending(hModule, 1, &amp;qdmaStatus);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga64c32de61c3988315043e6476ed3a3a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsQDMAChannelMissedEventSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsQDMAChannelMissedEventSet</b> </p>
<p><b>Description</b> <br />
 The API checks determines if there is a missed Event for a specific DMA channel</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel to be checked
     response        This is populated by the API and returns TRUE if the
                     event was missed else it returns FALSE.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QEMR_QEMR0;TPCC_TPCC_QEMR_QEMR1;TPCC_TPCC_QEMR_QEMR2; TPCC_TPCC_QEMR_QEMR3;TPCC_TPCC_QEMR_QEMR4;TPCC_TPCC_QEMR_QEMR5; TPCC_TPCC_QEMR_QEMR6;TPCC_TPCC_QEMR_QEMR7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    missed;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Check if DMA Channel 0 has an event missed.
         CSL_edma3IsQDMAChannelMissedEventSet(hModule, 0, &amp;missed);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0d26ed086c003ea5942764bc83639326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3IsQDMAChannelSecondaryEventSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3IsDMAChannelSecondaryEventSet</b> </p>
<p><b>Description</b> <br />
 This API is used to determine if the secondary Event for a specific DMA channel is set or not?</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     qdmaChannel     QDMA Channel for which secondary Events are being checked
     response        Status of the check populated by the API (TRUE if event
                     is missed else FALSE)</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TPCC_TPCC_QSER_QSER0;TPCC_TPCC_QSER_QSER1;TPCC_TPCC_QSER_QSER2; TPCC_TPCC_QSER_QSER3;TPCC_TPCC_QSER_QSER4;TPCC_TPCC_QSER_QSER5; TPCC_TPCC_QSER_QSER6;TPCC_TPCC_QSER_QSER7;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;
         Bool                    response;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Check if the QDMA Channel 1 Secondary Event is set or not? 
         CSL_edma3IsQDMAChannelSecondaryEventSet(hModule, 1, &amp;response);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac9d5fa3b6f36d2e9dc63c4dc3412f0f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapDMAChannelToEventQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapDMAChannelToEventQueue</b> </p>
<p><b>Description</b> <br />
 The function maps the event ID to the specific DMA Queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     dmaChannel  DMA Channel to which the event is mapped.
     eventQueue  Event Queue which is to be mapped.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 DMA Channel is mapped to the specified Event Queue.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DMAQNUM_E0;TPCC_TPCC_DMAQNUM_E1;TPCC_TPCC_DMAQNUM_E2; TPCC_TPCC_DMAQNUM_E3;TPCC_TPCC_DMAQNUM_E4;TPCC_TPCC_DMAQNUM_E5; TPCC_TPCC_DMAQNUM_E6;TPCC_TPCC_DMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps DMA Channel 1 to Event Queue 2
         CSL_edma3MapDMAChannelToEventQueue(hModule, 1, 2);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga57e8100aa3db1c61e789d74fb992e4a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapDMAChannelToParamBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>paramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapDMAChannelToParamBlock</b> </p>
<p><b>Description</b> <br />
 The function maps the DMA Channel to the specified PARAM Entry Block.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     dmaChannel  DMA Channel Number which is to be mapped.
     paramId     Parameter Identifier to be mapped to.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 DMA Channel is mapped to the specified PARAM Block.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_DCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps DMA Channel 1 to Param ID Block 5.
         CSL_edma3MapDMAChannelToParamBlock(hModule, 1, 5);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6d1b866c3c23f1c1f7970f9b5fbc5e6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapEventQueueToTC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>tcNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapEventQueueToTC</b> </p>
<p><b>Description</b> <br />
 The function maps the event queue to a specific TC</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle        
     eventQueue  Event Queue which is to be mapped.
     tcNum       TC to which the queue is to be mapped to.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Event Queue is mapped to the specific TC</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QUETCMAP_TCNUMQ0;TPCC_TPCC_QUETCMAP_TCNUMQ1;TPCC_TPCC_QUETCMAP_TCNUMQ2; TPCC_TPCC_QUETCMAP_TCNUMQ3;TPCC_TPCC_QUETCMAP_TCNUMQ4;TPCC_TPCC_QUETCMAP_TCNUMQ5; TPCC_TPCC_QUETCMAP_TCNUMQ6;TPCC_TPCC_QUETCMAP_TCNUMQ7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps Event Queue 1 to TC0
         CSL_edma3MapEventQueueToTC(hModule, 1, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa6e2fe8687852b8d640cfbf72e34d07a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapQDMAChannelToEventQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapQDMAChannelToEventQueue</b> </p>
<p><b>Description</b> <br />
 The function maps the event ID to the specific DMA Queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel to which the event is mapped.
     eventQueue  Event Queue which is to be mapped.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 DMA Channel is mapped to the specified Event Queue.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QDMAQNUM_E0;TPCC_TPCC_QDMAQNUM_E1;TPCC_TPCC_QDMAQNUM_E2; TPCC_TPCC_QDMAQNUM_E3;TPCC_TPCC_QDMAQNUM_E4;TPCC_TPCC_QDMAQNUM_E5; TPCC_TPCC_QDMAQNUM_E6;TPCC_TPCC_QDMAQNUM_E7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps QDMA Channel 1 to Event Queue 2
         CSL_edma3MapQDMAChannelToEventQueue(hModule, 1, 2);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0e25de939e1bcb1f714be5378058d9a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MapQDMAChannelToParamBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>paramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MapQDMAChannelToParamBlock</b> </p>
<p><b>Description</b> <br />
 The function maps the QDMA Channel to the specified PARAM Entry Block.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel Number which is to be mapped.
     paramId     Parameter Identifier to be mapped to.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 QDMA Channel is mapped to the specified PARAM Block.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QCHMAP_PAENTRY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps QDMA Channel 1 to Param ID Block 5.
         CSL_edma3MapQDMAChannelToParamBlock(hModule, 1, 5);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8c24483db8373f8e4b8eae0a9ad295ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3MemFaultClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3MemFaultClear</b> </p>
<p><b>Description</b> <br />
 The function clears the memory fault.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_MPFCR_MPFCLR=1</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Clear the memory protection fault 
         CSL_edma3MemFaultClear(hModule);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0b7e551e286eabb426729fcc8221eb87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a> CSL_edma3Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga5ec70099d6fe560fcbc690e5501f92b7">CSL_Edma3Obj</a> *&#160;</td>
          <td class="paramname"><em>pEdmaObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_InstNum&#160;</td>
          <td class="paramname"><em>edmaNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#gaaf0feb95229cadc3595103d84bae27bf">CSL_Edma3ModuleAttr</a> *&#160;</td>
          <td class="paramname"><em>pAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3Open</b> </p>
<p><b>Description</b> <br />
 This function returns the handle to the EDMA instance. This handle is passed to all other CSL APIs.</p>
<p><b>Arguments</b> </p><pre class="fragment">         pEdmaObj         EDMA Module Object pointer 
         edmaNum          Instance of EDMA                             
         pAttr            EDMA Attribute pointer 
         pStatus          Status of the function call</pre><p><b> Return Value </b> <br />
 Success - Valid Edma handle will be returned if status value is equal to CSL_SOK. <br />
 Failure - NULL</p>
<p><b> Pre Condition </b> <br />
 The EDMA must be succesfully initialized via <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a> before calling this function.</p>
<p><b> Post Condition </b> <br />
 1. The status is returned in the status variable. If status returned is </p><ul>
<li>CSL_SOK Valid EDMA handle is returned </li>
<li>CSL_ESYS_FAIL The EDMA instance is invalid </li>
<li>CSL_ESYS_INVPARAMS The Parameter passed is invalid <pre class="fragment">2. Edma object structure is populated
</pre></li>
</ul>
<p><b>Affects</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle     hModule;
         CSL_Edma3Obj        edmaObj;
         CSL_Status          status;
         
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga168d4c4967d21076a562f6777d281a9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3ParamSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga37e63265093e9e1a45c9e8b31f8608bd">CSL_Edma3ParamHandle</a>&#160;</td>
          <td class="paramname"><em>hParamHndl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga2c16ecb5df5dd2fe4c2fc8757bb7b61e">CSL_Edma3ParamSetup</a> *&#160;</td>
          <td class="paramname"><em>setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ParamSetup</b> </p>
<p><b>Description</b> <br />
 The function is used to configure the PARAM Entry block with the specific parameter information.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hParamHndl      Handle to the param entry
         setup           Pointer to param setup structure</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> must be called successfully in that order before this API can be invoked</p>
<p><b> Post Condition </b> <br />
 Configures the EDMA parameter Entry</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Status              status;
         CSL_Edma3ChannelHandle  hChannel;
         CSL_Edma3ChannelAttr    chAttr;
         CSL_Edma3ParamHandle    hParamBasic;
         CSL_Edma3ParamSetup     myParamSetup;
         
         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Open DMA Channel 1.
         chAttr.regionNum = CSL_EDMA3_REGION_GLOBAL;
         chAttr.chaNum    = 1;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         if ((hChannel == NULL) || (status != CSL_SOK)) 
         {
             printf ("Error: Unable to open EDMA Channel:%d\n", channelNum);
             return -1;
         }
         ...
         // Obtain a handle to PARAM Entry 0
         hParamBasic = CSL_edma3GetParamHandle(hChannel,0,&amp;status);
         ...
         // Setup the first param Entry (Ping buffer) 
         myParamSetup.option = CSL_EDMA3_OPT_MAKE(CSL_EDMA3_ITCCH_DIS, \
                                                  CSL_EDMA3_TCCH_DIS, \
                                                  CSL_EDMA3_ITCINT_DIS, \
                                                  CSL_EDMA3_TCINT_EN,\
                                                  0,CSL_EDMA3_TCC_NORMAL,\
                                                  CSL_EDMA3_FIFOWIDTH_NONE, \
                                                  CSL_EDMA3_STATIC_DIS, \
                                                  CSL_EDMA3_SYNC_A, \
                                                  CSL_EDMA3_ADDRMODE_INCR, \
                                                  CSL_EDMA3_ADDRMODE_INCR);           
         myParamSetup.srcAddr     = (Uint32)srcBuff1;         
         myParamSetup.aCntbCnt    = CSL_EDMA3_CNT_MAKE(256,1);       
         myParamSetup.dstAddr     = (Uint32)dstBuff1;        
         myParamSetup.srcDstBidx  = CSL_EDMA3_BIDX_MAKE(1,1);     
         myParamSetup.linkBcntrld = CSL_EDMA3_LINKBCNTRLD_MAKE(CSL_EDMA3_LINK_NULL,0);     
         myParamSetup.srcDstCidx  = CSL_EDMA3_CIDX_MAKE(0,1);     
         myParamSetup.cCnt        = 1;

         // Configure the PARAM Entry with the setup information. 
         CSL_edma3ParamSetup(hParamBasic,&amp;myParamSetup);     
         ... </pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8387a3b68b4bc948580e0a1d301d66dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_edma3ParamWriteWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga37e63265093e9e1a45c9e8b31f8608bd">CSL_Edma3ParamHandle</a>&#160;</td>
          <td class="paramname"><em>hParamHndl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>wordOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3ParamWriteWord</b> </p>
<p><b>Description</b> <br />
 This is for the ease of QDMA channels. Once the QDMA channel transfer is triggered, subsequent triggers may be done with only writing the modified words in the parameter entry along with the trigger word. This API is expected to achieve this purpose. Most usage scenarios, the user should not be writing more than the trigger word entry.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hParamHndl      Handle to the param entry
         wordOffset      word offset in the 8 word paramater entry
         word            word to be written</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK (Param Write Word successful) <br />
 Error - CSL_ESYS_BADHANDLE (Invalid handle)</p>
<p><b> Pre Condition </b> <br />
 <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a> and <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga59eef2276ba2cff959cc46a11b190a22">CSL_edma3ChannelOpen()</a> and must be <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga9c954b177f482c066efddbbc3627ffad">CSL_edma3GetParamHandle()</a>, <a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga168d4c4967d21076a562f6777d281a9b">CSL_edma3ParamSetup()</a> called successfully in that order before this API can be invoked. The main setup structure consists of pointers to sub-structures.The user has to allocate space for &amp; fill in the parameter setup structure.</p>
<p><b> Post Condition </b> <br />
 Configure trigger word</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Status              status;
         CSL_Edma3ChannelHandle  hChannel;
         CSL_Edma3ChannelAttr    chAttr;
         CSL_Edma3ParamHandle    hParamBasic;

         // Module Initialization
         CSL_edma3Init(NULL);
         
         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);

         // Open DMA Channel 1.
         chAttr.regionNum = CSL_EDMA3_REGION_GLOBAL;
         chAttr.chaNum    = 1;
         hChannel = CSL_edma3ChannelOpen(&amp;chObj, 0, &amp;chAttr, &amp;status);
         if ((hChannel == NULL) || (status != CSL_SOK)) 
         {
             printf ("Error: Unable to open EDMA Channel:%d\n", channelNum);
             return -1;
         }
         ...
         // Obtain a handle to PARAM Entry 0
         hParamBasic = CSL_edma3GetParamHandle(hChannel,0,&amp;status);
         ...
         // Write trigger word
         CSL_edma3ParamWriteWord(hParamBasic, 7, myParamSetup.cCnt);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gace982cddeda1d0afd516524cc4906756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3QDMAChannelDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3QDMAChannelDisable</b> </p>
<p><b>Description</b> <br />
 This API disables the specified QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadown Region or Global)
     qdmaChannel     QDMA Channel to be disabled. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QEECR_QEECR0=1;TPCC_TPCC_QEECR_QEECR1=1;TPCC_TPCC_QEECR_QEECR2=1; TPCC_TPCC_QEECR_QEECR3=1;TPCC_TPCC_QEECR_QEECR4=1;TPCC_TPCC_QEECR_QEECR5=1; TPCC_TPCC_QEECR_QEECR6=1;TPCC_TPCC_QEECR_QEECR7=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
       
         // Disables QDMA Channel 0
         CSL_edma3QDMAChannelDisable(hModule, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga18cbdd27ffd1b507768f64a22758323c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3QDMAChannelEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3QDMAChannelEnable</b> </p>
<p><b>Description</b> <br />
 This API enables the specified QDMA Channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadown Region or Global)
     qdmaChannel     QDMA Channel to be enabled. </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QEESR_QEESR0=1;TPCC_TPCC_QEESR_QEESR1=1;TPCC_TPCC_QEESR_QEESR2=1; TPCC_TPCC_QEESR_QEESR3=1;TPCC_TPCC_QEESR_QEESR4=1;TPCC_TPCC_QEESR_QEESR5=1; TPCC_TPCC_QEESR_QEESR6=1;TPCC_TPCC_QEESR_QEESR7=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
       
         // Enables QDMA Channel 1 for Global Region.
         CSL_edma3QDMAChannelEnable(hModule, CSL_EDMA3_REGION_GLOBAL, 1);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1253d6e8d81dd6370fdbea203f62718c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3QdmaRegionAccessDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>edmaRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>qrae</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3QdmaRegionAccessDisable</b> </p>
<p><b>Description</b> <br />
 This API disables read/write access to the shadow regions for the specific QDMA channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle        
     edmaRegion        Shadow Region.                          
     qrae              Bitmask to be enabled in QRAE</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QRAE_E0=0;TPCC_TPCC_QRAE_E1=0;TPCC_TPCC_QRAE_E2=0; TPCC_TPCC_QRAE_E3=0;TPCC_TPCC_QRAE_E4=0;TPCC_TPCC_QRAE_E5=0; TPCC_TPCC_QRAE_E6=0;TPCC_TPCC_QRAE_E7=0</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Disable read/write access in Region 0 for QDMA 0 to 3
         CSL_edma3QdmaRegionAccessDisable(hModule, 0, 0x0000000F);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1c8815957d655fd903f7ff29719bfee5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3QdmaRegionAccessEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>edmaRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>qrae</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3QdmaRegionAccessEnable</b> </p>
<p><b>Description</b> <br />
 This API enables read/write access to the shadow regions for the specific QDMA channels.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule           Module Handle
     edmaRegion        Shadow Region
     qrae              Bitmask to be enabled in QRAE</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QRAE_E0=1;TPCC_TPCC_QRAE_E1=1;TPCC_TPCC_QRAE_E2=1; TPCC_TPCC_QRAE_E3=1;TPCC_TPCC_QRAE_E4=1;TPCC_TPCC_QRAE_E5=1; TPCC_TPCC_QRAE_E6=1;TPCC_TPCC_QRAE_E7=1</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
      
         // Enable read/write access in Region 0 for QDMA 0 to 3
         CSL_edma3QdmaRegionAccessEnable(hModule, 0, 0x0000000F);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab6b71a3e6c8bb5938e759d7abb1c071c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3SetDMAChannelEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>dmaChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3SetDMAChannelEvent</b> </p>
<p><b>Description</b> <br />
 This API sets the event for the specific DMA channel.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region (Shadow or Global)
     dmaChannel      DMA Channel for which the event is to be set</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_ESR_E0=1;TPCC_TPCC_ESR_E1=1;TPCC_TPCC_ESR_E2=1;TPCC_TPCC_ESR_E3=1; TPCC_TPCC_ESR_E4=1;TPCC_TPCC_ESR_E5=1;TPCC_TPCC_ESR_E6=1;TPCC_TPCC_ESR_E7=1; TPCC_TPCC_ESR_E8=1;TPCC_TPCC_ESR_E9=1;TPCC_TPCC_ESR_E10=1;TPCC_TPCC_ESR_E11=1; TPCC_TPCC_ESR_E12=1;TPCC_TPCC_ESR_E13=1;TPCC_TPCC_ESR_E14=1;TPCC_TPCC_ESR_E15=1; TPCC_TPCC_ESR_E16=1;TPCC_TPCC_ESR_E17=1;TPCC_TPCC_ESR_E18=1;TPCC_TPCC_ESR_E19=1; TPCC_TPCC_ESR_E20=1;TPCC_TPCC_ESR_E21=1;TPCC_TPCC_ESR_E22=1;TPCC_TPCC_ESR_E23=1; TPCC_TPCC_ESR_E24=1;TPCC_TPCC_ESR_E25=1;TPCC_TPCC_ESR_E26=1;TPCC_TPCC_ESR_E27=1; TPCC_TPCC_ESR_E28=1;TPCC_TPCC_ESR_E29=1;TPCC_TPCC_ESR_E30=1;TPCC_TPCC_ESR_E31=1; <br />
 TPCC_TPCC_ESRH_E32=1;TPCC_TPCC_ESRH_E33=1;TPCC_TPCC_ESRH_E34=1;TPCC_TPCC_ESRH_E35=1; TPCC_TPCC_ESRH_E36=1;TPCC_TPCC_ESRH_E37=1;TPCC_TPCC_ESRH_E38=1;TPCC_TPCC_ESRH_E39=1; TPCC_TPCC_ESRH_E40=1;TPCC_TPCC_ESRH_E41=1;TPCC_TPCC_ESRH_E42=1;TPCC_TPCC_ESRH_E43=1; TPCC_TPCC_ESRH_E44=1;TPCC_TPCC_ESRH_E45=1;TPCC_TPCC_ESRH_E46=1;TPCC_TPCC_ESRH_E47=1; TPCC_TPCC_ESRH_E48=1;TPCC_TPCC_ESRH_E49=1;TPCC_TPCC_ESRH_E50=1;TPCC_TPCC_ESRH_E51=1; TPCC_TPCC_ESRH_E52=1;TPCC_TPCC_ESRH_E53=1;TPCC_TPCC_ESRH_E54=1;TPCC_TPCC_ESRH_E55=1; TPCC_TPCC_ESRH_E56=1;TPCC_TPCC_ESRH_E57=1;TPCC_TPCC_ESRH_E58=1;TPCC_TPCC_ESRH_E59=1; TPCC_TPCC_ESRH_E60=1;TPCC_TPCC_ESRH_E61=1;TPCC_TPCC_ESRH_E62=1;TPCC_TPCC_ESRH_E63=1;</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Set the DMA Channel 0 Event for the Global Region. 
         CSL_edma3SetDMAChannelEvent(hModule, CSL_EDMA3_REGION_GLOBAL, 0);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5ad8668228a1584b1201fa63e94d2498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3SetEventQueuePriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>eventQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3SetEventQueuePriority</b> </p>
<p><b>Description</b> <br />
 The function sets the priority of the specific event queue.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle        
     eventQueue  Event Queue whose priority is to be configured.
     priority    Priority to be configured.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Event Queue is configured to the specific priority.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QUEPRI_PRIQ0;TPCC_TPCC_QUEPRI_PRIQ1;TPCC_TPCC_QUEPRI_PRIQ2; TPCC_TPCC_QUEPRI_PRIQ3;TPCC_TPCC_QUEPRI_PRIQ4;TPCC_TPCC_QUEPRI_PRIQ5; TPCC_TPCC_QUEPRI_PRIQ6;TPCC_TPCC_QUEPRI_PRIQ7</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;            

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Maps Event Queue 2 to Priority 4 
         CSL_edma3SetEventQueuePriority(hModule, 2, 4);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga59c5d18de6e596e42437199c3601b881"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3SetMemoryProtectionAttrib </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_BitMask32&#160;</td>
          <td class="paramname"><em>mppa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3SetMemoryProtectionAttrib</b> </p>
<p><b>Description</b> <br />
 This API sets the memory protection attributes for the specified region.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule         Module Handle
     region          Region being configured.                          
     mpa             Value to be programmed into the MPPAG/MPPA[0/1/2/../n]
                     This is a Bitmask of the protection attributes.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_MPPAG;TPCC_TPCC_MPPA</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);
         
         // Module Level Open    
         hModule = CSL_edma3Open(&amp;edmaObj,CSL_EDMA3,NULL,&amp;status);
         ...
         // Set the memory protection attributes of region 0. 
         CSL_edma3SetMemoryProtectionAttrib (hModule, 0, CSL_EDMA3_MEMACCESS_UX |
                                                         CSL_EDMA3_MEMACCESS_UW |
                                                         CSL_EDMA3_MEMACCESS_UR |
                                                         CSL_EDMA3_MEMACCESS_AID2));
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6f7627ac0aea91aa666b330d01c51e1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_edma3SetQDMATriggerWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___e_d_m_a3___d_a_t_a_s_t_r_u_c_t.html#ga16a76d6128e9f20799bc5d8e9f341c2c">CSL_Edma3Handle</a>&#160;</td>
          <td class="paramname"><em>hModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>qdmaChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>trword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_edma3SetQDMATriggerWord</b> </p>
<p><b>Description</b> <br />
 The function sets the trigger word of the PaRAM Entry block.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hModule     Module Handle
     qdmaChannel QDMA Channel Number which is to be configured.
     trword      Trigger Word to be configured.</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga588ede6cd00b9ae480f847010a9433e8">CSL_edma3Init()</a></em> and <em><a class="el" href="group___c_s_l___e_d_m_a3___f_u_n_c_t_i_o_n.html#ga0b7e551e286eabb426729fcc8221eb87">CSL_edma3Open()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 QDMA Channel is mapped to the specified PARAM Block.</p>
<p><b>Writes</b> <br />
 TPCC_TPCC_QCHMAP_TRWORD</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_Edma3Handle         hModule;
         CSL_Edma3Obj            edmaObj;
         CSL_Edma3Context        context;
         CSL_Status              status;

         // Module Initialization
         CSL_edma3Init(&amp;context);

         // Module Level Open
         hModule = CSL_edma3Open(&amp;edmaObj, CSL_EDMA3, NULL, &amp;status);

         // Configure QDMA Channel 1 Trigger Word as 0
         CSL_edma3SetQDMATriggerWord(hModule, 1, 0);
         ...</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
