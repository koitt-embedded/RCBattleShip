<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TAC2 Back-End Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TAC2 Back-End Functions<div class="ingroups"><a class="el" href="group___c_s_l___t_a_c___b_e___a_p_i.html">TAC2 Back-End</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafef394ca245d3a0cd7c10bf7031a789b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gafef394ca245d3a0cd7c10bf7031a789b">CSL_TAC_BETI_enable</a> (void)</td></tr>
<tr class="separator:gafef394ca245d3a0cd7c10bf7031a789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd58e4c944c47bd7f517f46f281b46c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gacd58e4c944c47bd7f517f46f281b46c8">CSL_TAC_BETI_disable</a> (void)</td></tr>
<tr class="separator:gacd58e4c944c47bd7f517f46f281b46c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae753f6775b1d3cef3c82a9107386b58b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___t_a_c___b_e___e_n_u_m.html#gab608f12d78c2580d87b0fefc5650a1b8">CSL_TAC_BETI_enableStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gae753f6775b1d3cef3c82a9107386b58b">CSL_TAC_BETI_getEnableStatus</a> (void)</td></tr>
<tr class="separator:gae753f6775b1d3cef3c82a9107386b58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b92ff6a8d2e87d93ff71e18586cfe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gad1b92ff6a8d2e87d93ff71e18586cfe6">CSL_TAC_BETI_getStatus</a> (<a class="el" href="struct_c_s_l___t_a_c___b_e_t_i__status.html">CSL_TAC_BETI_status</a> *betiStatus)</td></tr>
<tr class="separator:gad1b92ff6a8d2e87d93ff71e18586cfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1d31d95382fc6bb4e2498b6419fe65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga8b1d31d95382fc6bb4e2498b6419fe65">CSL_TAC_BETI_setWatchDog</a> (Uint16 reloadCnt)</td></tr>
<tr class="separator:ga8b1d31d95382fc6bb4e2498b6419fe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5a9fa9087ce2db4f51356fb74d86d6"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga9b5a9fa9087ce2db4f51356fb74d86d6">CSL_TAC_BETI_getWatchDogStatus</a> (void)</td></tr>
<tr class="separator:ga9b5a9fa9087ce2db4f51356fb74d86d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c82a554e91f21bad99409fc1a6cefd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___t_a_c___b_e___e_n_u_m.html#ga95bfb8a12e8c4310fb298f3d778a3e8d">CSL_TAC_BETI_wdInterruptStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gae2c82a554e91f21bad99409fc1a6cefd">CSL_TAC_BETI_getWatchDogInterruptStatus</a> (void)</td></tr>
<tr class="separator:gae2c82a554e91f21bad99409fc1a6cefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga614a81d3aa810a4e9081524d0677a8e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga614a81d3aa810a4e9081524d0677a8e0">CSL_TAC_BETI_clearWatchDogInterrupt</a> (void)</td></tr>
<tr class="separator:ga614a81d3aa810a4e9081524d0677a8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf136d8cd531e17805d9855ff3657fec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gaf136d8cd531e17805d9855ff3657fec1">CSL_TAC_BEII_enable</a> (void)</td></tr>
<tr class="separator:gaf136d8cd531e17805d9855ff3657fec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a89928a340c7c959eadbf3432da8aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga11a89928a340c7c959eadbf3432da8aa">CSL_TAC_BEII_disable</a> (void)</td></tr>
<tr class="separator:ga11a89928a340c7c959eadbf3432da8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3037d9a69563bfa5ae184e2d31876827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___t_a_c___b_e___e_n_u_m.html#gacc533d3dfa44036e6040dedaf6fce925">CSL_TAC_BEII_enableStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga3037d9a69563bfa5ae184e2d31876827">CSL_TAC_BEII_getEnableStatus</a> (void)</td></tr>
<tr class="separator:ga3037d9a69563bfa5ae184e2d31876827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e2cd9e7351d0a6497b8d4c227b35722"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga7e2cd9e7351d0a6497b8d4c227b35722">CSL_TAC_BEII_getInterruptStatus</a> (<a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *interruptStatus)</td></tr>
<tr class="separator:ga7e2cd9e7351d0a6497b8d4c227b35722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3093b94a5167af86c38addf02a3cbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gaaa3093b94a5167af86c38addf02a3cbc">CSL_TAC_BEII_getEnabledInterruptStatus</a> (<a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *interruptEnStatus)</td></tr>
<tr class="separator:gaaa3093b94a5167af86c38addf02a3cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf80021d6e1eee21729b39bac0a051a8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gaf80021d6e1eee21729b39bac0a051a8d">CSL_TAC_BEII_forceInterrupts</a> (const <a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *interruptsToForce)</td></tr>
<tr class="separator:gaf80021d6e1eee21729b39bac0a051a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a652ebc6c82cd5ab93e26253133eaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga64a652ebc6c82cd5ab93e26253133eaa">CSL_TAC_BEII_clearInterrupts</a> (const <a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *interruptsToClear)</td></tr>
<tr class="separator:ga64a652ebc6c82cd5ab93e26253133eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51223c7105755dcabd6cea503bfdd5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga51223c7105755dcabd6cea503bfdd5b8">CSL_TAC_BEII_enableInterrupts</a> (const <a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *interruptsToEnable)</td></tr>
<tr class="separator:ga51223c7105755dcabd6cea503bfdd5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac190b402bfaf404cedcdcc4dbf072498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gac190b402bfaf404cedcdcc4dbf072498">CSL_TAC_BEII_disableInterrupts</a> (const <a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *interruptsToDisable)</td></tr>
<tr class="separator:gac190b402bfaf404cedcdcc4dbf072498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709b49aee5d1afc4f17e53ee0fc9105e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga709b49aee5d1afc4f17e53ee0fc9105e">CSL_TAC_BEII_setEOI</a> (Uint32 eoiVecValue)</td></tr>
<tr class="separator:ga709b49aee5d1afc4f17e53ee0fc9105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab134a8f64a686ffdcb18602b914fe19b"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gab134a8f64a686ffdcb18602b914fe19b">CSL_TAC_BEII_getEOI</a> (void)</td></tr>
<tr class="separator:gab134a8f64a686ffdcb18602b914fe19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba44c75470b69e13ff77951656d7fd5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___t_a_c___b_e___e_n_u_m.html#ga211152c7049be88c233edf9490697f5a">CSL_TAC_BE_strmPwrMeasMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gaba44c75470b69e13ff77951656d7fd5c">CSL_TAC_BE_getStrmPwrMeasMode</a> (void)</td></tr>
<tr class="separator:gaba44c75470b69e13ff77951656d7fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5250d9842afdaf68a4496ed4507fb72c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga5250d9842afdaf68a4496ed4507fb72c">CSL_TAC_BE_setSwIterStart</a> (void)</td></tr>
<tr class="separator:ga5250d9842afdaf68a4496ed4507fb72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1ae2a651e95adbbd3e8aeb63f24349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga8f1ae2a651e95adbbd3e8aeb63f24349">CSL_TAC_BE_setTimestamp</a> (const <a class="el" href="struct_c_s_l___t_a_c___b_e___timestamp__req.html">CSL_TAC_BE_Timestamp_req</a> *timestamp)</td></tr>
<tr class="separator:ga8f1ae2a651e95adbbd3e8aeb63f24349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1d94495118677a9b939dfc585a328e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#gaae1d94495118677a9b939dfc585a328e">CSL_TAC_BE_getTimestamp</a> (<a class="el" href="struct_c_s_l___t_a_c___b_e___timestamp__req.html">CSL_TAC_BE_Timestamp_req</a> *timestamp)</td></tr>
<tr class="separator:gaae1d94495118677a9b939dfc585a328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaba44c75470b69e13ff77951656d7fd5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___t_a_c___b_e___e_n_u_m.html#ga211152c7049be88c233edf9490697f5a">CSL_TAC_BE_strmPwrMeasMode</a> CSL_TAC_BE_getStrmPwrMeasMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BE_getStrmPwrMeasMode</b> </p>
<p><b>Description</b> <br />
 This function returns the accumulation mode used for the stream power measurement.</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 CSL_TAC_BE_strmPwrMeasMode_SlotMode The accumulation length is 1 slot (2560 chips) <br />
 CSL_TAC_BE_strmPwrMeasMode_SymbolMode The accumulation length is 1 symbol (256 chips)</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BETI_SPC_ACC_MODE</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BE_strmPwrMeasMode measMode;

measMode = CSL_TAC_BE_getStrmPwrMeasMode();
</pre> 
</div>
</div>
<a class="anchor" id="gaae1d94495118677a9b939dfc585a328e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BE_getTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___t_a_c___b_e___timestamp__req.html">CSL_TAC_BE_Timestamp_req</a> *&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BE_getTimestamp</b> </p>
<p><b>Description</b> <br />
 This function reads the Back End Timestamp register.</p>
<p><b>Arguments</b> </p><pre class="fragment">timestamp       Structure with timestamp parameters.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_DATA_BE_TIME_CHIP, TAC_DATA_BE_TIME_SLOT, TAC_DATA_BE_TIME_FRAME</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BE_Timestamp_req   timestamp;

CSL_TAC_BE_getTimestamp(&amp;timestamp);
</pre> 
</div>
</div>
<a class="anchor" id="ga5250d9842afdaf68a4496ed4507fb72c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BE_setSwIterStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BE_setSwIterStart</b> </p>
<p><b>Description</b> <br />
 This function enables the Software to bypass the HW iteration start line and triggers one iteration processing on each SGCP.</p>
<p>This function should be used only for debugging purposes.</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The HW iteration start line is bypassed. After this point the iteration processing can be triggered only by subsequent calls to <em><a class="el" href="group___c_s_l___t_a_c___b_e___f_u_n_c_t_i_o_n.html#ga5250d9842afdaf68a4496ed4507fb72c">CSL_TAC_BE_setSwIterStart()</a></em> API.</p>
<p>To take the HW out of this mode the application needs to issue a a device reset using <em><a class="el" href="group___c_s_l___t_a_c___f_e___f_u_n_c_t_i_o_n.html#ga1da1001052392fe5642cab49e729e92c">CSL_TAC_FE_softwareReset()</a></em> API.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BETI_SW_ITE_START_ITE_START=1</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BE_Timestamp_req   timestamp;
Uint16  frame = 0;
Uint16  chip  = 0;
Uint8   slot  = 0;
Uint16  numIter;

// Repeat for 640 iterations
for (numIter = 0; numIter &lt; 640; numIter++)
{
    // Set the time stamp in the HW
    timestamp.chipId  = chip;
    timestamp.slotId  = slot;
    timestamp.frameId = frame;

    CSL_TAC_BE_setTimestamp(&amp;timestamp);

    // Trigger 1 iteration worth of processing
    CSL_TAC_BE_setSwIterStart();

    ...
    // Increment the chip by 1 iteration (i.e. 4 chips)
    chip += 4;

    // Check for the slot boundary
    if (chip == 2560)
    {
        // Check for the frame boundary
        if (++slot == 15)
        {
            slot = 0;

            // Check for the super frame wrap
            frame = (frame + 1) &amp; 4095;
        }
    }
}
</pre> 
</div>
</div>
<a class="anchor" id="ga8f1ae2a651e95adbbd3e8aeb63f24349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BE_setTimestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___t_a_c___b_e___timestamp__req.html">CSL_TAC_BE_Timestamp_req</a> *&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BE_setTimestamp</b> </p>
<p><b>Description</b> <br />
 This function configures the Back End Timestamp register.</p>
<p><b>Arguments</b> </p><pre class="fragment">timestamp       Structure with timestamp parameters.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The Back-End Timestamp register is set.</p>
<p><b>Writes</b> <br />
 TAC_DATA_BE_TIME_CHIP, TAC_DATA_BE_TIME_SLOT, TAC_DATA_BE_TIME_FRAME</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BE_Timestamp_req   timestamp;

timestamp.chipId  = 8;
timestamp.slotId  = 3;
timestamp.frameId = 6;

CSL_TAC_BE_setTimestamp(&amp;timestamp);
</pre> 
</div>
</div>
<a class="anchor" id="ga64a652ebc6c82cd5ab93e26253133eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_clearInterrupts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *&#160;</td>
          <td class="paramname"><em>interruptsToClear</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_clearInterrupts</b> </p>
<p><b>Description</b> <br />
 This function clears the BEII Interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptsToClear Structure with the BETI interrupts to clear. A given
                  interrupt will be cleared if the corresponding flag
                  is set to 1.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The interrupts specified in the interruptsToClear structure are cleared.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_ICS0_SGCP0_CYC_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP0_FIFO_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP0_SEQ_CLR, TAC_CFG_BEII_ICS0_SGCP0_IB_WR_MISS_CLR, TAC_CFG_BEII_ICS0_SGCP1_CYC_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP1_FIFO_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP1_SEQ_CLR, TAC_CFG_BEII_ICS0_SGCP1_IB_WR_MISS_CLR, TAC_CFG_BEII_ICS0_SGCP2_CYC_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP2_FIFO_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP2_SEQ_CLR, TAC_CFG_BEII_ICS0_SGCP2_IB_WR_MISS_CLR, TAC_CFG_BEII_ICS0_SGCP3_CYC_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP3_FIFO_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP3_SEQ_CLR, TAC_CFG_BEII_ICS0_SGCP3_IB_WR_MISS_CLR, TAC_CFG_BEII_ICS0_SGCP4_CYC_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP4_FIFO_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP4_SEQ_CLR, TAC_CFG_BEII_ICS0_SGCP4_IB_WR_MISS_CLR, TAC_CFG_BEII_ICS0_SGCP5_CYC_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP5_FIFO_OVER_CLR, TAC_CFG_BEII_ICS0_SGCP5_SEQ_CLR, TAC_CFG_BEII_ICS0_SGCP5_IB_WR_MISS_CLR, TAC_CFG_BEII_ICS1_FE0_TRANS_CLR, TAC_CFG_BEII_ICS1_FE1_TRANS_CLR, TAC_CFG_BEII_ICS1_FE2_TRANS_CLR, TAC_CFG_BEII_ICS1_BE_WD_CLR</p>
<p><b>Affects</b> <br />
 TAC_CFG_BEII_IRS0_SGCP0_CYC_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP0_FIFO_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP0_SEQ_STAT = 0, TAC_CFG_BEII_IRS0_SGCP0_IB_WR_MISS_STAT = 0, TAC_CFG_BEII_IRS0_SGCP1_CYC_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP1_FIFO_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP1_SEQ_STAT = 0, TAC_CFG_BEII_IRS0_SGCP1_IB_WR_MISS_STAT = 0, TAC_CFG_BEII_IRS0_SGCP2_CYC_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP2_FIFO_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP2_SEQ_STAT = 0, TAC_CFG_BEII_IRS0_SGCP2_IB_WR_MISS_STAT = 0, TAC_CFG_BEII_IRS0_SGCP3_CYC_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP3_FIFO_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP3_SEQ_STAT = 0, TAC_CFG_BEII_IRS0_SGCP3_IB_WR_MISS_STAT = 0, TAC_CFG_BEII_IRS0_SGCP4_CYC_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP4_FIFO_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP4_SEQ_STAT = 0, TAC_CFG_BEII_IRS0_SGCP4_IB_WR_MISS_STAT = 0, TAC_CFG_BEII_IRS0_SGCP5_CYC_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP5_FIFO_OVER_STAT = 0, TAC_CFG_BEII_IRS0_SGCP5_SEQ_STAT = 0, TAC_CFG_BEII_IRS0_SGCP5_IB_WR_MISS_STAT = 0, TAC_CFG_BEII_IRS1_FE0_TRANS_STAT = 0, TAC_CFG_BEII_IRS1_FE1_TRANS_STAT = 0, TAC_CFG_BEII_IRS1_FE2_TRANS_STAT = 0, TAC_CFG_BEII_IRS1_BE_WD_STAT = 0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptStatus;

// Get the current interrupt status
CSL_TAC_BEII_getInterruptStatus(&amp;interruptStatus);

// Clear all the interrupts that have occured
CSL_TAC_BEII_clearInterrupts(&amp;interruptStatus);
</pre><p><br />
<b>CSL_TAC_BEII_clearInterrupts</b> </p>
<p><b>Description</b> <br />
 This function clears the BEII Interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptsToClear Structure with the BETI interrupts to clear. A given
                  interrupt will be cleared if the corresponding flag
                  is set to 1.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The interrupts specified in the interruptsToClear structure are cleared.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_ICS_0_SGCP0_CYC_OVER_CLR, TAC_CFG_BEII_ICS_0_SGCP0_FIFO_OVER_CLR, TAC_CFG_BEII_ICS_0_SGCP0_SEQ_CLR, TAC_CFG_BEII_ICS_0_SGCP0_IB_WR_MISS_CLR, TAC_CFG_BEII_ICS_0_SGCP1_CYC_OVER_CLR, TAC_CFG_BEII_ICS_0_SGCP1_FIFO_OVER_CLR, TAC_CFG_BEII_ICS_0_SGCP1_SEQ_CLR, TAC_CFG_BEII_ICS_0_SGCP1_IB_WR_MISS_CLR, TAC_CFG_BEII_ICS_1_FE0_TRANS_CLR, TAC_CFG_BEII_ICS_1_BE_WD_CLR</p>
<p><b>Affects</b> <br />
 TAC_CFG_BEII_IRS_0_SGCP0_CYC_OVER_STAT = 0, TAC_CFG_BEII_IRS_0_SGCP0_FIFO_OVER_STAT = 0, TAC_CFG_BEII_IRS_0_SGCP0_SEQ_STAT = 0, TAC_CFG_BEII_IRS_0_SGCP0_IB_WR_MISS_STAT = 0, TAC_CFG_BEII_IRS_0_SGCP1_CYC_OVER_STAT = 0, TAC_CFG_BEII_IRS_0_SGCP1_FIFO_OVER_STAT = 0, TAC_CFG_BEII_IRS_0_SGCP1_SEQ_STAT = 0, TAC_CFG_BEII_IRS_0_SGCP1_IB_WR_MISS_STAT = 0, TAC_CFG_BEII_IRS_1_FE0_TRANS_STAT = 0, TAC_CFG_BEII_IRS_1_BE_WD_STAT = 0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptStatus;

// Get the current interrupt status
CSL_TAC_BEII_getInterruptStatus(&amp;interruptStatus);

// Clear all the interrupts that have occured
CSL_TAC_BEII_clearInterrupts(&amp;interruptStatus);
</pre> 
</div>
</div>
<a class="anchor" id="ga11a89928a340c7c959eadbf3432da8aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_disable</b> </p>
<p><b>Description</b> <br />
 This function disables the TAC2 Back End Interrupt Interface (BEII)</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The Back End Interrupt Interface is disabled.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_CTRL_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_disable();
</pre> 
</div>
</div>
<a class="anchor" id="gac190b402bfaf404cedcdcc4dbf072498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_disableInterrupts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *&#160;</td>
          <td class="paramname"><em>interruptsToDisable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_disableInterrupts</b> </p>
<p><b>Description</b> <br />
 This function disables the BEII Interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptsToEnable Structure with the BETI interrupts to disable. A given
                   interrupt will be disabled if the corresponding flag is
                   set to 1.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The interrupts specified in the interruptsToDisable structure are disabled.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_IECS0_SGCP0_CYC_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP0_FIFO_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP0_SEQ_CLEAR, TAC_CFG_BEII_IECS0_SGCP0_IB_WR_MISS_CLEAR, TAC_CFG_BEII_IECS0_SGCP1_CYC_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP1_FIFO_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP1_SEQ_CLEAR, TAC_CFG_BEII_IECS0_SGCP1_IB_WR_MISS_CLEAR, TAC_CFG_BEII_IECS0_SGCP2_CYC_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP2_FIFO_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP2_SEQ_CLEAR, TAC_CFG_BEII_IECS0_SGCP2_IB_WR_MISS_CLEAR, TAC_CFG_BEII_IECS0_SGCP3_CYC_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP3_FIFO_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP3_SEQ_CLEAR, TAC_CFG_BEII_IECS0_SGCP3_IB_WR_MISS_CLEAR, TAC_CFG_BEII_IECS0_SGCP4_CYC_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP4_FIFO_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP4_SEQ_CLEAR, TAC_CFG_BEII_IECS0_SGCP4_IB_WR_MISS_CLEAR, TAC_CFG_BEII_IECS0_SGCP5_CYC_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP5_FIFO_OVER_CLEAR, TAC_CFG_BEII_IECS0_SGCP5_SEQ_CLEAR, TAC_CFG_BEII_IECS0_SGCP5_IB_WR_MISS_CLEAR, TAC_CFG_BEII_IECS1_FE0_TRANS_CLEAR, TAC_CFG_BEII_IECS1_FE1_TRANS_CLEAR, TAC_CFG_BEII_IECS1_FE2_TRANS_CLEAR, TAC_CFG_BEII_IECS1_BE_WD_CLEAR</p>
<p><b>Affects</b> <br />
 TAC_CFG_BEII_IE0_SGCP0_CYC_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP0_FIFO_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP0_SEQ_ENA=0, TAC_CFG_BEII_IE0_SGCP0_IB_WR_MISS_ENA=0, TAC_CFG_BEII_IE0_SGCP1_CYC_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP1_FIFO_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP1_SEQ_ENA=0, TAC_CFG_BEII_IE0_SGCP1_IB_WR_MISS_ENA=0, TAC_CFG_BEII_IE0_SGCP2_CYC_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP2_FIFO_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP2_SEQ_ENA=0, TAC_CFG_BEII_IE0_SGCP2_IB_WR_MISS_ENA=0, TAC_CFG_BEII_IE0_SGCP3_CYC_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP3_FIFO_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP3_SEQ_ENA=0, TAC_CFG_BEII_IE0_SGCP3_IB_WR_MISS_ENA=0, TAC_CFG_BEII_IE0_SGCP4_CYC_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP4_FIFO_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP4_SEQ_ENA=0, TAC_CFG_BEII_IE0_SGCP4_IB_WR_MISS_ENA=0, TAC_CFG_BEII_IE0_SGCP5_CYC_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP5_FIFO_OVER_ENA=0, TAC_CFG_BEII_IE0_SGCP5_SEQ_ENA=0, TAC_CFG_BEII_IE0_SGCP5_IB_WR_MISS_ENA=0, TAC_CFG_BEII_IE1_FE0_TRANS_ENA=0, TAC_CFG_BEII_IE1_FE1_TRANS_ENA=0, TAC_CFG_BEII_IE1_FE2_TRANS_ENA=0, TAC_CFG_BEII_IE1_BE_WD_ENA=0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptsToDisable;

// Disable the SGCP 0 FIFO Overflow interrupt
interruptsToDisable.sgcp0FifoOverStat = 1;

// Disable the BETI Watch Dog interrupt
interruptsToDisable.betiWdStat        = 1;

// Don't touch the rest of the interrupts
interruptsToDisable.sgcp0CycOverStat  = 0;
interruptsToDisable.sgcp0SeqStat      = 0;
interruptsToDisable.sgcp0BuffMissStat = 0;
interruptsToDisable.sgcp1CycOverStat  = 0;
interruptsToDisable.sgcp1FifoOverStat = 0;
interruptsToDisable.sgcp1BuffMissStat = 0;
interruptsToDisable.sgcp1SeqStat      = 0;
interruptsToDisable.sgcp2CycOverStat  = 0;
interruptsToDisable.sgcp2FifoOverStat = 0;
interruptsToDisable.sgcp2BuffMissStat = 0;
interruptsToDisable.sgcp2SeqStat      = 0;
interruptsToDisable.sgcp3CycOverStat  = 0;
interruptsToDisable.sgcp3FifoOverStat = 0;
interruptsToDisable.sgcp3BuffMissStat = 0;
interruptsToDisable.sgcp3SeqStat      = 0;
interruptsToDisable.sgcp4CycOverStat  = 0;
interruptsToDisable.sgcp4FifoOverStat = 0;
interruptsToDisable.sgcp4BuffMissStat = 0;
interruptsToDisable.sgcp4SeqStat      = 0;
interruptsToDisable.sgcp5CycOverStat  = 0;
interruptsToDisable.sgcp5FifoOverStat = 0;
interruptsToDisable.sgcp5BuffMissStat = 0;
interruptsToDisable.sgcp5SeqStat      = 0;
interruptsToDisable.fe0TransErrStat   = 0;
interruptsToDisable.fe1TransErrStat   = 0;
interruptsToDisable.fe2TransErrStat   = 0;

CSL_TAC_BEII_disableInterrupts(&amp;interruptsToDisable);
</pre><p><br />
<b>CSL_TAC_BEII_disableInterrupts</b> </p>
<p><b>Description</b> <br />
 This function disables the BEII Interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptsToEnable Structure with the BETI interrupts to disable. A given
                   interrupt will be disabled if the corresponding flag is
                   set to 1.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The interrupts specified in the interruptsToDisable structure are disabled.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_IECS_0_SGCP0_CYC_OVER_CLEAR, TAC_CFG_BEII_IECS_0_SGCP0_FIFO_OVER_CLEAR, TAC_CFG_BEII_IECS_0_SGCP0_SEQ_CLEAR, TAC_CFG_BEII_IECS_0_SGCP0_IB_WR_MISS_CLEAR, TAC_CFG_BEII_IECS_0_SGCP1_CYC_OVER_CLEAR, TAC_CFG_BEII_IECS_0_SGCP1_FIFO_OVER_CLEAR, TAC_CFG_BEII_IECS_0_SGCP1_SEQ_CLEAR, TAC_CFG_BEII_IECS_0_SGCP1_IB_WR_MISS_CLEAR, TAC_CFG_BEII_IECS_1_FE0_TRANS_CLEAR, TAC_CFG_BEII_IECS_1_BE_WD_CLEAR</p>
<p><b>Affects</b> <br />
 TAC_CFG_BEII_IE_0_SGCP0_CYC_OVER_ENA=0, TAC_CFG_BEII_IE_0_SGCP0_FIFO_OVER_ENA=0, TAC_CFG_BEII_IE_0_SGCP0_SEQ_ENA=0, TAC_CFG_BEII_IE_0_SGCP0_IB_WR_MISS_ENA=0, TAC_CFG_BEII_IE_0_SGCP1_CYC_OVER_ENA=0, TAC_CFG_BEII_IE_0_SGCP1_FIFO_OVER_ENA=0, TAC_CFG_BEII_IE_0_SGCP1_SEQ_ENA=0, TAC_CFG_BEII_IE_0_SGCP1_IB_WR_MISS_ENA=0, TAC_CFG_BEII_IE_1_FE0_TRANS_ENA=0, TAC_CFG_BEII_IE_1_BE_WD_ENA=0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptsToDisable;

// Disable the SGCP 0 FIFO Overflow interrupt
interruptsToDisable.sgcp0FifoOverStat = 1;

// Disable the BETI Watch Dog interrupt
interruptsToDisable.betiWdStat        = 1;

// Don't touch the rest of the interrupts
interruptsToDisable.sgcp0CycOverStat  = 0;
interruptsToDisable.sgcp0SeqStat      = 0;
interruptsToDisable.sgcp0BuffMissStat = 0;
interruptsToDisable.sgcp1CycOverStat  = 0;
interruptsToDisable.sgcp1FifoOverStat = 0;
interruptsToDisable.sgcp1BuffMissStat = 0;
interruptsToDisable.sgcp1SeqStat      = 0;
interruptsToDisable.fe0TransErrStat   = 0;

CSL_TAC_BEII_disableInterrupts(&amp;interruptsToDisable);
</pre> 
</div>
</div>
<a class="anchor" id="gaf136d8cd531e17805d9855ff3657fec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_enable</b> </p>
<p><b>Description</b> <br />
 This function enables the TAC2 Back End Interrupt Interface (BEII).</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The Back End Interrupt Interface is enabled.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_CTRL_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_enable();
</pre> 
</div>
</div>
<a class="anchor" id="ga51223c7105755dcabd6cea503bfdd5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_enableInterrupts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *&#160;</td>
          <td class="paramname"><em>interruptsToEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_enableInterrupts</b> </p>
<p><b>Description</b> <br />
 This function enables the BEII Interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptsToEnable Structure with the BETI interrupts to enable. A given
                   interrupt will be enabled if the corresponding flag is
                   set to 1.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The interrupts specified in the interruptsToEnable structure are enabled.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_IE0_SGCP0_CYC_OVER_ENA, TAC_CFG_BEII_IE0_SGCP0_FIFO_OVER_ENA, TAC_CFG_BEII_IE0_SGCP0_SEQ_ENA, TAC_CFG_BEII_IE0_SGCP0_IB_WR_MISS_ENA, TAC_CFG_BEII_IE0_SGCP1_CYC_OVER_ENA, TAC_CFG_BEII_IE0_SGCP1_FIFO_OVER_ENA, TAC_CFG_BEII_IE0_SGCP1_SEQ_ENA, TAC_CFG_BEII_IE0_SGCP1_IB_WR_MISS_ENA, TAC_CFG_BEII_IE0_SGCP2_CYC_OVER_ENA, TAC_CFG_BEII_IE0_SGCP2_FIFO_OVER_ENA, TAC_CFG_BEII_IE0_SGCP2_SEQ_ENA, TAC_CFG_BEII_IE0_SGCP2_IB_WR_MISS_ENA, TAC_CFG_BEII_IE0_SGCP3_CYC_OVER_ENA, TAC_CFG_BEII_IE0_SGCP3_FIFO_OVER_ENA, TAC_CFG_BEII_IE0_SGCP3_SEQ_ENA, TAC_CFG_BEII_IE0_SGCP3_IB_WR_MISS_ENA, TAC_CFG_BEII_IE0_SGCP4_CYC_OVER_ENA, TAC_CFG_BEII_IE0_SGCP4_FIFO_OVER_ENA, TAC_CFG_BEII_IE0_SGCP4_SEQ_ENA, TAC_CFG_BEII_IE0_SGCP4_IB_WR_MISS_ENA, TAC_CFG_BEII_IE0_SGCP5_CYC_OVER_ENA, TAC_CFG_BEII_IE0_SGCP5_FIFO_OVER_ENA, TAC_CFG_BEII_IE0_SGCP5_SEQ_ENA, TAC_CFG_BEII_IE0_SGCP5_IB_WR_MISS_ENA, TAC_CFG_BEII_IE1_FE0_TRANS_ENA, TAC_CFG_BEII_IE1_FE1_TRANS_ENA, TAC_CFG_BEII_IE1_FE2_TRANS_ENA, TAC_CFG_BEII_IE1_BE_WD_ENA</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptsToEnable;

// Enable the SGCP 0 FIFO Overflow interrupt
interruptsToEnable.sgcp0FifoOverStat = 1;

// Enable the BETI Watch Dog interrupt
interruptsToEnable.betiWdStat        = 1;

// Don't Enable the rest of the interrupts
interruptsToEnable.sgcp0CycOverStat  = 0;
interruptsToEnable.sgcp0SeqStat      = 0;
interruptsToEnable.sgcp0BuffMissStat = 0;
interruptsToEnable.sgcp1CycOverStat  = 0;
interruptsToEnable.sgcp1FifoOverStat = 0;
interruptsToEnable.sgcp1BuffMissStat = 0;
interruptsToEnable.sgcp1SeqStat      = 0;
interruptsToEnable.sgcp2CycOverStat  = 0;
interruptsToEnable.sgcp2FifoOverStat = 0;
interruptsToEnable.sgcp2BuffMissStat = 0;
interruptsToEnable.sgcp2SeqStat      = 0;
interruptsToEnable.sgcp3CycOverStat  = 0;
interruptsToEnable.sgcp3FifoOverStat = 0;
interruptsToEnable.sgcp3BuffMissStat = 0;
interruptsToEnable.sgcp3SeqStat      = 0;
interruptsToEnable.sgcp4CycOverStat  = 0;
interruptsToEnable.sgcp4FifoOverStat = 0;
interruptsToEnable.sgcp4BuffMissStat = 0;
interruptsToEnable.sgcp4SeqStat      = 0;
interruptsToEnable.sgcp5CycOverStat  = 0;
interruptsToEnable.sgcp5FifoOverStat = 0;
interruptsToEnable.sgcp5BuffMissStat = 0;
interruptsToEnable.sgcp5SeqStat      = 0;
interruptsToEnable.fe0TransErrStat   = 0;
interruptsToEnable.fe1TransErrStat   = 0;
interruptsToEnable.fe2TransErrStat   = 0;

CSL_TAC_BEII_enableInterrupts(&amp;interruptsToEnable);
</pre><p><br />
<b>CSL_TAC_BEII_enableInterrupts</b> </p>
<p><b>Description</b> <br />
 This function enables the BEII Interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptsToEnable Structure with the BETI interrupts to enable. A given
                   interrupt will be enabled if the corresponding flag is
                   set to 1.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The interrupts specified in the interruptsToEnable structure are enabled.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_IE_0_SGCP0_CYC_OVER_ENA, TAC_CFG_BEII_IE_0_SGCP0_FIFO_OVER_ENA, TAC_CFG_BEII_IE_0_SGCP0_SEQ_ENA, TAC_CFG_BEII_IE_0_SGCP0_IB_WR_MISS_ENA, TAC_CFG_BEII_IE_0_SGCP1_CYC_OVER_ENA, TAC_CFG_BEII_IE_0_SGCP1_FIFO_OVER_ENA, TAC_CFG_BEII_IE_0_SGCP1_SEQ_ENA, TAC_CFG_BEII_IE_0_SGCP1_IB_WR_MISS_ENA, TAC_CFG_BEII_IE_1_FE0_TRANS_ENA, TAC_CFG_BEII_IE_1_BE_WD_ENA</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptsToEnable;

// Enable the SGCP 0 FIFO Overflow interrupt
interruptsToEnable.sgcp0FifoOverStat = 1;

// Enable the BETI Watch Dog interrupt
interruptsToEnable.betiWdStat        = 1;

// Don't Enable the rest of the interrupts
interruptsToEnable.sgcp0CycOverStat  = 0;
interruptsToEnable.sgcp0SeqStat      = 0;
interruptsToEnable.sgcp0BuffMissStat = 0;
interruptsToEnable.sgcp1CycOverStat  = 0;
interruptsToEnable.sgcp1FifoOverStat = 0;
interruptsToEnable.sgcp1BuffMissStat = 0;
interruptsToEnable.sgcp1SeqStat      = 0;
interruptsToEnable.fe0TransErrStat   = 0;

CSL_TAC_BEII_enableInterrupts(&amp;interruptsToEnable);
</pre> 
</div>
</div>
<a class="anchor" id="gaf80021d6e1eee21729b39bac0a051a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_forceInterrupts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *&#160;</td>
          <td class="paramname"><em>interruptsToForce</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_forceInterrupts</b> </p>
<p><b>Description</b> <br />
 This function sets the BEII Interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptsToForce Structure with the BETI interrupts to set. A given
                  interrupt will be set if the corresponding flag is
                  set to 1.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The interrupts specified in the interruptsToForce structure are set.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_IRS0_SGCP0_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP0_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP0_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP0_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP1_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP1_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP1_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP1_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP2_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP2_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP2_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP2_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP3_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP3_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP3_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP3_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP4_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP4_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP4_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP4_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP5_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP5_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP5_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP5_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS1_FE0_TRANS_STAT, TAC_CFG_BEII_IRS1_FE1_TRANS_STAT, TAC_CFG_BEII_IRS1_FE2_TRANS_STAT, TAC_CFG_BEII_IRS1_BE_WD_STAT</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptsToForce;

// Force the SGCP 0 Cycle Overflow interrupt
interruptsToForce.sgcp0CycOverStat = 1;

// Force the SGCP 1 Input Buffer Miss Interrupt
interruptsToForce.sgcp1BuffMissStat = 1;

// Don't force the rest of the interrupts
interruptsToForce.sgcp0FifoOverStat = 0;
interruptsToForce.sgcp0SeqStat      = 0;
interruptsToForce.sgcp0BuffMissStat = 0;
interruptsToForce.sgcp1CycOverStat  = 0;
interruptsToForce.sgcp1FifoOverStat = 0;
interruptsToForce.sgcp1SeqStat      = 0;
interruptsToForce.sgcp2CycOverStat  = 0;
interruptsToForce.sgcp2FifoOverStat = 0;
interruptsToForce.sgcp2SeqStat      = 0;
interruptsToForce.sgcp2BuffMissStat = 0;
interruptsToForce.sgcp3CycOverStat  = 0;
interruptsToForce.sgcp3FifoOverStat = 0;
interruptsToForce.sgcp3SeqStat      = 0;
interruptsToForce.sgcp3BuffMissStat = 0;
interruptsToForce.fe1TransErrStat   = 0;
interruptsToForce.fe1TransErrStat   = 0;
interruptsToForce.betiWdStat        = 0;

CSL_TAC_BEII_forceInterrupts(&amp;interruptsToForce);
</pre><p><br />
<b>CSL_TAC_BEII_forceInterrupts</b> </p>
<p><b>Description</b> <br />
 This function sets the BEII Interrupts</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptsToForce Structure with the BETI interrupts to set. A given
                  interrupt will be set if the corresponding flag is
                  set to 1.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The interrupts specified in the interruptsToForce structure are set.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_IRS_0_SGCP0_CYC_OVER_STAT, TAC_CFG_BEII_IRS_0_SGCP0_FIFO_OVER_STAT, TAC_CFG_BEII_IRS_0_SGCP0_SEQ_STAT, TAC_CFG_BEII_IRS_0_SGCP0_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS_0_SGCP1_CYC_OVER_STAT, TAC_CFG_BEII_IRS_0_SGCP1_FIFO_OVER_STAT, TAC_CFG_BEII_IRS_0_SGCP1_SEQ_STAT, TAC_CFG_BEII_IRS_0_SGCP1_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS_1_FE0_TRANS_STAT, TAC_CFG_BEII_IRS_1_BE_WD_STAT</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptsToForce;

// Force the SGCP 0 Cycle Overflow interrupt
interruptsToForce.sgcp0CycOverStat = 1;

// Force the SGCP 1 Input Buffer Miss Interrupt
interruptsToForce.sgcp1BuffMissStat = 1;

// Don't force the rest of the interrupts
interruptsToForce.sgcp0FifoOverStat = 0;
interruptsToForce.sgcp0SeqStat      = 0;
interruptsToForce.sgcp0BuffMissStat = 0;
interruptsToForce.sgcp1CycOverStat  = 0;
interruptsToForce.sgcp1FifoOverStat = 0;
interruptsToForce.sgcp1SeqStat      = 0;
interruptsToForce.betiWdStat        = 0;

CSL_TAC_BEII_forceInterrupts(&amp;interruptsToForce);
</pre> 
</div>
</div>
<a class="anchor" id="gaaa3093b94a5167af86c38addf02a3cbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *&#160;</td>
          <td class="paramname"><em>interruptEnStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_getEnabledInterruptStatus</b> </p>
<p><b>Description</b> <br />
 This function reads the BEII Interrupt Enable Status</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptEnStatus Structure with the BETI interrupt Enable status.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BEII_IES0_SGCP0_CYC_OVER_STAT, TAC_CFG_BEII_IES0_SGCP0_FIFO_OVER_STAT, TAC_CFG_BEII_IES0_SGCP0_SEQ_STAT, TAC_CFG_BEII_IES0_SGCP0_IB_WR_MISS_STAT, TAC_CFG_BEII_IES0_SGCP1_CYC_OVER_STAT, TAC_CFG_BEII_IES0_SGCP1_FIFO_OVER_STAT, TAC_CFG_BEII_IES0_SGCP1_SEQ_STAT, TAC_CFG_BEII_IES0_SGCP1_IB_WR_MISS_STAT, TAC_CFG_BEII_IES0_SGCP2_CYC_OVER_STAT, TAC_CFG_BEII_IES0_SGCP2_FIFO_OVER_STAT, TAC_CFG_BEII_IES0_SGCP2_SEQ_STAT, TAC_CFG_BEII_IES0_SGCP2_IB_WR_MISS_STAT, TAC_CFG_BEII_IES0_SGCP3_CYC_OVER_STAT, TAC_CFG_BEII_IES0_SGCP3_FIFO_OVER_STAT, TAC_CFG_BEII_IES0_SGCP3_SEQ_STAT, TAC_CFG_BEII_IES0_SGCP3_IB_WR_MISS_STAT, TAC_CFG_BEII_IES0_SGCP4_CYC_OVER_STAT, TAC_CFG_BEII_IES0_SGCP4_FIFO_OVER_STAT, TAC_CFG_BEII_IES0_SGCP4_SEQ_STAT, TAC_CFG_BEII_IES0_SGCP4_IB_WR_MISS_STAT, TAC_CFG_BEII_IES0_SGCP5_CYC_OVER_STAT, TAC_CFG_BEII_IES0_SGCP5_FIFO_OVER_STAT, TAC_CFG_BEII_IES0_SGCP5_SEQ_STAT, TAC_CFG_BEII_IES0_SGCP5_IB_WR_MISS_STAT, TAC_CFG_BEII_IES1_FE0_TRANS_STAT, TAC_CFG_BEII_IES1_FE1_TRANS_STAT, TAC_CFG_BEII_IES1_FE2_TRANS_STAT, TAC_CFG_BEII_IES1_BE_WD_STAT</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptEnStatus;

CSL_TAC_BEII_getEnabledInterruptStatus(&amp;interruptEnStatus);

if (interruptEnStatus.sgcp0CycOverStat)
{
    // SGCP 0 Cycle Overflow Interrupt is enabled
    ...
}</pre><p><br />
<b>CSL_TAC_BEII_getEnabledInterruptStatus</b> </p>
<p><b>Description</b> <br />
 This function reads the BEII Interrupt Enable Status</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptEnStatus Structure with the BETI interrupt Enable status.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BEII_IES_0_SGCP0_CYC_OVER_STAT, TAC_CFG_BEII_IES_0_SGCP0_FIFO_OVER_STAT, TAC_CFG_BEII_IES_0_SGCP0_SEQ_STAT, TAC_CFG_BEII_IES_0_SGCP0_IB_WR_MISS_STAT, TAC_CFG_BEII_IES_0_SGCP1_CYC_OVER_STAT, TAC_CFG_BEII_IES_0_SGCP1_FIFO_OVER_STAT, TAC_CFG_BEII_IES_0_SGCP1_SEQ_STAT, TAC_CFG_BEII_IES_0_SGCP1_IB_WR_MISS_STAT, TAC_CFG_BEII_IES_1_FE0_TRANS_STAT, TAC_CFG_BEII_IES_1_BE_WD_STAT</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptEnStatus;

CSL_TAC_BEII_getEnabledInterruptStatus(&amp;interruptEnStatus);

if (interruptEnStatus.sgcp0CycOverStat)
{
    // SGCP 0 Cycle Overflow Interrupt is enabled
    ...
}</pre> 
</div>
</div>
<a class="anchor" id="ga3037d9a69563bfa5ae184e2d31876827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___t_a_c___b_e___e_n_u_m.html#gacc533d3dfa44036e6040dedaf6fce925">CSL_TAC_BEII_enableStatus</a> CSL_TAC_BEII_getEnableStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_getEnableStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the enable status of the BEII.</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 CSL_TAC_BEII_Disabled The BEII is disabled. <br />
 CSL_TAC_BEII_Enabled The BEII is enabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BEII_CTRL_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_enable();

if (CSL_TAC_BEII_getEnableStatus() != CSL_TAC_BEII_Enabled)
{
    // The BEII should have been enabled.
    ...
}

...
CSL_TAC_BEII_disable();

if (CSL_TAC_BEII_getEnableStatus() != CSL_TAC_BEII_Disabled)
{
    // The BEII should have been disabled.
    ...
}
</pre> 
</div>
</div>
<a class="anchor" id="gab134a8f64a686ffdcb18602b914fe19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_TAC_BEII_getEOI </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_getEOI</b> </p>
<p><b>Description</b> <br />
 This function returns the contents of BEII End of Interrupt register.</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BEII_EOI_EOI</p>
<p><b>Example</b> </p><pre class="fragment">Uint32  eoiVal;

eoiVal = CSL_TAC_BEII_getEOI();
</pre> 
</div>
</div>
<a class="anchor" id="ga7e2cd9e7351d0a6497b8d4c227b35722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_getInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___t_a_c___b_e_i_i__interrupt_status.html">CSL_TAC_BEII_interruptStatus</a> *&#160;</td>
          <td class="paramname"><em>interruptStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_getInterruptStatus</b> </p>
<p><b>Description</b> <br />
 This function reads the BEII Interrupt Status</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptStatus Structure with the active BETI interrupt status.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BEII_IRS0_SGCP0_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP0_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP0_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP0_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP1_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP1_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP1_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP1_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP2_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP2_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP2_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP2_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP3_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP3_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP3_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP3_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP4_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP4_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP4_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP4_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS0_SGCP5_CYC_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP5_FIFO_OVER_STAT, TAC_CFG_BEII_IRS0_SGCP5_SEQ_STAT, TAC_CFG_BEII_IRS0_SGCP5_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS1_FE0_TRANS_STAT, TAC_CFG_BEII_IRS1_FE1_TRANS_STAT, TAC_CFG_BEII_IRS1_FE2_TRANS_STAT, TAC_CFG_BEII_IRS1_BE_WD_STAT</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptStatus;

CSL_TAC_BEII_getInterruptStatus(&amp;interruptStatus);

if (interruptStatus.sgcp0CycOverStat)
{
    // SGCP 0 Cycle Overflow Interrupt occured
    ...
}

if (interruptStatus.sgcp0FifoOverStat)
{
    // SGCP 0 FIFO Overflow Interrupt occured
    ...
}

if (interruptStatus.sgcp0SeqStat)
{
    // SGCP 0 Cycle Sequencer Idle Interrupt occured
    ...
}

if (interruptStatus.sgcp0BuffMissStat)
{
    // SGCP 0 Input Buffer Miss Interrupt occured
    ...
}

if (interruptStatus.sgcp1CycOverStat)
{
    // SGCP 1 Cycle Overflow Interrupt occured
    ...
}

if (interruptStatus.sgcp1FifoOverStat)
{
    // SGCP 1 FIFO Overflow Interrupt occured
    ...
}

if (interruptStatus.sgcp1SeqStat)
{
    // SGCP 1 Cycle Sequencer Idle Interrupt occured
    ...
}

if (interruptStatus.sgcp1BuffMissStat)
{
    // SGCP 1 Input Buffer Miss Interrupt occured
    ...
}

...
// Checks for SGCP 2,3,4,5, if necesssary
...

if (interruptStatus.fe0TransErrStat)
{
    // Front-End # 0 Transaction ID unavailable
    ...
}

if (interruptStatus.fe1TransErrStat)
{
    // Front-End #1 Transaction ID unavailable
    ...
}

if (interruptStatus.fe2TransErrStat)
{
    // Front-End #2 Transaction ID unavailable
    ...
}

if (interruptStatus.betiWdStat)
{
    // The Back-End Watch Dog Timer counter reached 0
    ...
}</pre><p><br />
<b>CSL_TAC_BEII_getInterruptStatus</b> </p>
<p><b>Description</b> <br />
 This function reads the BEII Interrupt Status</p>
<p><b>Arguments</b> </p><pre class="fragment">interruptStatus Structure with the active BETI interrupt status.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BEII_IRS_0_SGCP0_CYC_OVER_STAT, TAC_CFG_BEII_IRS_0_SGCP0_FIFO_OVER_STAT, TAC_CFG_BEII_IRS_0_SGCP0_SEQ_STAT, TAC_CFG_BEII_IRS_0_SGCP0_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS_0_SGCP1_CYC_OVER_STAT, TAC_CFG_BEII_IRS_0_SGCP1_FIFO_OVER_STAT, TAC_CFG_BEII_IRS_0_SGCP1_SEQ_STAT, TAC_CFG_BEII_IRS_0_SGCP1_IB_WR_MISS_STAT, TAC_CFG_BEII_IRS_1_FE0_TRANS_STAT, TAC_CFG_BEII_IRS_1_BE_WD_STAT</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_interruptStatus  interruptStatus;

CSL_TAC_BEII_getInterruptStatus(&amp;interruptStatus);

if (interruptStatus.sgcp0CycOverStat)
{
    // SGCP 0 Cycle Overflow Interrupt occured
    ...
}

if (interruptStatus.sgcp0FifoOverStat)
{
    // SGCP 0 FIFO Overflow Interrupt occured
    ...
}

if (interruptStatus.sgcp0SeqStat)
{
    // SGCP 0 Cycle Sequencer Idle Interrupt occured
    ...
}

if (interruptStatus.sgcp0BuffMissStat)
{
    // SGCP 0 Input Buffer Miss Interrupt occured
    ...
}

if (interruptStatus.sgcp1CycOverStat)
{
    // SGCP 1 Cycle Overflow Interrupt occured
    ...
}

if (interruptStatus.sgcp1FifoOverStat)
{
    // SGCP 1 FIFO Overflow Interrupt occured
    ...
}

if (interruptStatus.sgcp1SeqStat)
{
    // SGCP 1 Cycle Sequencer Idle Interrupt occured
    ...
}

if (interruptStatus.sgcp1BuffMissStat)
{
    // SGCP 1 Input Buffer Miss Interrupt occured
    ...
}

if (interruptStatus.fe0TransErrStat)
{
    // Front-End # 0 Transaction ID unavailable
    ...
}

if (interruptStatus.betiWdStat)
{
    // The Back-End Watch Dog Timer counter reached 0
    ...
}</pre> 
</div>
</div>
<a class="anchor" id="ga709b49aee5d1afc4f17e53ee0fc9105e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BEII_setEOI </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>eoiVecValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BEII_setEOI</b> </p>
<p><b>Description</b> <br />
 This function configures the BEII End of Interrupt register.</p>
<p><b>Arguments</b> </p><pre class="fragment">eoiVecValue       EOI Vector value
None
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TAC_CFG_BEII_EOI_EOI</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BEII_setEOI(5000);
</pre> 
</div>
</div>
<a class="anchor" id="ga614a81d3aa810a4e9081524d0677a8e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BETI_clearWatchDogInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BETI_clearWatchDogInterrupt</b> </p>
<p><b>Description</b> <br />
 This function clears the interrupt registered in the watch dog interrupt status register.</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 TAC_CFG_BETI_WINT_INT_STAT=0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BETI_wdInterruptStatus wdIntStatus;

wdIntStatus = CSL_TAC_BETI_getWatchDogInterruptStatus();

if (wdIntStatus == CSL_TAC_BETI_wdInterruptStatus_Int)
{
    // Interrupt generated and forwarded to BEII
    CSL_TAC_BETI_clearWatchDogInterrupt();
}
</pre> 
</div>
</div>
<a class="anchor" id="gacd58e4c944c47bd7f517f46f281b46c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BETI_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BETI_disable</b> </p>
<p><b>Description</b> <br />
 This function disables the TAC2 Back End Transfer Interface (BETI).</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The Back End Transfer Interface is disabled.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BETI_CTRL_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BETI_disable();
</pre> 
</div>
</div>
<a class="anchor" id="gafef394ca245d3a0cd7c10bf7031a789b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BETI_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BETI_enable</b> </p>
<p><b>Description</b> <br />
 This function enables the TAC2 Back End Transfer Interface (BETI).</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The Back End Transfer Interface is enabled.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BETI_CTRL_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BETI_enable();
</pre> 
</div>
</div>
<a class="anchor" id="gae753f6775b1d3cef3c82a9107386b58b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___t_a_c___b_e___e_n_u_m.html#gab608f12d78c2580d87b0fefc5650a1b8">CSL_TAC_BETI_enableStatus</a> CSL_TAC_BETI_getEnableStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BETI_getEnableStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the enable status of the BETI.</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 CSL_TAC_BETI_Disabled The BETI is disabled. <br />
 CSL_TAC_BETI_Enabled The BETI is enabled.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BETI_CTRL_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BETI_enable();

if (CSL_TAC_BETI_getEnableStatus() != CSL_TAC_BETI_Enabled)
{
    // The BETI should have been enabled.
    ...
}

...
CSL_TAC_BETI_disable();

if (CSL_TAC_BETI_getEnableStatus() != CSL_TAC_BETI_Disabled)
{
    // The BETI should have been disabled.
    ...
}
</pre> 
</div>
</div>
<a class="anchor" id="gad1b92ff6a8d2e87d93ff71e18586cfe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BETI_getStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___t_a_c___b_e_t_i__status.html">CSL_TAC_BETI_status</a> *&#160;</td>
          <td class="paramname"><em>betiStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BETI_getStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the BETI status indicating whether the SGCPs are Busy or Idle.</p>
<p><b>Arguments</b> </p><pre class="fragment">betiStatus     Status of the SGCPs
</pre><p><b> Return Value </b> <b>None</b> </p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BETI_STAT_SGCP0_STATUS, TAC_CFG_BETI_STAT_SGCP1_STATUS</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BETI_status  betiStatus;

CSL_TAC_BETI_getStatus(&amp;betiStatus);

if (betiStatus.sgcp0Status == CSL_TAC_BETI_statusBit_Idle)
{
    // SGCP 0 Idle
    ...
}

if (betiStatus.sgcp1Status == CSL_TAC_BETI_statusBit_Busy)
{
    // SGCP 1 Busy
    ...
}

if (betiStatus.sgcp2Status == CSL_TAC_BETI_statusBit_Busy)
{
    // SGCP 2 Busy
    ...
}

if (betiStatus.sgcp3Status == CSL_TAC_BETI_statusBit_Idle)
{
    // SGCP 3 Idle
    ...
}</pre><p><br />
<b>CSL_TAC_BETI_getStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the BETI status indicating whether the SGCPs are Busy or Idle.</p>
<p><b>Arguments</b> </p><pre class="fragment">betiStatus     Status of the SGCPs
</pre><p><b> Return Value </b> <b>None</b> </p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BETI_STAT_SGCP0_STATUS, TAC_CFG_BETI_STAT_SGCP1_STATUS</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BETI_status  betiStatus;

CSL_TAC_BETI_getStatus(&amp;betiStatus);

if (betiStatus.sgcp0Status == CSL_TAC_BETI_statusBit_Idle)
{
    // SGCP 0 Idle
    ...
}

if (betiStatus.sgcp1Status == CSL_TAC_BETI_statusBit_Busy)
{
    // SGCP 1 Busy
    ...
}</pre> 
</div>
</div>
<a class="anchor" id="gae2c82a554e91f21bad99409fc1a6cefd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___t_a_c___b_e___e_n_u_m.html#ga95bfb8a12e8c4310fb298f3d778a3e8d">CSL_TAC_BETI_wdInterruptStatus</a> CSL_TAC_BETI_getWatchDogInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BETI_getWatchDogInterruptStatus</b> </p>
<p><b>Description</b> <br />
 This function reads the content of the watch dog interrupt status register.</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 CSL_TAC_BETI_wdInterruptStatus_NoInt No interrupt has been generated. <br />
 CSL_TAC_BETI_wdInterruptStatus_Int An interrupt has been generated and forwarded to the BEII.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BETI_WINT_INT_STAT</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BETI_wdInterruptStatus wdIntStatus;

wdIntStatus = CSL_TAC_BETI_getWatchDogInterruptStatus();

if (wdIntStatus == CSL_TAC_BETI_wdInterruptStatus_Int)
{
    // Interrupt generated and forwarded to BEII
    ...
}
</pre> 
</div>
</div>
<a class="anchor" id="ga9b5a9fa9087ce2db4f51356fb74d86d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 CSL_TAC_BETI_getWatchDogStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BETI_getWatchDogStatus</b> </p>
<p><b>Description</b> <br />
 This function reads the content of the BETI watch dog decounter.</p>
<p><b>Arguments</b> </p><pre class="fragment">None
</pre><p><b> Return Value </b> <br />
 Current value of the decounter.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TAC_CFG_BETI_WST_BE_WD_STAT</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  deCnt;

deCnt = CSL_TAC_BETI_getWatchDogStatus();
...
</pre> 
</div>
</div>
<a class="anchor" id="ga8b1d31d95382fc6bb4e2498b6419fe65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_BETI_setWatchDog </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>reloadCnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_BETI_setWatchDog</b> </p>
<p><b>Description</b> <br />
 This function configures the watch dog in the BETI.</p>
<p><b>Arguments</b> </p><pre class="fragment">reloadCnt       The value indicates the number of elapsed TAC2 clock cycles
                between DMA write accesses that will trigger a watchdog
                interrupt.
</pre><p><b> Return Value </b> <b>None</b> </p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The Back-End watch-dog is configured.</p>
<p><b>Writes</b> <br />
 TAC_CFG_BETI_WCFG_BE_WD_CFG</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_BETI_setWatchDog(100);
</pre> 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
