<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MDIO Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MDIO Functions<div class="ingroups"><a class="el" href="group___c_s_l___m_d_i_o___a_p_i.html">MDIO</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4557f178ac850e79dea29c48a686e86a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga4557f178ac850e79dea29c48a686e86a">CSL_MDIO_getVersionInfo</a> (<a class="el" href="struct_c_s_l___m_d_i_o___v_e_r_s_i_o_n.html">CSL_MDIO_VERSION</a> *mdioVersionInfo)</td></tr>
<tr class="separator:ga4557f178ac850e79dea29c48a686e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9bfcf528850710276444ffa0d8aa097"><td class="memItemLeft" align="right" valign="top">static Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gad9bfcf528850710276444ffa0d8aa097">CSL_MDIO_getClkDivVal</a> (void)</td></tr>
<tr class="separator:gad9bfcf528850710276444ffa0d8aa097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289deb7e32c4277eec786afd273408bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga289deb7e32c4277eec786afd273408bc">CSL_MDIO_setClkDivVal</a> (Uint16 clkDivVal)</td></tr>
<tr class="separator:ga289deb7e32c4277eec786afd273408bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga401a20e685cda37a7f0397970b14170e"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga401a20e685cda37a7f0397970b14170e">CSL_MDIO_isFaultDetectEnabled</a> (void)</td></tr>
<tr class="separator:ga401a20e685cda37a7f0397970b14170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a031867aebcf35b370abcd2bce357b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga1a031867aebcf35b370abcd2bce357b7">CSL_MDIO_enableFaultDetect</a> ()</td></tr>
<tr class="separator:ga1a031867aebcf35b370abcd2bce357b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f5e939587cdc5fd3fbc5e45c90d8497"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2f5e939587cdc5fd3fbc5e45c90d8497">CSL_MDIO_disableFaultDetect</a> ()</td></tr>
<tr class="separator:ga2f5e939587cdc5fd3fbc5e45c90d8497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f47898a451debf5ba44d1449b6a016"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga32f47898a451debf5ba44d1449b6a016">CSL_MDIO_isFaultDetected</a> (void)</td></tr>
<tr class="separator:ga32f47898a451debf5ba44d1449b6a016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0be476a73b57e2c6ff6d3a082f3752"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaba0be476a73b57e2c6ff6d3a082f3752">CSL_MDIO_clearFault</a> ()</td></tr>
<tr class="separator:gaba0be476a73b57e2c6ff6d3a082f3752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d8e2fd526b92bee7e083664fb64cad"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga63d8e2fd526b92bee7e083664fb64cad">CSL_MDIO_isPreambleEnabled</a> (void)</td></tr>
<tr class="separator:ga63d8e2fd526b92bee7e083664fb64cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097444696f4fb33d45e9b99df49cf338"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga097444696f4fb33d45e9b99df49cf338">CSL_MDIO_enablePreamble</a> ()</td></tr>
<tr class="separator:ga097444696f4fb33d45e9b99df49cf338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9be255ed97beccd423e88743828864"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gadf9be255ed97beccd423e88743828864">CSL_MDIO_disablePreamble</a> ()</td></tr>
<tr class="separator:gadf9be255ed97beccd423e88743828864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6faf36fb963a6035e02494d14f1087b1"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6faf36fb963a6035e02494d14f1087b1">CSL_MDIO_getHighestUserChannel</a> (void)</td></tr>
<tr class="separator:ga6faf36fb963a6035e02494d14f1087b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f40d9fce00936f6ca05407b172f4977"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6f40d9fce00936f6ca05407b172f4977">CSL_MDIO_isStateMachineEnabled</a> (void)</td></tr>
<tr class="separator:ga6f40d9fce00936f6ca05407b172f4977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd659c7512d86a249876f8a4977189b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabbd659c7512d86a249876f8a4977189b">CSL_MDIO_enableStateMachine</a> ()</td></tr>
<tr class="separator:gabbd659c7512d86a249876f8a4977189b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2180daf47153154f3274344973e3c553"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2180daf47153154f3274344973e3c553">CSL_MDIO_disableStateMachine</a> ()</td></tr>
<tr class="separator:ga2180daf47153154f3274344973e3c553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cabb86c9ef1ed5b373debd0518c4ce"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gae2cabb86c9ef1ed5b373debd0518c4ce">CSL_MDIO_isStateMachineIdle</a> (void)</td></tr>
<tr class="separator:gae2cabb86c9ef1ed5b373debd0518c4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ff9103a8ec1e971aed43dd70c9ba98"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga29ff9103a8ec1e971aed43dd70c9ba98">CSL_MDIO_isPhyAlive</a> (Uint32 phyAddr)</td></tr>
<tr class="separator:ga29ff9103a8ec1e971aed43dd70c9ba98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90419ccafe7119ac63833d240e748ded"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga90419ccafe7119ac63833d240e748ded">CSL_MDIO_clearPhyAliveStatus</a> (Uint32 phyAddr)</td></tr>
<tr class="separator:ga90419ccafe7119ac63833d240e748ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48582314d31c05514880bf1a876f19d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab48582314d31c05514880bf1a876f19d">CSL_MDIO_isPhyLinked</a> (Uint32 phyAddr)</td></tr>
<tr class="separator:gab48582314d31c05514880bf1a876f19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26e822a6ae7f8b3faa8316d06e83524"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf26e822a6ae7f8b3faa8316d06e83524">CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</a> (Uint32 index)</td></tr>
<tr class="separator:gaf26e822a6ae7f8b3faa8316d06e83524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301389b248d69524480aa4d0dd76cb9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga301389b248d69524480aa4d0dd76cb9e">CSL_MDIO_clearUnmaskedLinkStatusChangeInt</a> (Uint32 index)</td></tr>
<tr class="separator:ga301389b248d69524480aa4d0dd76cb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab798a906133056478c9488e24f86caba"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab798a906133056478c9488e24f86caba">CSL_MDIO_isMaskedLinkStatusChangeIntSet</a> (Uint32 index)</td></tr>
<tr class="separator:gab798a906133056478c9488e24f86caba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435e5615f18a341469b06c50582c928c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga435e5615f18a341469b06c50582c928c">CSL_MDIO_clearMaskedLinkStatusChangeInt</a> (Uint32 index)</td></tr>
<tr class="separator:ga435e5615f18a341469b06c50582c928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90f7f7efb26f324b9b13ce0683f280f"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gad90f7f7efb26f324b9b13ce0683f280f">CSL_MDIO_isUnmaskedUserCmdCompleteIntSet</a> (Uint32 index)</td></tr>
<tr class="separator:gad90f7f7efb26f324b9b13ce0683f280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8368908148e23780da4108de5860a338"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga8368908148e23780da4108de5860a338">CSL_MDIO_clearUnmaskedUserCmdCompleteInt</a> (Uint32 index)</td></tr>
<tr class="separator:ga8368908148e23780da4108de5860a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3850d096378dcab15bfc5f11c4bff848"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga3850d096378dcab15bfc5f11c4bff848">CSL_MDIO_isMaskedUserCmdCompleteIntSet</a> (Uint32 index)</td></tr>
<tr class="separator:ga3850d096378dcab15bfc5f11c4bff848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa214d2214209a16d875304176948b9e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaa214d2214209a16d875304176948b9e2">CSL_MDIO_clearMaskedUserCmdCompleteInt</a> (Uint32 index)</td></tr>
<tr class="separator:gaa214d2214209a16d875304176948b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988cdb81e87c0fabaabf837f2ea994d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga988cdb81e87c0fabaabf837f2ea994d9">CSL_MDIO_enableUserCmdCompleteInterrupt</a> (Uint32 index)</td></tr>
<tr class="separator:ga988cdb81e87c0fabaabf837f2ea994d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857d949e50c3739fef0b59c1840f0863"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga857d949e50c3739fef0b59c1840f0863">CSL_MDIO_disableUserCmdCompleteInterrupt</a> (Uint32 index)</td></tr>
<tr class="separator:ga857d949e50c3739fef0b59c1840f0863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c6a833abfd5070b365d1cb6211589a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga32c6a833abfd5070b365d1cb6211589a">CSL_MDIO_getUserAccessRegister</a> (Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *pUserAccessReg)</td></tr>
<tr class="separator:ga32c6a833abfd5070b365d1cb6211589a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ec6c3fd8a5bf6d10cf7d3ebb237012"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga27ec6c3fd8a5bf6d10cf7d3ebb237012">CSL_MDIO_setUserAccessRegister</a> (Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *pUserAccessReg)</td></tr>
<tr class="separator:ga27ec6c3fd8a5bf6d10cf7d3ebb237012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af9a45a5c6ca3cfdd815e5e908992bf"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga4af9a45a5c6ca3cfdd815e5e908992bf">CSL_MDIO_isUserAccessPending</a> (Uint32 index)</td></tr>
<tr class="separator:ga4af9a45a5c6ca3cfdd815e5e908992bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c8c9a443f8ee69f13e61e267fa7633"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga95c8c9a443f8ee69f13e61e267fa7633">CSL_MDIO_enableLinkStatusChangeInterrupt</a> (Uint32 index, Uint32 phyAddr)</td></tr>
<tr class="separator:ga95c8c9a443f8ee69f13e61e267fa7633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5503f6478f0c27dae771dae37ca5085e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga5503f6478f0c27dae771dae37ca5085e">CSL_MDIO_disableLinkStatusChangeInterrupt</a> (Uint32 index, Uint32 phyAddr)</td></tr>
<tr class="separator:ga5503f6478f0c27dae771dae37ca5085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3bb26f450207da97de969750e3c1e4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab3bb26f450207da97de969750e3c1e4c">CSL_MDIO_getUserPhySelect</a> (Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_p_h_y_s_e_l.html">CSL_MDIO_USERPHYSEL</a> *pUserPhySelect)</td></tr>
<tr class="separator:gab3bb26f450207da97de969750e3c1e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga220522c98e0188cd20faf182153b147c"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga220522c98e0188cd20faf182153b147c">CSL_MDIO_phyRegRead</a> (uint32_t baseAddr, Uint32 phyAddr, Uint32 regNum, Uint16 *pData)</td></tr>
<tr class="separator:ga220522c98e0188cd20faf182153b147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a905ff8d52c08bc7f19fccbad793b07"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2a905ff8d52c08bc7f19fccbad793b07">CSL_MDIO_phyRegWrite</a> (uint32_t baseAddr, uint32_t phyAddr, uint32_t regNum, uint16_t wrVal)</td></tr>
<tr class="memdesc:ga2a905ff8d52c08bc7f19fccbad793b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API writes a PHY register using MDIO.  <a href="#ga2a905ff8d52c08bc7f19fccbad793b07">More...</a><br /></td></tr>
<tr class="separator:ga2a905ff8d52c08bc7f19fccbad793b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7f801c55a4b16c4f6b71d39c36c747"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaec7f801c55a4b16c4f6b71d39c36c747">CSL_MDIO_phyAliveStatus</a> (uint32_t baseAddr, uint32_t phyAddr)</td></tr>
<tr class="memdesc:gaec7f801c55a4b16c4f6b71d39c36c747"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the alive status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY is alive.  <a href="#gaec7f801c55a4b16c4f6b71d39c36c747">More...</a><br /></td></tr>
<tr class="separator:gaec7f801c55a4b16c4f6b71d39c36c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafabf75c2c29bead23f2a73623673c626"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gafabf75c2c29bead23f2a73623673c626">CSL_MDIO_phyLinkStatus</a> (uint32_t baseAddr, uint32_t phyAddr)</td></tr>
<tr class="memdesc:gafabf75c2c29bead23f2a73623673c626"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the link status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY link is active.  <a href="#gafabf75c2c29bead23f2a73623673c626">More...</a><br /></td></tr>
<tr class="separator:gafabf75c2c29bead23f2a73623673c626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35310b54635ddedbdb1ad817d2ae78fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga35310b54635ddedbdb1ad817d2ae78fd">CSL_MDIO_init</a> (uint32_t baseAddr, uint32_t mdioInputFreq, uint32_t mdioOutputFreq)</td></tr>
<tr class="memdesc:ga35310b54635ddedbdb1ad817d2ae78fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API initializes the MDIO peripheral. This enables the MDIO state machine, uses standard pre-amble and set the clock divider value.  <a href="#ga35310b54635ddedbdb1ad817d2ae78fd">More...</a><br /></td></tr>
<tr class="separator:ga35310b54635ddedbdb1ad817d2ae78fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga059dc3a4f3c0a0e449f618f9b9dbb939"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga059dc3a4f3c0a0e449f618f9b9dbb939">CSL_MDIO_phyUserPhySel</a> (uint32_t baseAddr, uint32_t phyNum, uint32_t val)</td></tr>
<tr class="memdesc:ga059dc3a4f3c0a0e449f618f9b9dbb939"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API initializes the MDIO peripheral. This enables the MDIO state machine, uses standard pre-amble and set the clock divider value.  <a href="#ga059dc3a4f3c0a0e449f618f9b9dbb939">More...</a><br /></td></tr>
<tr class="separator:ga059dc3a4f3c0a0e449f618f9b9dbb939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd83a6819b915a0d9e8b515ed7f3dfa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6bd83a6819b915a0d9e8b515ed7f3dfa">CSL_MDIO_getVersionInfo</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, <a class="el" href="struct_c_s_l___m_d_i_o___v_e_r_s_i_o_n.html">CSL_MDIO_VERSION</a> *mdioVersionInfo)</td></tr>
<tr class="separator:ga6bd83a6819b915a0d9e8b515ed7f3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20a626416ca7125be1545a95cd66709"><td class="memItemLeft" align="right" valign="top">static Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab20a626416ca7125be1545a95cd66709">CSL_MDIO_getClkDivVal</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gab20a626416ca7125be1545a95cd66709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc18b198608a78476332ab9c4085c28"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaedc18b198608a78476332ab9c4085c28">CSL_MDIO_setClkDivVal</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint16 clkDivVal)</td></tr>
<tr class="separator:gaedc18b198608a78476332ab9c4085c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c70618fd2cb21f7d8879fbe2b65f168"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6c70618fd2cb21f7d8879fbe2b65f168">CSL_MDIO_isFaultDetectEnabled</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga6c70618fd2cb21f7d8879fbe2b65f168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc2b39a72e45c0286d1fe4e09f5a9cc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gadc2b39a72e45c0286d1fe4e09f5a9cc1">CSL_MDIO_enableFaultDetect</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gadc2b39a72e45c0286d1fe4e09f5a9cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba9f1eb2720ebed87f45eed0bb67b84"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2ba9f1eb2720ebed87f45eed0bb67b84">CSL_MDIO_disableFaultDetect</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga2ba9f1eb2720ebed87f45eed0bb67b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42fb295f8cfdc1578d68bbbb03a5013"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gab42fb295f8cfdc1578d68bbbb03a5013">CSL_MDIO_isFaultDetected</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gab42fb295f8cfdc1578d68bbbb03a5013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ad2f6d10b7232dcdcadb5cddecab4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga37ad2f6d10b7232dcdcadb5cddecab4d">CSL_MDIO_clearFault</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga37ad2f6d10b7232dcdcadb5cddecab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf803c6348c0e8289a1b5720e1b9f442d"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf803c6348c0e8289a1b5720e1b9f442d">CSL_MDIO_isPreambleEnabled</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gaf803c6348c0e8289a1b5720e1b9f442d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1011ab5614e23056bbc523206439593e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga1011ab5614e23056bbc523206439593e">CSL_MDIO_enablePreamble</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga1011ab5614e23056bbc523206439593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd81e0475eee9c175b356076ee63ef43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabd81e0475eee9c175b356076ee63ef43">CSL_MDIO_disablePreamble</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:gabd81e0475eee9c175b356076ee63ef43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1983a5b2083d4330e3fc5461a0fb6870"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga1983a5b2083d4330e3fc5461a0fb6870">CSL_MDIO_getHighestUserChannel</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga1983a5b2083d4330e3fc5461a0fb6870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58317a6b85eaea74572c9459bbff1f9a"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga58317a6b85eaea74572c9459bbff1f9a">CSL_MDIO_isStateMachineEnabled</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga58317a6b85eaea74572c9459bbff1f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23cb0c1c940dfc1cf4bad55ce9aced10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga23cb0c1c940dfc1cf4bad55ce9aced10">CSL_MDIO_enableStateMachine</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga23cb0c1c940dfc1cf4bad55ce9aced10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47dfbbad63c3d47f14e9961cb0534863"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga47dfbbad63c3d47f14e9961cb0534863">CSL_MDIO_disableStateMachine</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga47dfbbad63c3d47f14e9961cb0534863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0363acaa7928d8cb73444a3f2bf4abd7"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga0363acaa7928d8cb73444a3f2bf4abd7">CSL_MDIO_isStateMachineIdle</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>)</td></tr>
<tr class="separator:ga0363acaa7928d8cb73444a3f2bf4abd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd000c0d87221419b0bab63ee4d18e0"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gacdd000c0d87221419b0bab63ee4d18e0">CSL_MDIO_isPhyAlive</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 phyAddr)</td></tr>
<tr class="separator:gacdd000c0d87221419b0bab63ee4d18e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b73610734f967973f49b16d3efe97e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga4b73610734f967973f49b16d3efe97e5">CSL_MDIO_clearPhyAliveStatus</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 phyAddr)</td></tr>
<tr class="separator:ga4b73610734f967973f49b16d3efe97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfece98ef6d3e7f9ea901c035b5a7c67"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gabfece98ef6d3e7f9ea901c035b5a7c67">CSL_MDIO_isPhyLinked</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 phyAddr)</td></tr>
<tr class="separator:gabfece98ef6d3e7f9ea901c035b5a7c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga412732070fb23c65a3a0a87321af5f54"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga412732070fb23c65a3a0a87321af5f54">CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga412732070fb23c65a3a0a87321af5f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a9286ead1935ab1dff20ec37132421"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga11a9286ead1935ab1dff20ec37132421">CSL_MDIO_clearUnmaskedLinkStatusChangeInt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga11a9286ead1935ab1dff20ec37132421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6475c337eadb38721cb629f5362973fe"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga6475c337eadb38721cb629f5362973fe">CSL_MDIO_isMaskedLinkStatusChangeIntSet</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga6475c337eadb38721cb629f5362973fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3f2575524d044cae67eeec5d6b1b18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaae3f2575524d044cae67eeec5d6b1b18">CSL_MDIO_clearMaskedLinkStatusChangeInt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:gaae3f2575524d044cae67eeec5d6b1b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8c9f47aa7f29912680c3df795d9446"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaff8c9f47aa7f29912680c3df795d9446">CSL_MDIO_isUnmaskedUserCmdCompleteIntSet</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:gaff8c9f47aa7f29912680c3df795d9446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf65b1788320f5608231e46d39f294cdc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf65b1788320f5608231e46d39f294cdc">CSL_MDIO_clearUnmaskedUserCmdCompleteInt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:gaf65b1788320f5608231e46d39f294cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b8cfa629b2d47de0ee6289474aa355"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga54b8cfa629b2d47de0ee6289474aa355">CSL_MDIO_isMaskedUserCmdCompleteIntSet</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga54b8cfa629b2d47de0ee6289474aa355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad680d0316a7b0c9df3690f14af6830cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gad680d0316a7b0c9df3690f14af6830cc">CSL_MDIO_clearMaskedUserCmdCompleteInt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:gad680d0316a7b0c9df3690f14af6830cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f571baecba3850c3ba3111dc1de6ee7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga5f571baecba3850c3ba3111dc1de6ee7">CSL_MDIO_enableUserCmdCompleteInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga5f571baecba3850c3ba3111dc1de6ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171bb85b0b8005202dbe2ef18b0af37e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga171bb85b0b8005202dbe2ef18b0af37e">CSL_MDIO_disableUserCmdCompleteInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga171bb85b0b8005202dbe2ef18b0af37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf084a65c1ee267f8c680d2a98e3c9046"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaf084a65c1ee267f8c680d2a98e3c9046">CSL_MDIO_getUserAccessRegister</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *pUserAccessReg)</td></tr>
<tr class="separator:gaf084a65c1ee267f8c680d2a98e3c9046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73b16285da69873db11505a9132f52f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaa73b16285da69873db11505a9132f52f">CSL_MDIO_setUserAccessRegister</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, const <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *pUserAccessReg)</td></tr>
<tr class="separator:gaa73b16285da69873db11505a9132f52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb317435b4b51e1c5cec7ae9f4ea250"><td class="memItemLeft" align="right" valign="top">static Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga0eb317435b4b51e1c5cec7ae9f4ea250">CSL_MDIO_isUserAccessPending</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index)</td></tr>
<tr class="separator:ga0eb317435b4b51e1c5cec7ae9f4ea250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0883e77c05a0dad059571fde36dac4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga5f0883e77c05a0dad059571fde36dac4">CSL_MDIO_enableLinkStatusChangeInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, Uint32 phyAddr)</td></tr>
<tr class="separator:ga5f0883e77c05a0dad059571fde36dac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cafde38fabebc620ff05969b484534b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga2cafde38fabebc620ff05969b484534b">CSL_MDIO_disableLinkStatusChangeInterrupt</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, Uint32 phyAddr)</td></tr>
<tr class="separator:ga2cafde38fabebc620ff05969b484534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1f60dd31bd0b9488df7ca67e261c6b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga0d1f60dd31bd0b9488df7ca67e261c6b">CSL_MDIO_getUserPhySelect</a> (CSL_mdioHandle <a class="el" href="group___c_s_l___m_d_i_o___d_a_t_a_s_t_r_u_c_t.html#gaa8aca0c688f0a8e2604e83486dab1337">hMdioRegs</a>, Uint32 index, <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_p_h_y_s_e_l.html">CSL_MDIO_USERPHYSEL</a> *pUserPhySelect)</td></tr>
<tr class="separator:ga0d1f60dd31bd0b9488df7ca67e261c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cbf6a6ea42ae6990f7b6ce4d4e588ce"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga8cbf6a6ea42ae6990f7b6ce4d4e588ce">MDIO_open</a> (int instNum, Uint32 mdioModeFlags, Uint32 phyAddr, Handle hMDIO)</td></tr>
<tr class="separator:ga8cbf6a6ea42ae6990f7b6ce4d4e588ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ff45ebea999c71e352fa3da9c03cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga30ff45ebea999c71e352fa3da9c03cbf">MDIO_close</a> (Handle hMDIO)</td></tr>
<tr class="separator:ga30ff45ebea999c71e352fa3da9c03cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa5d91d9bd4ca264e9b2ff50ef695ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaaaa5d91d9bd4ca264e9b2ff50ef695ad">MDIO_getStatus</a> (Handle hMDIO, Uint32 *pPhy, Uint32 *pLinkStatus)</td></tr>
<tr class="separator:gaaaa5d91d9bd4ca264e9b2ff50ef695ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5e68c5d7d4dce64e45890a729f8221b"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaa5e68c5d7d4dce64e45890a729f8221b">MDIO_timerTick</a> (Handle hMDIO)</td></tr>
<tr class="separator:gaa5e68c5d7d4dce64e45890a729f8221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab3e2e8aa8e79e449b906f80a13b7434"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaab3e2e8aa8e79e449b906f80a13b7434">MDIO_initPHY</a> (Handle hMDIO, Uint32 phyAddr)</td></tr>
<tr class="separator:gaab3e2e8aa8e79e449b906f80a13b7434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2d0b45996aceb645d27b98b86e93dc"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga7b2d0b45996aceb645d27b98b86e93dc">MDIO_phyRegRead</a> (Uint32 phyIdx, Uint32 phyReg, Uint16 *pData)</td></tr>
<tr class="separator:ga7b2d0b45996aceb645d27b98b86e93dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacef10d15f13cd54cf4eca8a97290114"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaacef10d15f13cd54cf4eca8a97290114">MDIO_phyRegWrite</a> (Uint32 phyIdx, Uint32 phyReg, Uint16 data)</td></tr>
<tr class="separator:gaacef10d15f13cd54cf4eca8a97290114"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaba0be476a73b57e2c6ff6d3a082f3752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearFault </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearFault</b> </p>
<p><b>Description</b> <br />
 This function clears the 'FAULT' bit of the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the 'FAULT' bit of MDIO 'CONTROL_REG'.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT=1</p>
<p><b>Affects</b> <br />
 MDIO_CONTROL_REG_FAULT=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Clear MDIO fault bit
       CSL_MDIO_clearFault ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga37ad2f6d10b7232dcdcadb5cddecab4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearFault </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearFault</b> </p>
<p><b>Description</b> <br />
 This function clears the 'FAULT' bit of the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the 'FAULT' bit of MDIO 'CONTROL_REG'.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT=1</p>
<p><b>Affects</b> <br />
 MDIO_CONTROL_REG_FAULT=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Clear MDIO fault bit
       CSL_MDIO_clearFault ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga435e5615f18a341469b06c50582c928c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearMaskedLinkStatusChangeInt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearMaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTMASKED' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearMaskedLinkStatusChangeInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaae3f2575524d044cae67eeec5d6b1b18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearMaskedLinkStatusChangeInt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearMaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTMASKED' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearMaskedLinkStatusChangeInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa214d2214209a16d875304176948b9e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearMaskedUserCmdCompleteInt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearMaskedUserCmdCompleteInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function clears the 'USERINTMASKED' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be cleared. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the User command complete interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearMaskedUserCmdCompleteInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad680d0316a7b0c9df3690f14af6830cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearMaskedUserCmdCompleteInt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearMaskedUserCmdCompleteInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function clears the 'USERINTMASKED' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be cleared. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the User command complete interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearMaskedUserCmdCompleteInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga90419ccafe7119ac63833d240e748ded"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearPhyAliveStatus </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearPhyAliveStatus</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function clears the 'ALIVE' bit corresponding to that PHY.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be cleared.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the ALIVE bit for the PHY address specified</p>
<p><b>Writes</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Clear PHY 0 alive status bit
       CSL_MDIO_clearPhyAliveStatus (phyAddr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4b73610734f967973f49b16d3efe97e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearPhyAliveStatus </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearPhyAliveStatus</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function clears the 'ALIVE' bit corresponding to that PHY.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be cleared.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the ALIVE bit for the PHY address specified</p>
<p><b>Writes</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Clear PHY 0 alive status bit
       CSL_MDIO_clearPhyAliveStatus (phyAddr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga301389b248d69524480aa4d0dd76cb9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearUnmaskedLinkStatusChangeInt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearUnmaskedLinkStatusChangeInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga11a9286ead1935ab1dff20ec37132421"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearUnmaskedLinkStatusChangeInt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedLinkStatusChangeInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function clears the 'LINKINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the Link change interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_LINK_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearUnmaskedLinkStatusChangeInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8368908148e23780da4108de5860a338"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearUnmaskedUserCmdCompleteInt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedUserCmdCompleteInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function clears the 'USERINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the unmasked user
*                          command complete interrupt bit must be cleared. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the User command complete interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearUnmaskedUserCmdCompleteInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf65b1788320f5608231e46d39f294cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_clearUnmaskedUserCmdCompleteInt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_clearUnmaskedUserCmdCompleteInt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function clears the 'USERINTRAW' register contents corresponding to it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the unmasked user
*                          command complete interrupt bit must be cleared. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Clears the User command complete interrupt.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_clearUnmaskedUserCmdCompleteInt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2f5e939587cdc5fd3fbc5e45c90d8497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableFaultDetect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableFaultDetect</b> </p>
<p><b>Description</b> <br />
 This function disables the Physical layer fault detection mechanism by setting 'FAULTENB' bit of the MDIO Control register to 0.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables PHY layer fault detection.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable Phy Layer fault detection
       CSL_MDIO_disableFaultDetect ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2ba9f1eb2720ebed87f45eed0bb67b84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableFaultDetect </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableFaultDetect</b> </p>
<p><b>Description</b> <br />
 This function disables the Physical layer fault detection mechanism by setting 'FAULTENB' bit of the MDIO Control register to 0.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables PHY layer fault detection.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable Phy Layer fault detection
       CSL_MDIO_disableFaultDetect ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5503f6478f0c27dae771dae37ca5085e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableLinkStatusChangeInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableLinkStatusChangeInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the 'LINKINTENB' bit to 0 for a PHY address 'phyAddr' being monitored by the MDIO module. This configuration is done for the 'USERPHYSEL' register corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      phyAddr             PHY Address for which the Link Status change interrupt
*                          must be disabled.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for the index specified.Link Status Change interrupt disabled for PHY address specified.</p>
<p><b>Writes</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable PHY 0's interrupt
       CSL_MDIO_disableLinkStatusChangeInterrupt (0, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2cafde38fabebc620ff05969b484534b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableLinkStatusChangeInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableLinkStatusChangeInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the 'LINKINTENB' bit to 0 for a PHY address 'phyAddr' being monitored by the MDIO module. This configuration is done for the 'USERPHYSEL' register corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      phyAddr             PHY Address for which the Link Status change interrupt
*                          must be disabled.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for the index specified.Link Status Change interrupt disabled for PHY address specified.</p>
<p><b>Writes</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable PHY 0's interrupt
       CSL_MDIO_disableLinkStatusChangeInterrupt (0, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadf9be255ed97beccd423e88743828864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disablePreamble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disablePreamble</b> </p>
<p><b>Description</b> <br />
 This function disables the MDIO preamble.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables MDIO Preamble frames.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_PREAMBLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable MDIO preamble frames
       CSL_MDIO_disablePreamble ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabd81e0475eee9c175b356076ee63ef43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disablePreamble </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disablePreamble</b> </p>
<p><b>Description</b> <br />
 This function disables the MDIO preamble.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables MDIO Preamble frames.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_PREAMBLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable MDIO preamble frames
       CSL_MDIO_disablePreamble ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2180daf47153154f3274344973e3c553"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableStateMachine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableStateMachine</b> </p>
<p><b>Description</b> <br />
 This function sets the 'ENABLE' bit of the MDIO control register to 0, triggering the disable of MDIO state machine if active.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 If the MDIO state machine is active at the time it is disabled, will complete the current operation before halting it and setting the idle bit.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable MDIO state machine
       CSL_MDIO_disableStateMachine ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga47dfbbad63c3d47f14e9961cb0534863"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableStateMachine </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableStateMachine</b> </p>
<p><b>Description</b> <br />
 This function sets the 'ENABLE' bit of the MDIO control register to 0, triggering the disable of MDIO state machine if active.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 If the MDIO state machine is active at the time it is disabled, will complete the current operation before halting it and setting the idle bit.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Disable MDIO state machine
       CSL_MDIO_disableStateMachine ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga857d949e50c3739fef0b59c1840f0863"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableUserCmdCompleteInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableUserCmdCompleteInterrupt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function disables the user command complete interrupts for it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be enabled. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables the interrupt for User command complete events posted using USERACCESS register.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASK_CLEAR_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_disableUserCmdCompleteInterrupt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga171bb85b0b8005202dbe2ef18b0af37e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_disableUserCmdCompleteInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_disableUserCmdCompleteInterrupt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function disables the user command complete interrupts for it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be enabled. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Disables the interrupt for User command complete events posted using USERACCESS register.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASK_CLEAR_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_disableUserCmdCompleteInterrupt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1a031867aebcf35b370abcd2bce357b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableFaultDetect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableFaultDetect</b> </p>
<p><b>Description</b> <br />
 This function enables the Physical layer fault detection mechanism by setting 'FAULTENB' bit of the MDIO Control register to 1.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables PHY layer fault detection.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable Phy Layer fault detection
       CSL_MDIO_enableFaultDetect ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gadc2b39a72e45c0286d1fe4e09f5a9cc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableFaultDetect </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableFaultDetect</b> </p>
<p><b>Description</b> <br />
 This function enables the Physical layer fault detection mechanism by setting 'FAULTENB' bit of the MDIO Control register to 1.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables PHY layer fault detection.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable Phy Layer fault detection
       CSL_MDIO_enableFaultDetect ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga95c8c9a443f8ee69f13e61e267fa7633"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableLinkStatusChangeInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableLinkStatusChangeInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the 'LINKINTENB' bit to 1 for a PHY address 'phyAddr' being monitored by the MDIO module. This configuration is done for the 'USERPHYSEL' register corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      phyAddr             PHY Address for which the Link Status change interrupt
*                          must be enabled.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for the index specified. Link Status Change interrupt enabled for PHY address specified.</p>
<p><b>Writes</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable PHY 0's interrupt
       CSL_MDIO_enableLinkStatusChangeInterrupt (0, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5f0883e77c05a0dad059571fde36dac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableLinkStatusChangeInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableLinkStatusChangeInterrupt</b> </p>
<p><b>Description</b> <br />
 This function sets the 'LINKINTENB' bit to 1 for a PHY address 'phyAddr' being monitored by the MDIO module. This configuration is done for the 'USERPHYSEL' register corresponding to the index specified here.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      phyAddr             PHY Address for which the Link Status change interrupt
*                          must be enabled.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 USERPHYSEL register's 'PHYADDRMON' and 'LINKINTENB' bits are configured for the index specified. Link Status Change interrupt enabled for PHY address specified.</p>
<p><b>Writes</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable PHY 0's interrupt
       CSL_MDIO_enableLinkStatusChangeInterrupt (0, 0);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga097444696f4fb33d45e9b99df49cf338"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enablePreamble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enablePreamble</b> </p>
<p><b>Description</b> <br />
 This function enables the MDIO preamble.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables MDIO Preamble frames.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_PREAMBLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable MDIO preamble frames
       CSL_MDIO_enablePreamble ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1011ab5614e23056bbc523206439593e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enablePreamble </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enablePreamble</b> </p>
<p><b>Description</b> <br />
 This function enables the MDIO preamble.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables MDIO Preamble frames.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_PREAMBLE=0</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable MDIO preamble frames
       CSL_MDIO_enablePreamble ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabbd659c7512d86a249876f8a4977189b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableStateMachine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableStateMachine</b> </p>
<p><b>Description</b> <br />
 This function enables the MDIO state machine if not already active.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables MDIO State machine.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable MDIO state machine
       CSL_MDIO_enableStateMachine ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga23cb0c1c940dfc1cf4bad55ce9aced10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableStateMachine </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableStateMachine</b> </p>
<p><b>Description</b> <br />
 This function enables the MDIO state machine if not already active.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables MDIO State machine.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">*
       // Enable MDIO state machine
       CSL_MDIO_enableStateMachine ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga988cdb81e87c0fabaabf837f2ea994d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableUserCmdCompleteInterrupt </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableUserCmdCompleteInterrupt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function enables the user command complete interrupts for it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be enabled. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables the interrupt for User command complete events posted using USERACCESS register.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASK_SET_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_enableUserCmdCompleteInterrupt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5f571baecba3850c3ba3111dc1de6ee7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_enableUserCmdCompleteInterrupt </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_enableUserCmdCompleteInterrupt</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function enables the user command complete interrupts for it.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be enabled. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Enables the interrupt for User command complete events posted using USERACCESS register.</p>
<p><b>Writes</b> <br />
 MDIO_USER_INT_MASK_SET_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       CSL_MDIO_enableUserCmdCompleteInterrupt (index);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad9bfcf528850710276444ffa0d8aa097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint16 CSL_MDIO_getClkDivVal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function retrieves the clock divider value (CLKDIV) from the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint16      clkDivVal;

       clkDivVal   =   CSL_MDIO_getClkDivVal ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab20a626416ca7125be1545a95cd66709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint16 CSL_MDIO_getClkDivVal </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function retrieves the clock divider value (CLKDIV) from the MDIO control register.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint16      clkDivVal;

       clkDivVal   =   CSL_MDIO_getClkDivVal ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6faf36fb963a6035e02494d14f1087b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_getHighestUserChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getHighestUserChannel</b> </p>
<p><b>Description</b> <br />
 This function returns the highest user access channel available in MDIO module.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_HIGHEST_USER_CHANNEL</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  userAccChannel;

       // Get the highest user access channel.
       userAccChannel = CSL_MDIO_getHighestUserChannel ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1983a5b2083d4330e3fc5461a0fb6870"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_getHighestUserChannel </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getHighestUserChannel</b> </p>
<p><b>Description</b> <br />
 This function returns the highest user access channel available in MDIO module.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_HIGHEST_USER_CHANNEL</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32  userAccChannel;

       // Get the highest user access channel.
       userAccChannel = CSL_MDIO_getHighestUserChannel ();</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga32c6a833abfd5070b365d1cb6211589a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getUserAccessRegister </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *&#160;</td>
          <td class="paramname"><em>pUserAccessReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getUserAccessRegister</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the USERACCESS register corresponding to the 'index' (0-1) provided.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register contents
*                          must be read by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserAccessReg      CSL_MDIO_USERACCESS structure that needs to be
*                          populated with the User Access register contents.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_DATA, MDIO_USER_ACCESS_REG_PHYADR, MDIO_USER_ACCESS_REG_REGADR, MDIO_USER_ACCESS_REG_ACK, MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       // Get User Access Reg 0 contents
       CSL_MDIO_getUserAccessRegister (0, &amp;userAccReg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf084a65c1ee267f8c680d2a98e3c9046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getUserAccessRegister </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *&#160;</td>
          <td class="paramname"><em>pUserAccessReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getUserAccessRegister</b> </p>
<p><b>Description</b> <br />
 This function retrieves the contents of the USERACCESS register corresponding to the 'index' (0-1) provided.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register contents
*                          must be read by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserAccessReg      CSL_MDIO_USERACCESS structure that needs to be
*                          populated with the User Access register contents.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_DATA, MDIO_USER_ACCESS_REG_PHYADR, MDIO_USER_ACCESS_REG_REGADR, MDIO_USER_ACCESS_REG_ACK, MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       // Get User Access Reg 0 contents
       CSL_MDIO_getUserAccessRegister (0, &amp;userAccReg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab3bb26f450207da97de969750e3c1e4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getUserPhySelect </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_p_h_y_s_e_l.html">CSL_MDIO_USERPHYSEL</a> *&#160;</td>
          <td class="paramname"><em>pUserPhySelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getUserPhySelect</b> </p>
<p><b>Description</b> <br />
 This function reads the 'USERPHYSEL' register contents corresponding to the index specified here and returns its contents in the output param 'pUserPhySelect'.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserPhySelect      CSL_MDIO_USERPHYSEL structure that needs to be populated
*                          with register contents
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None.</p>
<p><b>Reads</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE, MDIO_USER_PHY_SEL_REG_LINKSEL</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERPHYSEL    userPhySelect;

       // Get USERPHYSEL0 contents
       CSL_MDIO_getUserPhySelect (0, &amp;userPhySelect);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0d1f60dd31bd0b9488df7ca67e261c6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getUserPhySelect </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_p_h_y_s_e_l.html">CSL_MDIO_USERPHYSEL</a> *&#160;</td>
          <td class="paramname"><em>pUserPhySelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getUserPhySelect</b> </p>
<p><b>Description</b> <br />
 This function reads the 'USERPHYSEL' register contents corresponding to the index specified here and returns its contents in the output param 'pUserPhySelect'.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERPHYSEL register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserPhySelect      CSL_MDIO_USERPHYSEL structure that needs to be populated
*                          with register contents
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None.</p>
<p><b>Reads</b> <br />
 MDIO_USER_PHY_SEL_REG_PHYADR_MON, MDIO_USER_PHY_SEL_REG_LINKINT_ENABLE, MDIO_USER_PHY_SEL_REG_LINKSEL</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERPHYSEL    userPhySelect;

       // Get USERPHYSEL0 contents
       CSL_MDIO_getUserPhySelect (0, &amp;userPhySelect);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4557f178ac850e79dea29c48a686e86a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getVersionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___v_e_r_s_i_o_n.html">CSL_MDIO_VERSION</a> *&#160;</td>
          <td class="paramname"><em>mdioVersionInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the MDIO version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mdioVersionInfo     CSL_MDIO_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_VERSION_REG_REVMINOR, MDIO_VERSION_REG_REVMAJ, MDIO_VERSION_REG_MODID</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_MDIO_VERSION    mdioVersionInfo;

       CSL_MDIO_getVersion (&amp;mdioVersionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6bd83a6819b915a0d9e8b515ed7f3dfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_getVersionInfo </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___v_e_r_s_i_o_n.html">CSL_MDIO_VERSION</a> *&#160;</td>
          <td class="paramname"><em>mdioVersionInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_getVersionInfo</b> </p>
<p><b>Description</b> <br />
 This function retrieves the MDIO version information.</p>
<p><b>Arguments</b> </p><pre class="fragment">       mdioVersionInfo     CSL_MDIO_VERSION structure that needs to be populated
                           with the version info read from the hardware.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_VERSION_REG_REVMINOR, MDIO_VERSION_REG_REVMAJ, MDIO_VERSION_REG_MODID</p>
<p><b>Example</b> </p><pre class="fragment">       CSL_MDIO_VERSION    mdioVersionInfo;

       CSL_MDIO_getVersion (&amp;mdioVersionInfo);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga35310b54635ddedbdb1ad817d2ae78fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mdioInputFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mdioOutputFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API initializes the MDIO peripheral. This enables the MDIO state machine, uses standard pre-amble and set the clock divider value. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_init</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">mdioInputFreq</td><td>The clock input to the MDIO module. <h1>mdioOutputFreq The clock output required on the MDIO bus. </h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga32f47898a451debf5ba44d1449b6a016"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isFaultDetected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isFaultDetected</b> </p>
<p><b>Description</b> <br />
 This function returns physical layer fault status, i.e., 1 to indicate that the MDIO module has detected a physical layer fault and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_FAULT</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isFaultDetected ())
     {
         // Physical Layer fault detected
     }
     else
     {
         // No Physical Layer fault detected
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab42fb295f8cfdc1578d68bbbb03a5013"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isFaultDetected </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isFaultDetected</b> </p>
<p><b>Description</b> <br />
 This function returns physical layer fault status, i.e., 1 to indicate that the MDIO module has detected a physical layer fault and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_FAULT</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isFaultDetected ())
     {
         // Physical Layer fault detected
     }
     else
     {
         // No Physical Layer fault detected
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga401a20e685cda37a7f0397970b14170e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isFaultDetectEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isFaultDetectEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Fault detect enable bit of the MDIO control register. The Fault detect enable bit indicates whether physical layer fault detection is enabled.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isFaultDetectEnabled ())
     {
         // MDIO/Physical Layer fault detection is enabled
     }
     else
     {
         // MDIO/Physical Layer fault detection is disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6c70618fd2cb21f7d8879fbe2b65f168"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isFaultDetectEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isFaultDetectEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Fault detect enable bit of the MDIO control register. The Fault detect enable bit indicates whether physical layer fault detection is enabled.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_FAULT_DETECT_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isFaultDetectEnabled ())
     {
         // MDIO/Physical Layer fault detection is enabled
     }
     else
     {
         // MDIO/Physical Layer fault detection is disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab798a906133056478c9488e24f86caba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isMaskedLinkStatusChangeIntSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isMaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTMASKED' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isMaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6475c337eadb38721cb629f5362973fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isMaskedLinkStatusChangeIntSet </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isMaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTMASKED' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isMaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3850d096378dcab15bfc5f11c4bff848"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isMaskedUserCmdCompleteIntSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isMaskedUserCmdCompleteIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function returns the 'USERINTMASKED' register contents corresponding to it. This functions returns a 1 to indicate that the previously scheduled PHY read/write command using that particular USERACCESS register has completed and corresponding USERINTMASKSET bit is set to 1 and returns 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be read. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isMaskedUserCmdCompleteIntSet (index))
       {
           // User command completed
       }
       else
       {
           // User command not done
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga54b8cfa629b2d47de0ee6289474aa355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isMaskedUserCmdCompleteIntSet </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isMaskedUserCmdCompleteIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function returns the 'USERINTMASKED' register contents corresponding to it. This functions returns a 1 to indicate that the previously scheduled PHY read/write command using that particular USERACCESS register has completed and corresponding USERINTMASKSET bit is set to 1 and returns 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the masked user
*                          command complete interrupt bit must be read. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_INT_MASKED_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isMaskedUserCmdCompleteIntSet (index))
       {
           // User command completed
       }
       else
       {
           // User command not done
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga29ff9103a8ec1e971aed43dd70c9ba98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPhyAlive </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyAlive</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'ALIVE' bit corresponding to that PHY; The function returns 1 to indicate that the most recent access for the address was acknowledged by the PHY and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Check if PHY Address 0 is alive
       if (CSL_MDIO_isPhyAlive (phyAddr))
       {
           // MDIO PHY 0 access succeeded
       }
       else
       {
           // MDIO PHY 0 access failed
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacdd000c0d87221419b0bab63ee4d18e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPhyAlive </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyAlive</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'ALIVE' bit corresponding to that PHY; The function returns 1 to indicate that the most recent access for the address was acknowledged by the PHY and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the alive bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Check if PHY Address 0 is alive
       if (CSL_MDIO_isPhyAlive (phyAddr))
       {
           // MDIO PHY 0 access succeeded
       }
       else
       {
           // MDIO PHY 0 access failed
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab48582314d31c05514880bf1a876f19d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPhyLinked </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyLinked</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'LINK' bit corresponding to that PHY; The function returns 1 to indicate that the corresponding PHY address has a link.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the link bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Check if PHY Address 0 link is up
       if (CSL_MDIO_isPhyLinked (phyAddr))
       {
           // MDIO PHY 0 link up
       }
       else
       {
           // MDIO PHY 0 link not up
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabfece98ef6d3e7f9ea901c035b5a7c67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPhyLinked </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPhyLinked</b> </p>
<p><b>Description</b> <br />
 For a given PHY address provided to this function in 'phyAddr', this function reads the 'LINK' bit corresponding to that PHY; The function returns 1 to indicate that the corresponding PHY address has a link.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      phyAddr             The PHY address number (0-31) for which the link bit
*                          status must be checked and returned by this function.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_LINK_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      phyAddr = 0;

       // Check if PHY Address 0 link is up
       if (CSL_MDIO_isPhyLinked (phyAddr))
       {
           // MDIO PHY 0 link up
       }
       else
       {
           // MDIO PHY 0 link not up
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga63d8e2fd526b92bee7e083664fb64cad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPreambleEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPreambleEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Preamble disable bit of the MDIO control register. It returns 1 to indicate the MDIO preamble is enabled and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_PREAMBLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isPreambleEnabled ())
     {
         // MDIO preamble enabled
     }
     else
     {
         // MDIO preamble disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf803c6348c0e8289a1b5720e1b9f442d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isPreambleEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isPreambleEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Preamble disable bit of the MDIO control register. It returns 1 to indicate the MDIO preamble is enabled and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_PREAMBLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isPreambleEnabled ())
     {
         // MDIO preamble enabled
     }
     else
     {
         // MDIO preamble disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga6f40d9fce00936f6ca05407b172f4977"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isStateMachineEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Enable bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is enabled and is active and 0 to indicate otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineEnabled ())
     {
         // MDIO state machine enabled
     }
     else
     {
         // MDIO state machine disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga58317a6b85eaea74572c9459bbff1f9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isStateMachineEnabled </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineEnabled</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the Enable bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is enabled and is active and 0 to indicate otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_ENABLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineEnabled ())
     {
         // MDIO state machine enabled
     }
     else
     {
         // MDIO state machine disabled
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae2cabb86c9ef1ed5b373debd0518c4ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isStateMachineIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineIdle</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the 'IDLE' bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is in idle state and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineIdle ())
     {
         // MDIO state machine idle
     }
     else
     {
         // MDIO state machine not idle
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0363acaa7928d8cb73444a3f2bf4abd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isStateMachineIdle </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isStateMachineIdle</b> </p>
<p><b>Description</b> <br />
 This function returns the value of the 'IDLE' bit of the MDIO control register. It returns 1 to indicate that the MDIO state machine is in idle state and 0 otherwise.</p>
<p><b>Arguments</b> None</p>
<p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_CONTROL_REG_IDLE</p>
<p><b>Example</b> </p><pre class="fragment">     if (CSL_MDIO_isStateMachineIdle ())
     {
         // MDIO state machine idle
     }
     else
     {
         // MDIO state machine not idle
     }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaf26e822a6ae7f8b3faa8316d06e83524"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUnmaskedLinkStatusChangeIntSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isUnmaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga412732070fb23c65a3a0a87321af5f54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUnmaskedLinkStatusChangeIntSet </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedLinkStatusChangeIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERPHYSEL register, this function returns the 'LINKINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the link status has changed for the PHY provided and 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the link status change
*                          bit must be read. Phy selector value 0 corresponds to the
*                          PHY address programmed in USERPHYSEL0 register and a Phy
*                          selector value 1 corresponds to the PHY address in
*                          USERPHYSEL1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_ALIVE_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isUnmaskedLinkStatusChangeIntSet (index))
       {
           // Link status has changed
       }
       else
       {
           // Link status has not changed
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gad90f7f7efb26f324b9b13ce0683f280f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUnmaskedUserCmdCompleteIntSet </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedUserCmdCompleteIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function returns the 'USERINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the previously scheduled PHY read/write command using that particular USERACCESS register has completed and returns 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the unmasked user
*                          command complete interrupt bit must be read. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isUnmaskedUserCmdCompleteIntSet (index))
       {
           // User command completed
       }
       else
       {
           // User command not done
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaff8c9f47aa7f29912680c3df795d9446"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUnmaskedUserCmdCompleteIntSet </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUnmaskedUserCmdCompleteIntSet</b> </p>
<p><b>Description</b> <br />
 For a given PHY selector(0-1) provided corresponding to the PHY address in USERACCESS register, this function returns the 'USERINTRAW' register contents corresponding to it. This functions returns a 1 to indicate that the previously scheduled PHY read/write command using that particular USERACCESS register has completed and returns 0 otherwise.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index              The PHY selector (0-1) for which the unmasked user
*                          command complete interrupt bit must be read. Phy selector
*                          value 0 corresponds to the PHY address used in USERACCESS0
*                          register and a Phy selector value 1 corresponds to the PHY
*                          address in USERACCESS1 register.
*   </pre><p><b> Return Value </b> Uint32</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 MDIO_USER_INT_RAW_REG</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint32      index = 0;

       if (CSL_MDIO_isUnmaskedUserCmdCompleteIntSet (index))
       {
           // User command completed
       }
       else
       {
           // User command not done
       }
       }</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4af9a45a5c6ca3cfdd815e5e908992bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUserAccessPending </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUserAccessPending</b> </p>
<p><b>Description</b> <br />
 This function reads the 'GO' bit of the USERACCESS register corresponding to the 'index' specified and returns its value. When 1 returned, indicates that the user access transaction (read/write) performed earlier is still pending and has not yet completed. 0 indicates that the transaction has completed.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register's GO bit
*                          must be read by this function. Valid values are 0-1,
*                          both inclusive.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None.</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       userAccessReg.data      =   1;
       userAccessReg.phyAddr   =   0;
       ...
       userAccessReg.go        =   1;

       // Set User Access Reg 0 contents
       CSL_MDIO_setUserAccessRegister (0, &amp;userAccReg);

       // Wait till the set completes
       while (CSL_MDIO_isUserAccessPending (0));</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0eb317435b4b51e1c5cec7ae9f4ea250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_isUserAccessPending </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_isUserAccessPending</b> </p>
<p><b>Description</b> <br />
 This function reads the 'GO' bit of the USERACCESS register corresponding to the 'index' specified and returns its value. When 1 returned, indicates that the user access transaction (read/write) performed earlier is still pending and has not yet completed. 0 indicates that the transaction has completed.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register's GO bit
*                          must be read by this function. Valid values are 0-1,
*                          both inclusive.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None.</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       userAccessReg.data      =   1;
       userAccessReg.phyAddr   =   0;
       ...
       userAccessReg.go        =   1;

       // Set User Access Reg 0 contents
       CSL_MDIO_setUserAccessRegister (0, &amp;userAccReg);

       // Wait till the set completes
       while (CSL_MDIO_isUserAccessPending (0));</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaec7f801c55a4b16c4f6b71d39c36c747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t CSL_MDIO_phyAliveStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API reads the alive status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY is alive. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyAliveStatus</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>PHY is present. <h1>FALSE PHY is not present. </h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafabf75c2c29bead23f2a73623673c626"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t CSL_MDIO_phyLinkStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API reads the link status of all PHY connected to this MDIO. The bit corresponding to the PHY address will be set if the PHY link is active. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyLinkStatus</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>PHY link is active. <h1>FALSE PHY link is inactive. </h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga220522c98e0188cd20faf182153b147c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Uint32 CSL_MDIO_phyRegRead </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>regNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_phyRegRead</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address. </td></tr>
    <tr><td class="paramname">regNum</td><td>Register Number to be read. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer where the read value shall be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Read is successful. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Read is not acknowledged properly. <h1></h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2a905ff8d52c08bc7f19fccbad793b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_phyRegWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wrVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API writes a PHY register using MDIO. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyRegWrite</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phyAddr</td><td>PHY Address. </td></tr>
    <tr><td class="paramname">regNum</td><td>Register Number to be written. <h1>wrVal Value to be written. </h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga059dc3a4f3c0a0e449f618f9b9dbb939"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_phyUserPhySel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>phyNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This API initializes the MDIO peripheral. This enables the MDIO state machine, uses standard pre-amble and set the clock divider value. </p>
<p>============================================================================ <br />
<b>CSL_MDIO_phyUserPhySel</b> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of the MDIO module. </td></tr>
    <tr><td class="paramname">phynum</td><td>The clock input to the MDIO module. <h1>val The clock output required on the MDIO bus. </h1>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga289deb7e32c4277eec786afd273408bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_setClkDivVal </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>clkDivVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_setClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function configures the clock divider value (CLKDIV) in the MDIO control register with the value specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       clkDivVal           The value to use for clock divider configuration.
                           When this set to 0, the MDIO clock is disabled.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CONTROL_REG configured with the clock divider value. Configures the MDIO clock frequency.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint16      clkDivVal;

       clkDivVal = 165;

       // Setup the MDIO clock frequency
       CSL_MDIO_setClkDivVal (clkDivVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaedc18b198608a78476332ab9c4085c28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_setClkDivVal </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>clkDivVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_setClkDivVal</b> </p>
<p><b>Description</b> <br />
 This function configures the clock divider value (CLKDIV) in the MDIO control register with the value specified.</p>
<p><b>Arguments</b> </p><pre class="fragment">       clkDivVal           The value to use for clock divider configuration.
                           When this set to 0, the MDIO clock is disabled.
*        </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 CONTROL_REG configured with the clock divider value. Configures the MDIO clock frequency.</p>
<p><b>Writes</b> <br />
 MDIO_CONTROL_REG_CLKDIV</p>
<p><b>Example</b> </p><pre class="fragment">*      Uint16      clkDivVal;

       clkDivVal = 165;

       // Setup the MDIO clock frequency
       CSL_MDIO_setClkDivVal (clkDivVal);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga27ec6c3fd8a5bf6d10cf7d3ebb237012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_setUserAccessRegister </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *&#160;</td>
          <td class="paramname"><em>pUserAccessReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_setUserAccessRegister</b> </p>
<p><b>Description</b> <br />
 This function configures the contents of the USERACCESS register corresponding to the 'index' (0-1) provided with the values provided in 'pUserAccessReg' input parameter.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserAccessReg      CSL_MDIO_USERACCESS structure that specifies the values
*                          that need to be configured into the User Access register
*                          contents.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 User Access Register(USERACCESS) corresponding to the index specified is configured.</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_DATA, MDIO_USER_ACCESS_REG_PHYADR, MDIO_USER_ACCESS_REG_REGADR, MDIO_USER_ACCESS_REG_WRITE, MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       userAccessReg.data      =   1;
       userAccessReg.phyAddr   =   0;
       ...
       userAccessReg.go        =   1;

       // Set User Access Reg 0 contents
       CSL_MDIO_setUserAccessRegister (0, &amp;userAccReg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa73b16285da69873db11505a9132f52f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_MDIO_setUserAccessRegister </td>
          <td>(</td>
          <td class="paramtype">CSL_mdioHandle&#160;</td>
          <td class="paramname"><em>hMdioRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___m_d_i_o___u_s_e_r_a_c_c_e_s_s.html">CSL_MDIO_USERACCESS</a> *&#160;</td>
          <td class="paramname"><em>pUserAccessReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_MDIO_setUserAccessRegister</b> </p>
<p><b>Description</b> <br />
 This function configures the contents of the USERACCESS register corresponding to the 'index' (0-1) provided with the values provided in 'pUserAccessReg' input parameter.</p>
<p><b>Arguments</b> </p><pre class="fragment">*      index               Specifies which of the USERACCESS register contents
*                          must be configured by this function. Valid values are 0-1,
*                          both inclusive.
*      pUserAccessReg      CSL_MDIO_USERACCESS structure that specifies the values
*                          that need to be configured into the User Access register
*                          contents.
*   </pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 User Access Register(USERACCESS) corresponding to the index specified is configured.</p>
<p><b>Reads</b> <br />
 MDIO_USER_ACCESS_REG_DATA, MDIO_USER_ACCESS_REG_PHYADR, MDIO_USER_ACCESS_REG_REGADR, MDIO_USER_ACCESS_REG_WRITE, MDIO_USER_ACCESS_REG_GO</p>
<p><b>Example</b> </p><pre class="fragment">*      CSL_MDIO_USERACCESS      userAccReg;

       userAccessReg.data      =   1;
       userAccessReg.phyAddr   =   0;
       ...
       userAccessReg.go        =   1;

       // Set User Access Reg 0 contents
       CSL_MDIO_setUserAccessRegister (0, &amp;userAccReg);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga30ff45ebea999c71e352fa3da9c03cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDIO_close </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hMDIO</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga30ff45ebea999c71e352fa3da9c03cbf">MDIO_close()</a></b> </p>
<p><b>Description</b> <br />
 Close the MDIO peripheral and disable further operation.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hMDIO   handle to the opened MDIO instance</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 MDIO module must be reset and opened before calling this function.</p>
<p><b> Post Condition </b> <br />
 MDIO module is closed. No further operations are possible.</p>
<p><b>Example:</b> </p><pre class="fragment">     #define MDIO_MODEFLG_FD1000      0x0020
     #define MDIO_MODEFLG_LOOPBACK       0x0040

     MDIO_Device    mdioDev;
     int            instNum = 0;
     Uint32    mdioModeFlags = MDIO_MODEFLG_FD1000 | MDIO_MODEFLG_LOOPBACK;
     Uint32         mdioPhyAddr = 0;

     MDIO_open(instNum, mdioModeFlags, mdioPhyAddr, &amp;mdioDev);

     MDIO_close( &amp;mdioDev );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaaa5d91d9bd4ca264e9b2ff50ef695ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDIO_getStatus </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hMDIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pPhy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pLinkStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaaaa5d91d9bd4ca264e9b2ff50ef695ad">MDIO_getStatus()</a></b> </p>
<p><b>Description</b> <br />
 Called to get the status of the MDIO/PHY</p>
<p><b>Arguments</b> </p><pre class="fragment">     hMDIO       handle to the opened MDIO instance
     pPhy        pointer to the physical address
     pLinkStatus pointer to the link status</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 MDIO module must be reset and opened before calling this API</p>
<p><b> Post Condition </b> <br />
 MDIO stauts is returned through the parameters paased in this API.</p>
<p><b>Example:</b> </p><pre class="fragment">     #define MDIO_MODEFLG_FD1000         0x0020
     #define MDIO_MODEFLG_LOOPBACK       0x0040

     MDIO_Device    mdioDev;
     int            instNum = 0;
     Uint32    mdioModeFlags = MDIO_MODEFLG_FD1000 | MDIO_MODEFLG_LOOPBACK;
     Uint32         mdioPhyAddr = 0;

     //Open the MDIO module
     MDIO_open(instNum, mdioModeFlags, mdioPhyAddr, &amp;mdioDev);

     MDIO_getStatus( &amp;mdioDev, &amp;pPhy, &amp;pLinkStatus );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaab3e2e8aa8e79e449b906f80a13b7434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MDIO_initPHY </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hMDIO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaab3e2e8aa8e79e449b906f80a13b7434">MDIO_initPHY()</a></b> </p>
<p><b>Description</b> <br />
 Force a switch to the specified PHY, and start the negotiation process.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hMDIO   handle to the opened MDIO instance
     phyAddr Physical address</pre><p><b> Return Value </b> <br />
 Returns 1 if the PHY selection completed OK, <br />
 else 0</p>
<p><b> Pre Condition </b> <br />
 MDIO module must be reset.</p>
<p><b> Post Condition </b> <br />
 Initializes the specific PHY device.</p>
<p><b>Example:</b> </p><pre class="fragment">     #define MDIO_MODEFLG_FD1000         0x0020
     #define MDIO_MODEFLG_LOOPBACK       0x0040

     MDIO_Device    mdioDev;
     int            instNum = 0;
     Uint32    mdioModeFlags = MDIO_MODEFLG_FD1000 | MDIO_MODEFLG_LOOPBACK;
     Uint32         mdioPhyAddr = 0;

     //Open the MDIO module
     MDIO_open(instNum, mdioModeFlags, mdioPhyAddr, &amp;mdioDev);

     MDIO_initPHY( &amp;mdioDev, mdioPhyAddr );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8cbf6a6ea42ae6990f7b6ce4d4e588ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MDIO_open </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>mdioModeFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hMDIO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interfaces for the MDIO.</p>
<dl class="section user"><dt></dt><dd><b> NOTE: </b> When used in an multitasking environment, no MDIO function may be called while another MDIO function is operating on the same device handle in another thread. It is the responsibility of the application to assure adherence to this restriction. ============================================================================ <br />
<b><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga8cbf6a6ea42ae6990f7b6ce4d4e588ce">MDIO_open()</a></b> </dd></dl>
<p><b>Description</b> <br />
 Opens the MDIO peripheral and initialize the MDIO state machine</p>
<p>It is assumed that the MDIO module is reset prior to calling this function.</p>
<p><b>Arguments</b> </p><pre class="fragment">     instNum         Instance number when user is specifying a PHY address for monitoring
                     i.e., MDIO_MODEFLG_SPECPHYADDR mode flag is set.
                     It is hard-coded as 0 when MDIO_MODEFLG_SPECPHYADDR is not set.
     mdioModeFlags   Mode flags
     phyAddr         PHY address user specifies for monitoring. It is bypassed when
                     MDIO_MODEFLG_SPECPHYADDR mode flag is not set.
     hMDIO           Handle to the MDIO device which needs to be initialized.</pre><p><b> Return Value </b> Success (0) <br />
 MDIO_ERROR_INVALID - A calling parameter is invalid</p>
<p><b> Pre Condition </b> <br />
 The MDIO module must be reset prior to calling this function.</p>
<p><b> Post Condition </b> <br />
 Opens the MDIO peripheral and initialize the MDIO state machine.</p>
<p><b>Example:</b> </p><pre class="fragment">     #define MDIO_MODEFLG_FD1000         0x0020
     #define MDIO_MODEFLG_LOOPBACK       0x0040

     MDIO_Device    mdioDev;
     int            instNum = 0;
     Uint32         mdioModeFlags = MDIO_MODEFLG_FD1000 | MDIO_MODEFLG_LOOPBACK;
     Uint32         mdioPhyAddr = 0;

     MDIO_open(instNum, mdioModeFlags, mdioPhyAddr, &amp;mdioDev);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7b2d0b45996aceb645d27b98b86e93dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MDIO_phyRegRead </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#ga7b2d0b45996aceb645d27b98b86e93dc">MDIO_phyRegRead()</a></b> </p>
<p><b>Description</b> <br />
 Raw data read of a PHY register.</p>
<p><b>Arguments</b> </p><pre class="fragment">     phyIdx  Physical Index
     phyReg  Physical register
     pData   Data read</pre><p><b> Return Value </b> <br />
 Returns 1 if the PHY ACK'd the read, <br />
 else 0</p>
<p><b> Pre Condition </b> <br />
 MDIO module must be reset and opened. PHY device must be initialized.</p>
<p><b> Post Condition </b> <br />
 Raw data is read from a PHY register.</p>
<p><b>Example:</b> </p><pre class="fragment">     #define MDIO_MODEFLG_FD1000         0x0020
     #define MDIO_MODEFLG_LOOPBACK       0x0040

     volatile Uint32 phyIdx = PHYREG_CONTROL;
     volatile Uint32 phyReg;
     Uint16 pData;

     MDIO_Device    mdioDev;
     int            instNum = 0;
     Uint32    mdioModeFlags = MDIO_MODEFLG_FD1000 | MDIO_MODEFLG_LOOPBACK;
     Uint32         mdioPhyAddr = 0;

     //Open the MDIO module
     MDIO_open(instNum, mdioModeFlags, mdioPhyAddr, &amp;mdioDev);

     MDIO_initPHY( &amp;mdioDev, mdioPhyAddr );

     MDIO_phyRegRead( phyIdx, ((MDIO_Device *)&amp;mdioDev)-&gt;phyReg, pData );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaacef10d15f13cd54cf4eca8a97290114"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MDIO_phyRegWrite </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>phyReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaacef10d15f13cd54cf4eca8a97290114">MDIO_phyRegWrite()</a></b> </p>
<p><b>Description</b> <br />
 Raw data write of a PHY register.</p>
<p><b>Arguments</b> </p><pre class="fragment">     phyIdx  Physical Index
     phyReg  Physical register
     pData   Data written</pre><p><b> Return Value </b> <br />
 Returns 1 if the PHY ACK'd the write, <br />
 else 0</p>
<p><b> Pre Condition </b> <br />
 MDIO module must be reset and opened. PHY device must be initialized.</p>
<p><b> Post Condition </b> <br />
 Raw data is written to a PHY register.</p>
<p><b>Example:</b> </p><pre class="fragment">     #define MDIO_MODEFLG_FD1000         0x0020
     #define MDIO_MODEFLG_LOOPBACK       0x0040
     #define PHYREG_SHADOW_EXTLOOPBACK   0x8400

     volatile Uint32 phyIdx = PHYREG_CONTROL;
     volatile Uint32 phyReg;
     Uint16 pData = PHYREG_SHADOW_EXTLOOPBACK;

     MDIO_Device    mdioDev;
     int            instNum = 0;
     Uint32    mdioModeFlags = MDIO_MODEFLG_FD1000 | MDIO_MODEFLG_LOOPBACK;
     Uint32         mdioPhyAddr = 0;

     //Open the MDIO module
     MDIO_open(instNum, mdioModeFlags, mdioPhyAddr, &amp;mdioDev);

     MDIO_initPHY( &amp;mdioDev, mdioPhyAddr );

     MDIO_phyRegWrite( phyIdx, ((MDIO_Device *)&amp;mdioDev)-&gt;phyReg, pData );</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaa5e68c5d7d4dce64e45890a729f8221b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 MDIO_timerTick </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>hMDIO</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b><a class="el" href="group___c_s_l___m_d_i_o___f_u_n_c_t_i_o_n.html#gaa5e68c5d7d4dce64e45890a729f8221b">MDIO_timerTick()</a></b> </p>
<p><b>Description</b> <br />
 Called to signify that approx 100mS have elapsed</p>
<p><b>Arguments</b> </p><pre class="fragment">     hMDIO   Handle to the opened MDIO instance</pre><p><b> Return Value </b> <br />
 MDIO event code (see MDIO Events).</p>
<p><b> Pre Condition </b> <br />
 MDIO module must be reset and opened before calling this API.</p>
<p><b> Post Condition </b> <br />
 Gets approximately 100mS delay</p>
<p><b>Example:</b> </p><pre class="fragment">     #define MDIO_MODEFLG_FD1000         0x0020
     #define MDIO_MODEFLG_LOOPBACK       0x0040

     MDIO_Device    mdioDev;
     int            instNum = 0;
     Uint32    mdioModeFlags = MDIO_MODEFLG_FD1000 | MDIO_MODEFLG_LOOPBACK;
     Uint32         mdioPhyAddr = 0;

     //Open the MDIO module
     MDIO_open(instNum, mdioModeFlags, mdioPhyAddr, &amp;mdioDev);

     MDIO_timerTick( &amp;mdioDev );</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
