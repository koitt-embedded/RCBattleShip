<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IMGLIB: IMG_erode_bin</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>IMG_erode_bin</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_m_g__erode__bin.html#gea87fcd88cd2952c18d315c4513674b7">IMG_erode_bin</a> (const unsigned char *restrict in_data, unsigned char *restrict out_data, const char *restrict mask, int cols)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gea87fcd88cd2952c18d315c4513674b7"></a><!-- doxytag: member="c66/IMG_erode_bin.h::IMG_erode_bin" ref="gea87fcd88cd2952c18d315c4513674b7" args="(const unsigned char *restrict in_data, unsigned char *restrict out_data, const char *restrict mask, int cols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMG_erode_bin           </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *restrict&nbsp;</td>
          <td class="paramname"> <em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *restrict&nbsp;</td>
          <td class="paramname"> <em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>The function <a class="el" href="group___i_m_g__erode__bin.html#gea87fcd88cd2952c18d315c4513674b7">IMG_erode_bin()</a> implements binary erosion using an arbitrary 3x3 mask. The erosion operator generates output pixels by ANDing the pixels under the input mask together to generate the output pixel. The input mask specifies whether one or more pixels from the input are to be ignored. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in_data</em>&nbsp;</td><td>Input image pointer (packed binary) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_data</em>&nbsp;</td><td>Output image pointer (packed binary) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Erosion filter mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cols</em>&nbsp;</td><td>Number of columns in the image</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Algorithm:</b></dt><dd>The filtering operation for a pixel at (x, y) works as illustrated by the following pseudo-code:</dd></dl>
<code> result = 1; if (mask[0][0] != DONT_CARE) result &amp;= input[y + 0][x + 0]; if (mask[0][1] != DONT_CARE) result &amp;= input[y + 1][x + 1]; if (mask[0][2] != DONT_CARE) result &amp;= input[y + 2][x + 2]; if (mask[1][0] != DONT_CARE) result &amp;= input[y + 0][x + 0]; if (mask[1][1] != DONT_CARE) result &amp;= input[y + 1][x + 1]; if (mask[1][2] != DONT_CARE) result &amp;= input[y + 2][x + 2]; if (mask[2][0] != DONT_CARE) result &amp;= input[y + 0][x + 0]; if (mask[2][1] != DONT_CARE) result &amp;= input[y + 1][x + 1]; if (mask[2][2] != DONT_CARE) result &amp;= input[y + 2][x + 2]; output[y][x] = result; </code><p>
<dl class="user" compact><dt><b></b></dt><dd>For the above code, "DONT_CARE" is specified by a negative value in the input mask. Non-negative values in the mask cause the corresponding pixel to be included in the erosion operation. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that this code operates on a bitmap where each pixel is represented as a single bit within a byte or word. Although the pseudo-code above operates only on one pixel at a time, with a single pixel in each array element, the implementation operates on a bitmap which contains 8 binary pixels per byte. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Pixels are organized within each byte such that the pixel with the smallest index is in the LSB, and the pixel with the largest index is in the MSB. (That is, the code assumes a LITTLE ENDIAN bit ordering.) </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that the "cols" argument actually specifies the number of BYTES in the output, not the number of columns. The number of columns is 8 times this argument. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The 3x3 erosion mask is applied to 32 output pixels simultaneously. This is achieved via the 32-bit bitwise operators in the register file. To accomlish this, the code reads in a 34-bit input window, and 40-bit operations are used to manipulate the pixels initially. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Because the code reads a 34-bit context for each 32-bits of output, the input needs to be one byte longer than the output in order to make the rightmost two pixels well-defined. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The natural C implementation has no restrictions. The optimized intrinsic C code has restrictions as noted in Assumptions below.</dd></dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The input array and output array should not overlap</li><li>Negative values in the mask specify "DONT_CARE", and non-negative values specify that pixels are included in the erosion operation.</li><li>The input image needs to have a multiple of 64 pixels (bits) per row. As such, the number of columns (cols) must be a multiple of 8.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible</li><li>This code is compatible with C66x processors</li><li>This code will work for little endian only</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See IMGLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2012, Texas Instruments Incorporated</small>
</body>
</html>
